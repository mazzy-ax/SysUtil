Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Error unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Error
    PROPERTIES
      Name                #Error
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classIdMismatch
        #//mazzy 24.03.2021
        #public static LabelType classIdMismatch(str _funcName, ClassId actual, ClassId expected)
        #{
        #    SysDictClass actualDc = new SysDictClass(actual);
        #    SysDictClass expectedDc = new SysDictClass(expected);
        #
        #    str actualStr = actualDc ? actualDc.toString() : strfmt('%1',actual);
        #    str expectedStr = expectedDc ? expectedDc.toString() : strfmt('%1', expected);
        #
        #    LabelType ret = strfmt('Class mismatch at %1: Actual: %2, Expected %3', _funcName, actualStr, expectedStr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedBuffer
        #//Eshp CL005598 2019/09/05
        #public static LabelType unsupportedBuffer(Common _common, str _funcName = '')
        #{
        #    LabelType ret;
        #    ;
        #
        #    if (_common.TableId)
        #    {
        #        ret = strfmt("Таблица %1 не поддерживается%2.",
        #                    SysDictTable::newTableId(_common.TableId).name(),
        #                    (_funcName ? (" в методе " + _funcName) : ''));
        #    }
        #    else
        #    {
        #        ret = Error::missingRecord(_funcName);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedEmptyString
        #// в качестве описания можно использовать название переменной
        #public static LabelType unsupportedEmptyString(str _funcName, anytype _description = '')
        #{
        #    LabelType ret = strfmt("Unsupported empty string in %1 %2", _funcName, _description);
        #
        #    return ret;
        #    }
      ENDSOURCE
      SOURCE #unsupportedEnum
        #//mazzy 28.11.2019
        #public static LabelType unsupportedEnum(str _funcName, anytype enumValue = '')
        #{
        #    LabelType ret;
        #;
        #
        #    if (typeof(enumValue) == Types::Enum)
        #    {
        #        ret = strfmt("Enum <%1:%2> не поддерживается %3. Обратитесь к разработчикам.", EnumId2Name(DictEnum::value2id(enumValue)), enumValue, _funcName);
        #    }
        #    else
        #    {
        #        ret = strfmt("Enum <%1> не поддерживается %2. Обратитесь к разработчикам.", enumValue, _funcName);
        #    }
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedNull
        #//mazzy 07.12.2020
        #public static LabelType unsupportedNull(str _funcName, anytype _varNameOrText = '')
        #{
        #    LabelType ret = strfmt("Unsupported Null in %1 %2", _funcName, _varNameOrText);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedType
        #//mazzy 24.03.2021
        #public static LabelType unsupportedType(str _funcName, anytype type = '')
        #{
        #    LabelType ret = strfmt("Unsupported Type %1 - %2", type, _funcName);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: Any unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Any
    PROPERTIES
      Name                #Any
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addToTextBuffer
        #// перенести в SysTextBuffer
        #// рекурсивно заполняет textBuffer
        #protected textBuffer addToTextBuffer(  str          _sep                        = ',',
        #                                       boolean      _queryValue                 = false,
        #                                       boolean      _usingExtendedQuery_MRC     = false,
        #                                       TextBuffer   _textBuffer                 = null)
        #{
        #    Types   type    = typeof(value);
        #    int     i;
        #    int     len;
        #    str     s;
        #;
        #
        #    if (_textBuffer == null)
        #    {
        #        _textBuffer = new TextBuffer();
        #    }
        #
        #    switch(type)
        #    {
        #        case Types::Container:
        #            len = conlen(value);
        #            for(i=1; i<=len; ++i)
        #            {
        #                if(i>1)
        #                {
        #                    _textBuffer.appendText(_sep);
        #                }
        #                _textBuffer = Any::conpeek(value, i).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
        #            }
        #            break;
        #
        #        case Types::Class:
        #            if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(Set)))
        #            {
        #                _textBuffer = Any::construct(ConUtil::newFromSet(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
        #                break;
        #            }
        #            else if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(List)))
        #            {
        #                _textBuffer = Any::construct(ConUtil::newFromList(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
        #                break;
        #            }
        #            else if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(Array)))
        #            {
        #                _textBuffer = Any::construct(ConUtil::newFromArray(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
        #                break;
        #            }
        #            // no break! проваливаемся ниже
        #        case Types::Record:
        #        case Types::AnyType:
        #        case Types::BLOB:
        #        case Types::void:
        #            throw error(Error::unsupportedEnum(funcname(), type));
        #
        #        default:
        #            s = _queryValue ? SysQuery::value_MRC(value) : AnytypeUtil::toString(value);
        #            _textBuffer.appendText(s);
        #            break;
        #    }
        #
        #    return _textBuffer;
        #}
      ENDSOURCE
      SOURCE #as
        #public anytype as(Types type, int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::as(this.value(), type, potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #asArray
        #public Array asArray()
        #{
        #    return AnytypeUtil::asArray(this.value());
        #}
      ENDSOURCE
      SOURCE #asClass
        #public Object asClass(ClassId potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::asClass(this.value(), potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #asContainer
        #public container asContainer()
        #{
        #    return AnytypeUtil::asContainer(this.value());
        #}
      ENDSOURCE
      SOURCE #asDate
        #public Date asDate()
        #{
        #    return AnytypeUtil::asDate(this.value());
        #}
      ENDSOURCE
      SOURCE #asDateTime
        #public UtcDateTime asDateTime()
        #{
        #    return AnytypeUtil::asDateTime(this.value());
        #}
      ENDSOURCE
      SOURCE #asEnum
        #public anytype asEnum(enumId enumId = 0)
        #{
        #    return AnytypeUtil::asEnum(this.value(), enumId);
        #}
      ENDSOURCE
      SOURCE #asGUID
        #public GUID asGUID()
        #{
        #    return AnytypeUtil::asGUID(this.value());
        #}
      ENDSOURCE
      SOURCE #asInt
        #public int asInt()
        #{
        #    return AnytypeUtil::asInt(this.value());
        #}
      ENDSOURCE
      SOURCE #asInt64
        #public int64 asInt64()
        #{
        #    return AnytypeUtil::asInt64(this.value());
        #}
      ENDSOURCE
      SOURCE #asList
        #public List asList()
        #{
        #    return AnytypeUtil::asList(this.value());
        #}
      ENDSOURCE
      SOURCE #asMap
        #public Map asMap()
        #{
        #    return AnytypeUtil::asMap(this.value());
        #}
      ENDSOURCE
      SOURCE #asObject
        #public Object asObject()
        #{
        #    return AnytypeUtil::asObject(this.value());
        #}
      ENDSOURCE
      SOURCE #asReal
        #public Real asReal()
        #{
        #    return AnytypeUtil::asReal(this.value());
        #}
      ENDSOURCE
      SOURCE #asRecId
        #public int64 asRecId()
        #{
        #    return AnytypeUtil::asRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #asRecord
        #public Common asRecord(TableId tableId = 0)
        #{
        #    return AnytypeUtil::asRecord(this.value(), tableId);
        #}
      ENDSOURCE
      SOURCE #asRecVersion
        #public int64 asRecVersion()
        #{
        #    return AnytypeUtil::asRecVersion(this.value());
        #}
      ENDSOURCE
      SOURCE #asSet
        #public Set asSet()
        #{
        #    return AnytypeUtil::asSet(this.value());
        #}
      ENDSOURCE
      SOURCE #asString
        #public str asString()
        #{
        #    return AnytypeUtil::asString(this.value());
        #}
      ENDSOURCE
      SOURCE #asTime
        #public timeOfDay asTime()
        #{
        #    return AnytypeUtil::asTime(this.value());
        #}
      ENDSOURCE
      SOURCE #asValue
        #public anytype asValue(anytype asValue)
        #{
        #    anytype ret = AnytypeUtil::as(this.value(), asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс содержит неизменяемое значение любого типа
        #// чтобы переприсвоить значение, создайте новый объект этого типа
        #//
        #// Чем отличается этот класс от Anytype и от SysAnyType?
        #// 1.
        #// Аксапта позволяет установить произвольное значение в переменную типа anytype только один раз.
        #// Во время первой инициализации тип переменной фиксируется, в дальнейшем тип изменить нельзя.
        #//
        #// Anytype var = 1;
        #// var = 2;         // ok
        #// var = '';        // результат не определен. В большинстве версий аксапты будет 0;
        #//
        #// 2.
        #// Чтобы обойти эту проблему в Аксапту ввели тип SysAnyType
        #// SysAnyType позволяет в любой момент установить действительно любое значение.
        #// Но ради этого тип сделали очень тяжелым - в куче хранится map, key и сам объект в качестве value
        #// кроме того, каждое обращение к value - это lookup внутри map
        #//
        #// SysAnyType var = new SysAnyType(1);
        #// var.value('');   // будет хранить пустую строку
        #//
        #// 3.
        #// Данный класс Any не позволяет изменять значение хранимого объекта.
        #// Поэтому данный класс может просто хранить ref на объект произвольного типа
        #// Но! переприсвоить значение можно просто пересоздав объект Any
        #//
        #// Any var = new Any(1);        // ok
        #// var = new Any('');           // ok
        #//
        #// у Any есть несколько специализированных конструкторов и обычный construct
        #//
        #// Any var = Any::constuct(1);  // ok
        #// var = Any::constuct('');     // ok
        #//
        #// Класс проявляется в цикле (обратите внимание на специализированный конструктор conpeek)
        #//
        #// container con = [1, '', 31\01\2019];
        #// Any var;
        #// for(i=1; i<=conlen(con); ++i)
        #// {
        #//     var = Any::conpeek(con, i);
        #// }
        #class Any
        #{
        #    Anytype value;
        #}
      ENDSOURCE
      SOURCE #ensureEmpty
        #public Any ensureEmpty()
        #{
        #    if (this.value())
        #    {
        #        throw error(Error::wrongUseOfFunction(funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #ensureInTypes
        #public Any ensureInTypes(container typeCon)
        #{
        #    if (confind(typeCon, this.type()))
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #ensureNotEmpty
        #public Any ensureNotEmpty()
        #{
        #    if (this.value())
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public Any ensureType(Types type, int potentialAncestorId = 0)
        #{
        #    if (AnytypeUtil::is(this.value(), type, potentialAncestorId))
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #equalsTo
        #public boolean equalsTo(Any type2)
        #{
        #    //Is one of them null ?
        #    if (!type2)
        #    {
        #        return false;
        #    }
        #
        #    //Are their types different ?
        #    if (this.type() != type2.type())
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (this.type() == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    //Are their values different ?
        #    if (this.value() != type2.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #id
        #public int id()
        #{
        #    int id = AnytypeUtil::Id(this.value());
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #is
        #public boolean is(Types type, int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::is(this.value(), type, potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isArray
        #public boolean isArray()
        #{
        #    return AnytypeUtil::isArray(this.value());
        #}
      ENDSOURCE
      SOURCE #isClass
        #public boolean isClass(int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::isClass(potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isCollection
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isCollection()
        #{
        #    return EnumeratorUtil::isEnumerable(this.value());
        #}
      ENDSOURCE
      SOURCE #isContainer
        #public boolean isContainer()
        #{
        #    return AnytypeUtil::isContainer(this.value());
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public boolean isEmpty()
        #{
        #    if (this.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isEnum
        #public boolean isEnum(enumId enumId = 0)
        #{
        #    return AnytypeUtil::isEnum(this.value(), enumId);
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isEnumerable()
        #{
        #    return EnumeratorUtil::isEnumerable(this.value());
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isEnumerator()
        #{
        #    return EnumeratorUtil::isEnumerator(this.value());
        #}
      ENDSOURCE
      SOURCE #isImplements
        #public boolean isImplements(int interfaceId = 0)
        #{
        #    return AnytypeUtil::isImplement(this.value(), interfaceId);
        #}
      ENDSOURCE
      SOURCE #isInt
        #public boolean isInt()
        #{
        #    return AnytypeUtil::isInt(this.value());
        #}
      ENDSOURCE
      SOURCE #isInt64
        #public boolean isInt64()
        #{
        #    return AnytypeUtil::isInt(this.value());
        #}
      ENDSOURCE
      SOURCE #isList
        #public boolean isList()
        #{
        #    return AnytypeUtil::isClass(classnum(List));
        #}
      ENDSOURCE
      SOURCE #isMap
        #public boolean isMap()
        #{
        #    return AnytypeUtil::isClass(classnum(Map));
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public boolean isNotEmpty()
        #{
        #    if (this.value())
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isRecId
        #public boolean isRecId()
        #{
        #    return AnytypeUtil::isRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #isRecord
        #public boolean isRecord(int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::isRecord(this.value(), potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isRecVersion
        #public boolean isRecVersion()
        #{
        #    return AnytypeUtil::isRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #isSet
        #public boolean isSet()
        #{
        #    return AnytypeUtil::isClass(classnum(Set));
        #}
      ENDSOURCE
      SOURCE #isString
        #public boolean isString()
        #{
        #    return AnytypeUtil::isString(this.value());
        #}
      ENDSOURCE
      SOURCE #isValue
        #public boolean isValue(anytype isValue)
        #{
        #    boolean ret = AnytypeUtil::isValue(this.value(), isValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #void new(Anytype _value = null)
        #{
        #    value = _value;
        #}
      ENDSOURCE
      SOURCE #queryValue
        #// @deprecated! используйте метод toQueryValue()
        #//
        #final public str queryValue(boolean _usingExtendedQuery_MRC = false)
        #{
        #    return this.toQueryValue(_usingExtendedQuery_MRC);
        #}
      ENDSOURCE
      SOURCE #toBuf
        #// преобразовать value в соответствующий буфер, насколько это возможно
        #public Common toBuf()
        #{
        #    return AnytypeUtil::toBuf(this.value());
        #}
      ENDSOURCE
      SOURCE #toNullValue
        #public anytype toNullValue()
        #{
        #    return nullValueBaseType(this.type());
        #}
      ENDSOURCE
      SOURCE #toQueryValue
        #public str toQueryValue(boolean _usingExtendedQuery_MRC = false)
        #{
        #    str ret;
        #
        #    switch (this.type())
        #    {
        #        case Types::Class:
        #        case Types::Container:
        #            ret = this.addToTextBuffer(',', true, _usingExtendedQuery_MRC).getText();
        #            break;
        #
        #        case Types::Record:
        #        case Types::AnyType:
        #        case Types::BLOB:
        #        case Types::void:
        #            throw error(Error::unsupportedEnum(funcname(), this.type()));
        #
        #        default:
        #            ret = SysQuery::value_MRC(value,_usingExtendedQuery_MRC);
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString(str sep = ',')
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    str ret = AnytypeUtil::toString(this.value(), sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #final public Types type()
        #{
        #    Types type = typeof(value);
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #value
        #// только чтение! см. комментарий к classDeclaration
        #final public AnyType value()
        #{
        #    return value;
        #}
      ENDSOURCE
      SOURCE #checkAllNotEmpty
        #// принимает данные в контейнере, который состоит из контейнеров - значение и метка
        #// выдает ошибки для всех пустых значений
        #// если хотя бы одно значение пустое, то возвращает false
        #// если все значения не пустые, то возвращает true
        #//
        #// пример использования:
        #//     Any::checkAllNotEmpty([[purchId, 'Закупка'], [emplId, 'Ответственный']]);
        #//
        #public static boolean checkAllNotEmpty(container pairs, str txt = 'Значение не должно быть пустым. Укажите значение для %1.')
        #{
        #    boolean     ret = true;
        #
        #    container   pair;
        #    str         label;
        #
        #    int         i;
        #    int         len = conlen(pairs);
        #    ;
        #
        #    for (i=1; i<=len; ++i)
        #    {
        #        pair  = ConUtil::peekAsContainer(pairs, i);
        #        label = conpeek(pair, 2);
        #
        #        if( !conpeek(pair, 1) )
        #        {
        #            ret = CheckFailed(strfmt(txt, label));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #conpeek
        #public static Any conpeek(container con, int idx)
        #{
        #    anytype value   = conpeek(con, idx);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про контейнеры
        #    Any     ret     = Any::construct(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static Any construct(Anytype value)
        #{
        #    return new Any(value);
        #}
      ENDSOURCE
      SOURCE #field
        #public static Any field(Common record, fieldId fieldid)
        #{
        #    anytype value   = record.(fieldid);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    Any     ret     = Any::construct(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEqual
        #// TODO удалить
        #public static boolean isEqual(Any type1, Any type2)
        #{
        #    //Are both null ?
        #    if (!type1 && !type2)
        #    {
        #        return true;
        #    }
        #
        #    //Is one of them null ?
        #    if (!type1 || !type2)
        #    {
        #        return false;
        #    }
        #
        #    //Are their types different ?
        #    if (type1.type() != type2.type())
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (type1.type() == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    //Are their values different ?
        #    if (type1.value() != type2.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #list2set
        #// mazzy CL006053 31.12.2019
        #public static Set list2set(List _list)
        #{
        #    Set set;
        #    ListEnumerator   le;
        #
        #    if (_list)
        #    {
        #        set = new Set(_list.typeId());
        #
        #        le = _list.getEnumerator();
        #        while (le.moveNext())
        #        {
        #            set.add(le.current());
        #        }
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #set2list
        #// mazzy CL006053 31.12.2019
        #public static List set2list(Set _set)
        #{
        #    List            list;
        #    SetEnumerator   se;
        #
        #    if (_set)
        #    {
        #        list = new List(_set.typeId());
        #
        #        se = _set.getEnumerator();
        #        while (se.moveNext())
        #        {
        #            list.addEnd(se.current());
        #        }
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: AnyTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #AnyTest
    PROPERTIES
      Name                #AnyTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class AnyTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testConpeek
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConpeek()
        #{
        #    container con = [1, '', 31\01\2019, ['inside'], 2019-01-31T13:00:00];
        #    Any any;
        #    ;
        #
        #    any = Any::conpeek(con, 1);
        #    this.assertEquals(conpeek(con,1), any.value());
        #
        #    any = Any::conpeek(con, 2);
        #    this.assertEquals(conpeek(con, 2), any.value());
        #
        #    any = Any::conpeek(con, 3);
        #    this.assertEquals(conpeek(con, 3), any.value());
        #
        #    any = Any::conpeek(con, 4);
        #    this.assertEquals(conpeek(con, 4), any.value());
        #
        #    any = Any::conpeek(con, 5);
        #    this.assertEquals(conpeek(con, 5), any.value());
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConstruct()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Any any;
        #    ;
        #
        #    any = Any::construct(i);
        #    this.assertEquals(i, any.value());
        #
        #    any = Any::construct(s);
        #    this.assertEquals(s, any.value());
        #
        #    any = Any::construct(v);
        #    this.assertEquals(v, any.value());
        #}
      ENDSOURCE
      SOURCE #testEqualsTo
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testEqualsTo()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Date d = systemdateget();
        #    utcdatetime dt = DateTimeUtil::utcNow();
        #    container c = [1, '', d];
        #
        #    Any any1 = Any::construct(i);
        #    Any any2;
        #    ;
        #
        #    any2 = Any::construct(i);
        #    this.assertTrue(any1.equalsTo(any2));
        #    this.assertTrue(any2.equalsTo(any1));
        #
        #    this.assertFalse(any1.equalsTo(null));
        #    this.assertFalse(any2.equalsTo(null));
        #
        #    any2 = Any::construct(s);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(v);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(d);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(dt);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(c);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #}
      ENDSOURCE
      SOURCE #testField
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testField()
        #{
        #    UserInfo userInfo;
        #    Any any;
        #    ;
        #
        #    select firstOnly userInfo;
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, RecId));
        #    this.assertEquals(userInfo.RecId, any.value());
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, dataAreaId));
        #    this.assertEquals(userInfo.dataAreaId, any.value());
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, createdDateTime));
        #    this.assertEquals(userInfo.createdDateTime, any.value());
        #}
      ENDSOURCE
      SOURCE #testIsEqual
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsEqual()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Date d = systemdateget();
        #    utcdatetime dt = DateTimeUtil::utcNow();
        #    container c = [1, '', d];
        #
        #    Any any1 = Any::construct(i);
        #    Any any2;
        #    ;
        #
        #    any2 = Any::construct(i);
        #    this.assertTrue(Any::isEqual(any1, any2));
        #    this.assertTrue(Any::isEqual(any2, any1));
        #
        #    this.assertTrue(Any::isEqual(null, null));
        #    this.assertFalse(Any::isEqual(any1, null));
        #    this.assertFalse(Any::isEqual(null, any2));
        #
        #    any2 = Any::construct(s);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(v);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(d);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(dt);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(c);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #}
      ENDSOURCE
      SOURCE #testToString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString()
        #{
        #    //TO DO проверить все типы
        #    Any any;
        #    ;
        #
        #    any = Any::construct(1);
        #    this.assertEquals('1', any.toString());
        #
        #    any = Any::construct('test');
        #    this.assertEquals('test', any.toString());
        #
        #    any = Any::construct(31\12\2019);
        #    this.assertEquals(strfmt('%1',31\12\2019), any.toString());
        #
        #    any = Any::construct(2019-12-31T13:01:00);
        #    this.assertEquals(strfmt('%1',2019-12-31T13:01:00), any.toString());
        #
        #    any = Any::construct([1, '', [31\12\2019]]);
        #    this.assertEquals('1,,31.12.2019', any.toString());
        #
        #    any = Any::construct(appl);
        #    this.assertEquals('Class', any.toString());
        #
        #    any = Any::construct(SysUserInfo::find());
        #    this.assertEquals('Record', any.toString());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: AnytypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #AnytypeUtil
    PROPERTIES
      Name                #AnytypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс AnytypeUtil обслуживает значения типа anytype
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #class AnytypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #as
        #public static anytype as(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    if( AnytypeUtil::is(value, type, potentialAncestorId) )
        #    {
        #        return value;
        #    }
        #
        #    return nullValueBaseType(type);
        #}
      ENDSOURCE
      SOURCE #asArray
        #public static Array asArray(anytype value)
        #{
        #    if( AnytypeUtil::isArray(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asClass
        #public static Object asClass(anytype value, ClassId potentialAncestorId = 0)
        #{
        #    if( typeof(value) == Types::Class )
        #    {
        #        if( potentialAncestorId )
        #        {
        #            return ObjectUtil::as(value, potentialAncestorId);
        #        }
        #
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asCollection
        #public static anytype asCollection(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #asContainer
        #public static container asContainer(anytype value)
        #{
        #    if( typeof(value) == Types::Container )
        #    {
        #        return value;
        #    }
        #
        #    return connull();
        #}
      ENDSOURCE
      SOURCE #asDate
        #public static Date asDate(anytype value)
        #{
        #    if( typeof(value) == Types::Date )
        #    {
        #        return value;
        #    }
        #
        #    return DateNull();
        #}
      ENDSOURCE
      SOURCE #asDateTime
        #public static UtcDateTime asDateTime(anytype value)
        #{
        #    if( typeof(value) == Types::UtcDateTime )
        #    {
        #        return value;
        #    }
        #
        #    return utcDateTimeNull();
        #}
      ENDSOURCE
      SOURCE #asEnum
        #public static anytype asEnum(anytype value, enumId enumId = 0)
        #{
        #    return AnytypeUtil::as(value, Types::Enum, enumId);
        #}
      ENDSOURCE
      SOURCE #asEnumDefault
        #public static anytype asEnumDefault(anytype value, anytype defaultEnumValue)
        #{
        #    int enumId = AnytypeUtil::enumId(defaultEnumValue);
        #
        #    if( enumId && AnytypeUtil::is(value, Types::Enum, enumId) )
        #    {
        #        return value;
        #    }
        #
        #    return defaultEnumValue;
        #}
        #
        #
      ENDSOURCE
      SOURCE #asEnumerable
        #public static anytype asEnumerable(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #asEnumerator
        #public static anytype asEnumerator(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerator(value);
        #}
      ENDSOURCE
      SOURCE #asGUID
        #public static GUID asGUID(anytype value)
        #{
        #    if( typeof(value) == Types::Guid )
        #    {
        #        return value;
        #    }
        #
        #    return nullValueBaseType(Types::Guid);
        #}
      ENDSOURCE
      SOURCE #asInt
        #public static int asInt(anytype value)
        #{
        #    if( typeof(value) == Types::Integer )
        #    {
        #        return value;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #asInt64
        #public static int64 asInt64(anytype value)
        #{
        #    if( typeof(value) == Types::Int64 )
        #    {
        #        return value;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #asList
        #public static List asList(anytype value)
        #{
        #    if( AnytypeUtil::isList(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asMap
        #public static Map asMap(anytype value)
        #{
        #    if( AnytypeUtil::isMap(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asObject
        #public static Object asObject(anytype value)
        #{
        #    return AnytypeUtil::asClass(value);
        #}
      ENDSOURCE
      SOURCE #asReal
        #public static Real asReal(anytype value)
        #{
        #    if( typeof(value) == Types::Real )
        #    {
        #        return value;
        #    }
        #
        #    return 0.0;
        #}
      ENDSOURCE
      SOURCE #asRecId
        #public static int64 asRecId(anytype value)
        #{
        #    if( typeof(value) == Types::Int64 )
        #    {
        #        return value;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #asRecord
        #public static Common asRecord(anytype value, TableId tableId = 0)
        #{
        #    Common ret = AnytypeUtil::as(value, Types::Record, tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asRecVersion
        #public static int asRecVersion(anytype value)
        #{
        #    if( typeof(value) == Types::Integer )
        #    {
        #        return value;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #assertEmpty
        #public static anytype assertEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        throw error(Error::wrongUseOfFunction(funcName()));
        #    }
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #assertNotEmpty
        #public static anytype assertNotEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        return value;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcName()));
        #}
      ENDSOURCE
      SOURCE #assertType
        #public static anytype assertType(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    if (AnytypeUtil::is(value, type, potentialAncestorId))
        #    {
        #        return value;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcName()));
        #}
      ENDSOURCE
      SOURCE #asSet
        #public static Set asSet(anytype value)
        #{
        #    if( AnytypeUtil::isSet(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asStack
        #public static Stack asStack(anytype value)
        #{
        #    if( AnytypeUtil::isStack(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asString
        #public static str asString(anytype value)
        #{
        #    if( AnytypeUtil::isString(value) )
        #    {
        #        return value;
        #    }
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #asStruct
        #public static Struct asStruct(anytype value)
        #{
        #    if( AnytypeUtil::isStruct(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asTime
        #public static timeOfDay asTime(anytype value)
        #{
        #    if( typeof(value) == Types::Integer )
        #    {
        #        return value;
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #asValue
        #public static anytype asValue(anytype value, anytype asValue)
        #{
        #    Types   asType = typeof(asValue);
        #    Int     asId   = AnytypeUtil::id(asValue);
        #    anytype ret    = AnytypeUtil::as(value, asType, asId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classId
        #public static int classId(anytype value)
        #{
        #    int id = 0;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        id = classidget(value);
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #enumId
        #public static int enumId(anytype value)
        #{
        #    int id = 0;
        #
        #    if( typeof(value) == Types::Enum )
        #    {
        #        id = DictEnum::value2id(value);
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает объект, у которого можно вызвать метод moveNext
        #public static Enumerator getEnumerator(anytype collectionOrValue)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #id
        #public static int id(anytype value)
        #{
        #    int   id   = 0;
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Enum:
        #            id = DictEnum::value2id(value);
        #            break;
        #
        #        case Types::Record:
        #            id = AnytypeUtil::asRecord(value).TableId;
        #            break;
        #
        #        case Types::Class:
        #            id = classidget(value);
        #            break;
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    Types t = typeof(value);
        #
        #    if( potentialAncestorId )
        #    {
        #        switch( t )
        #        {
        #            case Types::Class:
        #                return (type == t) && ObjectUtil::is(value, potentialAncestorId);
        #
        #            case Types::Record:
        #                return (type == t) && SysDictTable::is(value, potentialAncestorId);
        #
        #            case Types::Integer:
        #                switch( type )
        #                {
        #                    case Types::Class:
        #                        return ObjectUtil::is(value, potentialAncestorId);
        #
        #                    case Types::Record:
        #                        return SysDictTable::is(RecordUtil::makeRecord(value), potentialAncestorId);
        #
        #                    case Types::UserType:
        #                        return DictTypeUtil::is(value, potentialAncestorId);
        #
        #                    case Types::Enum:
        #                        return (potentialAncestorId == new DictType(value).enumId());
        #                }
        #                break;
        #
        #            case Types::Enum:
        #                return (type == t) && potentialAncestorId == DictEnum::value2id(value); // TODO равен ли? может ли быть enum от enum?
        #        }
        #    }
        #
        #    if( type == t )
        #    {
        #        return true;
        #    }
        #    else if( TypeUtil::isString(t) )
        #    {
        #        // не строгое совпадение строковых типов поскольку все строки можно присвоить друг другу
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isArray
        #public static boolean isArray(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(Array));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isClass
        #public static boolean isClass(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isCollection
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isCollection(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #isContainer
        #public static boolean isContainer(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Container;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public static boolean isEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isEnum
        #public static boolean isEnum(anytype value, enumId enumId = 0)
        #{
        #    return AnytypeUtil::is(value, Types::Enum, enumId);
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerable(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerator(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerator(value);
        #}
      ENDSOURCE
      SOURCE #isEqual
        #// не создаем новых переменных в стеке
        #public static boolean isEqual(anytype value1, anytype value2)
        #{
        #    //Are both null ?
        #    if (!value1 && !value2)
        #    {
        #        return true;
        #    }
        #
        #    //Is one of them null ?
        #    if (!value1 || !value2)
        #    {
        #        return false;
        #    }
        #
        #    //Are their types different ?
        #    if (typeof(value1) != typeof(value2))
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (typeof(value1) == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    if (typeof(value1) == Types::Class)
        #    {
        #        return ObjectUtil::isEqual(value1, value2);
        #    }
        #
        #    //Are their values different ?
        #    if (value1 != value2)
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #public static boolean isImplement(anytype value, int interfaceId = 0)
        #{
        #    boolean ret;
        #
        #    if( interfaceId && typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isImplement(value, interfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInt
        #public static boolean isInt(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Integer;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInt64
        #public static boolean isInt64(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Int64;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isList
        #public static boolean isList(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(List));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMap
        #public static boolean isMap(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(Map));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public static boolean isNotEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isNull
        #public static boolean isNull(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Class:
        #        case typeof(null):
        #            return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(anytype value)
        #{
        #    Types type = typeof(value);
        #    boolean ret = TypeUtil::isNumeric(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPrimitive
        #public static boolean isPrimitive(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::String:
        #        case Types::Integer:
        #        case Types::Real:
        #        case Types::Date:
        #        case Types::Enum:
        #        case Types::UtcDateTime:
        #        case Types::RString:
        #        case Types::VarString:
        #        case Types::UserType:
        #        case Types::Guid:
        #        case Types::Int64:
        #        case Types::Time:
        #            return true;
        #
        #        case Types::Container:
        #        case Types::Record:
        #        case Types::AnyType:
        #        case Types::BLOB:
        #        case Types::Class:
        #        case Types::void:
        #            return false;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isRecId
        #public static boolean isRecId(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Int64;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isRecord
        #public static boolean isRecord(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(value, Types::Record, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isRecVersion
        #public static boolean isRecVersion(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Integer;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSet
        #public static boolean isSet(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(Set));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStack
        #public static boolean isStack(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(Stack));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(anytype value)
        #{
        #    Types type = typeof(value);
        #    boolean ret = TypeUtil::isString(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStruct
        #public static boolean isStruct(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(Struct));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isValue
        #public static boolean isValue(anytype value, anytype isValue)
        #{
        #    Types   isType = typeof(isValue);
        #    Int     isId   = AnytypeUtil::id(isValue);
        #    boolean ret    = AnytypeUtil::is(value, isType, isId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nullValue
        #public static anytype nullValue(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    return nullValueBaseType(type);
        #}
      ENDSOURCE
      SOURCE #tableId
        #public static int tableId(anytype value)
        #{
        #    int id = 0;
        #
        #    if( typeof(value) == Types::Record )
        #    {
        #        id = AnytypeUtil::asRecord(value).TableId;
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #toBuf
        #// преобразовать value в соответствующий буфер, насколько это возможно
        #public static Common toBuf(anytype value)
        #{
        #    Common buf;
        #
        #    switch(typeof(value))
        #    {
        #        case Types::Record:
        #            buf = value;
        #            break;
        #
        #        case Types::Integer:
        #            buf = RecordUtil::makeRecord(value);
        #            break;
        #
        #        case Types::Int64:
        #            buf = RecordUtil::makeRecord(int642int(value, true));
        #            break;
        #
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            if( value )
        #            {
        #                buf = RecordUtil::makeRecord(tablename2id(value));
        #            }
        #            break;
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #toNullValue
        #public static anytype toNullValue(anytype value)
        #{
        #    return nullValueBaseType(value);
        #}
      ENDSOURCE
      SOURCE #toString
        #public static str toString(anytype value, str sep = ',')
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    Types type = typeof(value);
        #    str   ret;
        #    Object obj;
        #
        #    switch (type)
        #    {
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            ret = value;
        #            break;
        #
        #        case Types::Container:
        #            ret = ConUtil::toStr(value, sep);
        #            break;
        #
        #        case Types::Enum:
        #            ret = enum2str(value);
        #            break;
        #
        #        case Types::AnyType:
        #            ret = '';
        #            break;
        #
        #        case Types::Record:
        #            ret = RecordUtil::getValuesInfo(value);
        #
        #        case Types::Class:
        #            if( value )
        #            {
        #                obj = value;
        #                ret = obj.toString();
        #            }
        #            else
        #            {
        #                ret = 'null';
        #            }
        #            break;
        #
        #        case Types::BLOB:
        #        case Types::void:
        #            ret = strfmt('%1', type); // не бросаем исключение! throw error(Error::unsupportedEnum(funcname(), type));
        #            break;
        #
        #        default:
        #            ret = strfmt('%1', value);
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #undefined
        #public static anytype undefined()
        #{
        #    anytype undefined;
        #
        #    return undefined;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictTypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictTypeUtil
    PROPERTIES
      Name                #DictTypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class DictTypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(DictType dt, ExtendedTypeId potentialAncestorId)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeIdUtil::is(dt.id(), potentialAncestorId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeIdUtil::isInteger(dt.id());
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isLengthEnough
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnough(DictType dt, str s)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeIdUtil::isLengthEnough(dt.id(), s);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnoughOrWarning
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnoughOrWarning(DictType dt, str s)
        #{
        #    boolean ret = DictTypeUtil::isLengthEnough(dt, s);
        #
        #    if( dt && !ret )
        #    {
        #        // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #        Warning(strfmt('Строка с длиной %1 не помещается в тип %2. Обратитесь к разработчикам.', strlen(s), DictTypeUtil::name(dt)));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isNumeric(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isString(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isUndefined(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #public static str name(DictType dt)
        #{
        #    str ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeId2name(dt.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ExtendedTypeIdUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ExtendedTypeIdUtil
    PROPERTIES
      Name                #ExtendedTypeIdUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ExtendedTypeIdUtil
        #{
        #}
      ENDSOURCE
      SOURCE #dictType
        #public static DictType dictType(ExtendedTypeId id)
        #{
        #    DictType dt;
        #
        #    if( id )
        #    {
        #        dt = new DictType(id);
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от Global::isType():
        #// 1. итерация, а не рекурсия.
        #// 2. минимальное число создаваемых в памяти объектов
        #public static boolean is(ExtendedTypeId id, ExtendedTypeId potentialAncestorId)
        #{
        #    DictType dictType;
        #    ;
        #
        #    while( id && potentialAncestorId )
        #    {
        #        if( id == potentialAncestorId )
        #        {
        #            return true;
        #        }
        #
        #        dictType = new DictType(id);
        #
        #        if( dictType )
        #        {
        #            id = dictType.extend();
        #        }
        #        else
        #        {
        #            id = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isInteger(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnough
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnough(ExtendedTypeId id, str s)
        #{
        #    DictType    dt  = new DictType(id);
        #    boolean     ret = DictTypeUtil::isLengthEnough(dt, s);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnoughOrWarning
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnoughOrWarning(ExtendedTypeId id, str s)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isLengthEnough(dt, s);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isNumeric(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isString(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isUndefined(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #public static str name(ExtendedTypeId id)
        #{
        #    str ret = ExtendedTypeId2name(id);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sysDictType
        #public static SysDictType sysDictType(ExtendedTypeId id)
        #{
        #    SysDictType dt;
        #
        #    if( id )
        #    {
        #        dt = new SysDictType(id);
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TypeUtil
    PROPERTIES
      Name                #TypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #integerTypes
        #public static container integerTypes()
        #{
        #    return [Types::Integer, Types::Int64, Types::Date, Types::Time];
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(Types type)
        #{
        #    boolean ret = confind(TypeUtil::integerTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(Types type)
        #{
        #    boolean ret = confind(TypeUtil::numericTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(Types type)
        #{
        #    boolean ret = confind(TypeUtil::stringTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(Types type)
        #{
        #    boolean ret = (type == Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #numericTypes
        #public static container numericTypes()
        #{
        #    return [Types::Real, Types::Integer, Types::Int64];
        #}
      ENDSOURCE
      SOURCE #stringTypes
        #public static container stringTypes()
        #{
        #    return [Types::String, Types::RString, Types::VarString];
        #}
      ENDSOURCE
      SOURCE #undefined
        #public static Types undefined()
        #{
        #    return Types::AnyType;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ClrTypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ClrTypeUtil
    PROPERTIES
      Name                #ClrTypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ClrTypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #asInstance
        #// mazzy, 06.10.2020
        #public static System.Object asInstance(System.Object obj, System.Object baseObj)
        #{
        #    if( ClrTypeUtil::isInstance(obj, baseObj) )
        #    {
        #        return obj;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asInstanceOrBase
        #// mazzy, 06.10.2020
        #public static System.Object asInstanceOrBase(System.Object obj, System.Object baseObj)
        #{
        #    if( ClrTypeUtil::isInstance(obj, baseObj) )
        #    {
        #        return obj;
        #    }
        #
        #    return baseObj;
        #}
        #
      ENDSOURCE
      SOURCE #isInstance
        #// mazzy, 06.10.2020
        #public static boolean isInstance(System.Object obj, System.Object baseObj)
        #{
        #    anytype perm = new InteropPermission(Interopkind::ClrInterop).assert();
        #
        #    System.Type baseType = baseObj ? baseObj.GetType() : null;
        #    boolean     ret      = baseType && obj ? baseType.IsInstanceOfType(obj) : false;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #// mazzy, 06.10.2020
        #public static str name(System.Object obj)
        #{
        #    anytype perm = new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    System.Type type = obj ? obj.GetType() : null;
        #    str typeName = type ? type.get_Name() : '';
        #
        #    return typeName;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrUtil
    PROPERTIES
      Name                #StrUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StrUtil
        #{
        #}
      ENDSOURCE
      SOURCE #after
        #// возвращает подстроку, которая находится после первого вхожения подстроки
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      StringUtil::after('ABC-DEF-GH','DEF-') == 'GH'
        #//      StringUtil::after('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str after(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+strlen(txt), len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterChar
        #// возвращает подстроку, которая находится после первого вхожения любого из указанных символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'DEF-GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterLast
        #// возвращает подстроку, которая находится после последнего вхожения подстроки
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','DEF') == 'GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterLast(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+strlen(txt), len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterLastChar
        #// возвращает подстроку, которая находится после последнего вхожения одного из символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterLastChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #before
        #// возвращает подстроку, которая находится до первого вхожения подстроки
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','DEF') == 'ABC-'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str before(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeChar
        #// возвращает подстроку, которая находится до первого вхожения одного из символов characters
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'ABC'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeLast
        #// возвращает подстроку, которая находится до последнего вхожения подстроки
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','-=') == 'ABC-DEF-'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeLast(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeLastChar
        #// возвращает подстроку, которая находится до последнего вхожения одного из символов characters
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'ABC'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeLastChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #    {
        #        ret = StrUtil::strLeft(s, pos-1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #char
        #public static str char(int n)
        #{
        #    str ret = num2char(n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #char2num
        #public static int char2num(str text, int position)
        #{
        #    int ret = char2num(text, position);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #// удалить первые n символов, если n > 0
        #// удалить последние n символов, если n < 0
        #// оставить исходную строку, если n == 0
        #public static str drop(str s, int n)
        #{
        #    if(n == 0)
        #        return s;
        #
        #    if(n < 0)
        #        return substr(s, 1, strlen(s)+n);
        #
        #    return substr(s, n+1, strlen(s)-n);
        #}
      ENDSOURCE
      SOURCE #end
        #// возвращает подстроку заданной длины справа
        #//
        #// по идее, различие между strRight и end должно проявляться на текстах с разным направлением письма
        #static str end(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #static str first(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #formatClarification
        #// добавляет к строке разъяснение в скобках, если разъяснение есть
        #public static str formatClarification(
        #    str     s,
        #    str     clarification,
        #    str     clarificationFormat     = "%1 (%2)")
        #{
        #    if( clarification )
        #    {
        #        s = strfmt(clarification, s, clarificationFormat);
        #    }
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #hexDump
        #public static str hexDump(str s)
        #{
        #    int         i;
        #    str         hex;
        #    int         len     = strlen(s);
        #    TextBuffer  ret     = new TextBuffer();
        #;
        #    for( i=1; i<=len; ++i )
        #    {
        #        if( ret.size() )
        #            ret.appendText(' ');
        #
        #        hex = Int2Hex(char2num(s, i));
        #
        #        if( strlen(hex) mod 2 )
        #        {
        #            ret.appendText('0');
        #        }
        #
        #        ret.appendText(hex);
        #    }
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #isBlank
        #//TODO
        #public static boolean isBlank(str s)
        #{
        #    str ret;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isEmptyOrBlank
        #//TODO
        #public static boolean isEmptyOrBlank(str s)
        #{
        #    str ret;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #last
        #static str last(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static str newFrom(anytype valueOrCollection, str sep = ',')
        #{
        #    str ret = TextBufferUtil::append(null, valueOrCollection, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #public static str newFromArray(Array arr, str sep = ',')
        #{
        #    ArrayEnumerator ae;
        #    str ret;
        #
        #    if( arr )
        #    {
        #        if( arr.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('Array хранит enum как целые. Используйте Array(Types::Container) и arr.value(i, [Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в массиве. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        ae = ArrayEnumerator::construct(arr);
        #        ret = TextBufferUtil::appendEnumerator(null, ae, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static str newFromContainer(container con, str sep = ',')
        #{
        #    str ret = TextBufferUtil::appendContainer(null, con, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static str newFromList(List list, str sep = ',')
        #{
        #    ListEnumerator le;
        #    str ret;
        #
        #    if( list )
        #    {
        #        if( list.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('List хранит enum как целые. Используйте List(Types::Container) и list.add([Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в списке. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        le = list.getEnumerator();
        #        ret = TextBufferUtil::appendEnumerator(null, le, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromObject
        #public static str newFromObject(Object obj)
        #{
        #    str ret;
        #
        #    if( obj )
        #    {
        #        ret = obj.toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static str newFromSet(Set set, str sep = ',')
        #{
        #    SetEnumerator se;
        #    str ret;
        #
        #    if( set )
        #    {
        #        if( set.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('Set хранит enum как целые. Используйте Set(Types::Container) и set.add([Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в множестве. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        se = set.getEnumerator();
        #        ret = TextBufferUtil::appendEnumerator(null, se, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padEnd
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #//
        #// по идее, различие между padRight и padEnd должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #static str padEnd(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = s + strrep(char, l);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padLeft
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padLeft(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = strrep(char, l) + s;
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padRight
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padRight(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = s + strrep(char, l);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padStart
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #//
        #// по идее, различие между padLeft и padStart должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #static str padStart(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = strrep(char, l) + s;
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #split
        #// делит строку на подстроки, разделенные строкой delimiterStr
        #// возвращает контейнер подстрок. Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      strSplitCon('ABC:=DEF:=GH',':=')   == ['ABC','DEF','GH']
        #//      strSplitCon('ABC:=DEF:=GH',':=',2) == ['ABC','DEF:=GH']
        #//      strSplitCon('ABC:=DEF:=GH',':=',1) == ['ABC:=DEF:=GH']
        #//
        #static container split(str s, str delimiterStr, int maxSubstrings = 0)
        #{
        #    container ret;
        #    int delimiterLen;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiterStr == '' )
        #        return [s];
        #
        #    delimiterLen = strlen(delimiterStr);
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        pos = strscan(s, delimiterStr, posFrom, len);
        #        if( pos == 0 )
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+delimiterLen;
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #splitChar
        #// делит строку на подстроки, разделенные хотя бы одним символом из delimiters (по-умолчанию это пробел, табуляция и перевод строки - whitespaces)
        #// возвращает контейнер подстрок.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #// Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #//
        #// пример:
        #//      strSplitChar('ABC DEF GH')        == ['ABC','DEF','GH']
        #//      strSplitChar('ABC-DEF-GH','-=')   == ['ABC','DEF','GH']
        #//      strSplitChar('ABC-DEF-GH','-=',2) == ['ABC','DEF-GH']
        #//      strSplitChar('ABC-DEF-GH','-=',1) == ['ABC-DEF-GH']
        #//
        #static container splitChar(str s, str delimiters = ' \t\n', int maxSubstrings = 0)
        #{
        #    container ret;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiters == '' )
        #        return [s];
        #
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        pos = strfind(s, delimiters, posFrom, len);
        #        if( pos == 0 )
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+1;
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #splitCon
        #// делит строку на подстроки, разделенные хотя бы одной строкой из контейнера delimiterCon (по умолчанию пробел, табуляция и переводы строк - whitespaces)
        #// результат не зависит от порядка разделителей в контейнере.
        #// возвращает контейнер подстрок. Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      strSplitCon('ABC=DEF:=GH',[':=','='])   == ['ABC','DEF','GH']
        #//      strSplitCon('ABC=DEF:=GH',[':=','='],2) == ['ABC','DEF:=GH']
        #//      strSplitCon('ABC=DEF:=GH',[':=','='],1) == ['ABC=DEF:=GH']
        #//
        #static container splitCon(str s, container delimiterCon = [' ','\t','\n','\r\n','\n\r'], int maxSubstrings = 0)
        #{
        #    container ret;
        #    int d;
        #    str delimiter;
        #    str delimiterStr;
        #    int delimiterPos;
        #    int delimiterLen;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiterCon == connull() )
        #        return [s];
        #
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        delimiter = conpeek(delimiterCon, 1);       // проверка выше гарантирует, что хотя бы один разделитель у нас есть
        #        pos = strscan(s, delimiter, posFrom, len);  // позиция первого разделителя
        #        for(d = 2; d <= conlen(delimiterCon); d++)  // позиции разделителей после первого
        #        {
        #            delimiterStr = conpeek(delimiterCon, d);
        #            delimiterPos = strscan(s, delimiterStr, posFrom, len);
        #            if( delimiterPos == 0 )
        #                continue;
        #
        #            if( pos && pos < delimiterPos )
        #                continue;
        #
        #            if( pos == delimiterPos && strlen(delimiter) >= strlen(delimiterStr) )
        #                continue;
        #
        #            // берем разделитель с минимальной позицией
        #            // если позиция совпадает, то берем разделитель с максимальной длиной
        #            delimiter = delimiterStr;
        #            pos = delimiterPos;
        #        }
        #        if( pos == 0 )  // разделители не найдены
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+strlen(delimiter);
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #start
        #// возвращает подстроку заданной длины слева
        #//
        #// по идее, различие между strLeft и start должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #//
        #static str start(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #strLeft
        #// возвращает подстроку заданной длины слева
        #//
        #// в X++ есть ключевое слово left. Поэтому обявить метод с именем left нельзя
        #static str strLeft(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #strRight
        #// возвращает подстроку заданной длины справа
        #static str strRight(str s, int len)
        #{
        #    str ret;
        #
        #    if( len<=0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #// возвращает подстроку заданной длины с указанного символа
        #// len может быть отрицательным числом.
        #static str take(str s, int len, int startFrom = 1)
        #{
        #    str ret = substr(s, startFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trim
        #// убирает указанные символы в начале и в конце строки
        #// по умолчанию, убирает пробелы, табуляцию и переводы строк
        #static str trim(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #    int len = strlen(s);
        #    int fromPos = strnfind(s, ws, 1, len);
        #    int toPos = strnfind(s, ws, len, -len);
        #
        #    if( fromPos && fromPos <= toPos )
        #    {
        #        ret = substr(s, fromPos, toPos - fromPos + 1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimEnd
        #//TODO
        #public static str trimEnd(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static str trimIndent(str s)
        #{
        #    return TextUtil::trimIndent(s);
        #}
      ENDSOURCE
      SOURCE #trimStart
        #//TODO
        #public static str trimStart(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrUtilTest
    PROPERTIES
      Name                #StrUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class StrUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testDrop_0
        #void testDrop_0()
        #{
        #    this.assertEquals('abcdefgh', StrUtil::drop('abcdefgh', 0));
        #}
      ENDSOURCE
      SOURCE #testDrop_Minus
        #void testDrop_Minus()
        #{
        #    this.assertEquals('abcde', StrUtil::drop('abcdefgh', -3));
        #}
      ENDSOURCE
      SOURCE #testDrop_Plus
        #void testDrop_Plus()
        #{
        #    this.assertEquals('defgh', StrUtil::drop('abcdefgh', 3));
        #}
      ENDSOURCE
      SOURCE #testHexDump
        #void testHexDump()
        #{
        #    this.assertEquals('20 0A', StrUtil::hexDump(' \n'));
        #}
      ENDSOURCE
      SOURCE #testHexDump_Unicode
        #void testHexDump_Unicode()
        #{
        #    this.assertEquals('042E 042F', StrUtil::hexDump('ЮЯ'));
        #}
      ENDSOURCE
      SOURCE #testPadLeft
        #void testPadLeft()
        #{
        #    this.assertEquals('  ABC', StrUtil::padLeft('ABC',5));
        #    this.assertEquals('==ABC', StrUtil::padLeft('ABC',5,'='));
        #    this.assertEquals('==ABC', StrUtil::padLeft('ABC',5,'=Z'));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',3,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',2,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',0,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',-1,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testPadRight
        #void testPadRight()
        #{
        #    this.assertEquals('ABC  ', StrUtil::padRight('ABC',5));
        #    this.assertEquals('ABC==', StrUtil::padRight('ABC',5,'='));
        #    this.assertEquals('ABC==', StrUtil::padRight('ABC',5,'=Z'));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',3,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',2,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',0,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',-1,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testSplit
        #void testSplit()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':='));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',0));
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH',':=',1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::split('ABC:=DEF:=GH',':=',2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',4));
        #
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH',''));
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH','',4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::split(':=ABC:=DEF:=GH:=',':='));
        #
        #    this.assertEquals([''], StrUtil::split('',':='));
        #    this.assertEquals([''], StrUtil::split('',''));
        #}
      ENDSOURCE
      SOURCE #testSplitChar
        #void testSplitChar()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-='));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',0));
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH','-=',1));
        #    this.assertEquals(['ABC','DEF-GH'],         StrUtil::splitChar('ABC-DEF-GH','-=',2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',4));
        #
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH',''));
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH','',4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitChar('-ABC-DEF-GH-','-='));
        #
        #}
      ENDSOURCE
      SOURCE #testSplitCon
        #void testSplitCon()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','=']));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],0));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',[':=','='],1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::splitCon('ABC=DEF:=GH',[':=','='],2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],4));
        #
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':=']));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],0));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',['=',':='],1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::splitCon('ABC=DEF:=GH',['=',':='],2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],4));
        #
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',connull()));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',connull(),4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC=DEF:=GH=',[':=','=']));
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC=DEF:=GH=',['=',':=']));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC:DEF:=GH:',[':=',':']));
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC:DEF:=GH:',[':',':=']));
        #}
      ENDSOURCE
      SOURCE #testStrAfter
        #void testStrAfter()
        #{
        #    this.assertEquals('DEF-GH',    StrUtil::after('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',        StrUtil::after('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',          StrUtil::after('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::after('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::after('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterChar
        #void testStrAfterChar()
        #{
        #    this.assertEquals('DEF-GH',    StrUtil::afterChar('ABC-DEF-GH','-='));
        #    this.assertEquals('DEF-GH',    StrUtil::afterChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::afterChar('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterChar('ABC-DEF-GH','A-='));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterLast
        #void testStrAfterLast()
        #{
        #    this.assertEquals('GH',        StrUtil::afterLast('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',        StrUtil::afterLast('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',          StrUtil::afterLast('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterLastChar
        #void testStrAfterLastChar()
        #{
        #    this.assertEquals('GH',        StrUtil::afterLastChar('ABC-DEF-GH','-='));
        #    this.assertEquals('GH',        StrUtil::afterLastChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::afterLastChar('ABC-DEF-GH','H-='));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBefore
        #void testStrBefore()
        #{
        #    this.assertEquals('ABC',       StrUtil::before('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC',       StrUtil::before('ABC-DEF-GH','-DEF'));
        #    this.assertEquals('',          StrUtil::before('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G', StrUtil::before('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::before('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeChar
        #void testStrBeforeChar()
        #{
        #    this.assertEquals('ABC',       StrUtil::beforeChar('ABC-DEF-GH','-='));
        #    this.assertEquals('ABC',       StrUtil::beforeChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::beforeChar('ABC-DEF-GH','A-='));
        #    this.assertEquals('ABC-DEF-G', StrUtil::beforeChar('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeLast
        #void testStrBeforeLast()
        #{
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLast('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC'       ,StrUtil::beforeLast('ABC-DEF-GH','-DEF'));
        #    this.assertEquals(''          ,StrUtil::beforeLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G' ,StrUtil::beforeLast('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeLastChar
        #void testStrBeforeLastChar()
        #{
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLastChar('ABC-DEF-GH','-='));
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLastChar('ABC-DEF-GH','E-='));
        #    this.assertEquals(''          ,StrUtil::beforeLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G' ,StrUtil::beforeLastChar('ABC-DEF-GH','H-='));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrLeft
        #void testStrLeft()
        #{
        #    this.assertEquals('ABC',        StrUtil::strLeft('ABC-DEF-GH',3));
        #    this.assertEquals('',           StrUtil::strLeft('ABC-DEF-GH',0));
        #    this.assertEquals('',           StrUtil::strLeft('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH', StrUtil::strLeft('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testStrLFix
        #//TODO ???
        #void testStrLFix()
        #{
        #    this.assertEquals('ABC  ',strLFix('ABC',5));
        #    this.assertEquals('ABC==',strLFix('ABC',5,'='));
        #    this.assertEquals('ABC==',strLFix('ABC',5,'=Z'));
        #    this.assertEquals('ABC',strLFix('ABC',3,'='));
        #    this.assertEquals('AB',strLFix('ABC',2,'='));
        #    this.assertEquals('',strLFix('ABC',0,'='));
        #    this.assertEquals('A',strLFix('ABC',-1,'='));
        #    this.assertEquals('A',strLFix('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testStrRFix
        #// TODO ???
        #void testStrRFix()
        #{
        #    this.assertEquals('  ABC',strRFix('ABC',5));
        #    this.assertEquals('==ABC',strRFix('ABC',5,'='));
        #    this.assertEquals('==ABC',strRFix('ABC',5,'=Z'));
        #    this.assertEquals('ABC',strRFix('ABC',3,'='));
        #    this.assertEquals('AB',strRFix('ABC',2,'='));
        #    this.assertEquals('',strRFix('ABC',0,'='));
        #    this.assertEquals('A',strRFix('ABC',-1,'='));
        #    this.assertEquals('A',strRFix('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testStrRight
        #void testStrRight()
        #{
        #    this.assertEquals('DEF-GH'    ,StrUtil::strRight('ABC-DEF-GH',6));
        #    this.assertEquals(''          ,StrUtil::strRight('ABC-DEF-GH',0));
        #    this.assertEquals(''          ,StrUtil::strRight('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::strRight('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testTrim
        #void testTrim()
        #{
        #    this.assertEquals('ABC', StrUtil::trim('ABC  '));
        #    this.assertEquals('ABC', StrUtil::trim('  ABC'));
        #    this.assertEquals('ABC', StrUtil::trim('ABC  \r\n  '));
        #    this.assertEquals('ABC', StrUtil::trim('  \r\n  ABC'));
        #    this.assertEquals('ABC', StrUtil::trim('  \r\n  ABC  \r\n  '));
        #    this.assertEquals('ABC', StrUtil::trim(@'ABC
        #    '));
        #    this.assertEquals('ABC', StrUtil::trim(@'
        #    ABC'));
        #    this.assertEquals('ABC', StrUtil::trim(@'
        #    ABC
        #    '));
        #    this.assertEquals('A',   StrUtil::trim('  A  '));
        #
        #    this.assertEquals('ABC', StrUtil::trim('==ABC==','='));
        #    this.assertEquals('A',   StrUtil::trim('==A==','='));
        #
        #
        #    this.assertEquals('',    StrUtil::trim('  '));
        #    this.assertEquals('',    StrUtil::trim('  \r\n  '));
        #    this.assertEquals('',    StrUtil::trim(@'
        #    '));
        #
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextBufferUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextBufferUtil
    PROPERTIES
      Name                #TextBufferUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TextBufferUtil
        #{
        #}
      ENDSOURCE
      SOURCE #append
        #public static TextBuffer append(TextBuffer textOrNull, anytype valueOrCollection, str sep = ',')
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    TextBuffer text = TextBufferUtil::appendEnumerator(null, e, sep);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendCallStack
        #// отображаем как в отладчике
        #public static TextBuffer appendCallStack(TextBuffer text, int skip = 1, container callStack = xSession::xppCallStack())
        #{
        #    int len   = conLen(callStack);
        #    int start = max(2, skip*2+2);
        #    int i;
        #
        #    if( !text )
        #    {
        #        text = new TextBuffer();
        #    }
        #
        #    for( i=start; i<=len; i+=2 )
        #    {
        #        text.appendText(strfmt('\n%1 - line %2', conPeek(callStack, i-1), conPeek(callStack, i)));
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendCollectionItem
        #public static TextBuffer appendCollectionItem(TextBuffer text, str s, str sep=',')
        #{
        #    text = TextBufferUtil::appendIfNotEmpty(text, sep);
        #    text = TextBufferUtil::appendStr(text, s);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendContainer
        #public static TextBuffer appendContainer(TextBuffer textOrNull, container con, str sep = ',')
        #{
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #    TextBuffer text = TextBufferUtil::appendEnumerator(textOrNull, ce, sep);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendEnumerator
        #public static TextBuffer appendEnumerator(TextBuffer textOrNull, Enumerator e, str sep = ',')
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #    boolean tail;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( tail && sep )
        #        {
        #            text.appendText(sep);
        #        }
        #
        #        text.appendText(AnytypeUtil::toString(e.current()));
        #
        #        tail = true;
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendIfNotEmpty
        #public static TextBuffer appendIfNotEmpty(TextBuffer text, str s)
        #{
        #    if( s && text && text.size() )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendInfolog
        #public static TextBuffer appendInfolog(TextBuffer textOrNull, InfologData info = infolog.export(), str newLine = '\n')
        #{
        #    TextBuffer              text = TextBufferUtil::nonNull(textOrNull);
        #    boolean                 firstLine = true;
        #    SysInfologEnumerator    sysInfologEnumerator;
        #    SysInfologMessageStruct messageStruct;
        #    SysInfoLogStr           message;
        #
        #    if (info)
        #    {
        #        sysInfologEnumerator = SysInfologEnumerator::newData(info);
        #        while (sysInfologEnumerator.moveNext())
        #        {
        #            if (!firstLine && newLine)
        #            {
        #                text.appendText(newline);
        #            }
        #
        #            messageStruct = SysInfologMessageStruct::construct(sysInfologEnumerator.currentMessage());
        #            message = messageStruct.message();
        #            if (message)
        #            {
        #                text.appendText(message);
        #                firstLine = false;
        #            }
        #        }
        #    }
        #
        #    return text;
        #}
        #
      ENDSOURCE
      SOURCE #appendStr
        #public static TextBuffer appendStr(TextBuffer textOrNull, str s)
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #
        #    if( s )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #calcIndent
        #// рассчитывает бощий отступ, который может быть применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// при расчете игнорирует пустые и пробельные строки (строки, содержащие только пробелы)
        #public static int calcIndent(TextBuffer text)
        #{
        #    int     ident;
        #    int     lineIndent;
        #    int     startPos    = 1;
        #
        #    if( !text )
        #        return 0;
        #
        #    if( !text.size() )
        #        return 0;
        #
        #    ident = maxint();
        #
        #    ///////////////////
        #    if( text.find('< +') )
        #    {
        #        lineIndent = text.matchLen();
        #        startPos = text.matchPos() + text.matchLen();
        #    }
        #
        #    while( text.find('\n *', startPos) )
        #    {
        #        // вторая половина условия срабатывает толкьо для непробельных строк
        #        if( lineIndent < ident && startPos != text.matchPos() )
        #        {
        #            ident = lineIndent;
        #        }
        #
        #        lineIndent = text.matchLen() - 1;
        #        startPos = text.matchPos() + text.matchLen();
        #    }
        #
        #    if( lineIndent < ident && startPos <= text.size() )
        #    {
        #        ident = lineIndent;
        #    }
        #    else if( ident == maxint() )
        #    {
        #        ident = lineIndent;
        #    }
        #
        #    return ident;
        #}
      ENDSOURCE
      SOURCE #changeIndent
        #// добавляет или удаляет отступ слева у каждой строки в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #// возвращает измененный TextBuffer, не создает копию если TextBuffer уже создан
        #// возвращаемый объект никогда не равен null
        #//
        #// text - исходный текст, в котором метод изменяет отступы
        #// identOffset - положительное значение увеличивает отступ, отрицательное значение уменьшает отступ, нулевое значение не меняет текст
        #//
        #public static TextBuffer changeIndent(TextBuffer textOrNull, int indentOffset)
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #
        #    if( text.size() == 0 )
        #        return text;
        #
        #    while( indentOffset < 0 )
        #    {
        #        text.replace('< ', '');
        #        text.replace('\n ', '\n');
        #        indentOffset++;
        #    }
        #
        #    while( indentOffset > 0 )
        #    {
        #        text.insert(' ', 1);
        #        text.replace('\n', '\n ');
        #        indentOffset--;
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #fromStr
        #public static TextBuffer fromStr(str s)
        #{
        #    TextBuffer text = new TextBuffer();
        #
        #    if( s )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #getText
        #public static str getText(TextBuffer text)
        #{
        #    str ret = text ? text.getText() : '';
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static TextBuffer newFrom(TextBuffer textOrNull)
        #{
        #    TextBuffer text = new TextBuffer();
        #
        #    if( textOrNull && textOrNull.size() )
        #    {
        #        text.setText(textOrNull.getText());
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static TextBuffer nonNull(TextBuffer text)
        #{
        #    if( !text )
        #    {
        #        text = new TextBuffer();
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет общий для всех строк отступ в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #//
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static TextBuffer trimIndent(TextBuffer text)
        #{
        #    TextBuffer  ret     = new TextBuffer();
        #    int         startPos;
        #    int         endPos;
        #    int         len;
        #    int         indent;
        #;
        #    if( text == null )
        #        return ret;
        #
        #    if( text.size() == 0 )
        #        return ret;
        #
        #    // удаляем первую пустую или пробельную строку
        #    if( text.find('< *\n') )
        #        startPos = text.matchPos() + text.matchLen();
        #    else
        #        startPos = 1;
        #
        #    // удаляем последнюю пустую или пробельную строку
        #    if( text.find('\n *>') )
        #        endPos = text.matchPos() - 1;
        #    else
        #        endPos = text.size();
        #
        #    len = endPos - startPos + 1;
        #
        #    if( len <= 0 )
        #        return ret;
        #
        #    if( len == text.size() )
        #        ret = text;
        #    else
        #        ret.setText(text.subStr(startPos, len));
        #
        #    indent = TextBufferUtil::calcIndent(ret);
        #
        #    if( indent == 0 )
        #        return ret;
        #
        #    ret = TextBufferUtil::changeIndent(ret, -indent);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextUtil
    PROPERTIES
      Name                #TextUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс оперирует с текстом - многострочной строкой (multiline string)
        #// если текст содержит только одну строку, то класс работает также как и строковые функции
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TextUtil
        #{
        #}
      ENDSOURCE
      SOURCE #after
        #// возвращает текст с подстроками, которые находится после первого вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','-') == 'DEF-GH\nLMN-OP'
        #//      TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str after(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*?%1', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterChar
        #// возвращает текст с подстроками, которые находятся после первого вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','-') == 'DEF-GH\nLMN-OP'
        #//      TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*?[%1]', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterLast
        #// возвращает текст с подстроками, которые находятся после последнего вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','-') == 'GH\nOP'
        #//      TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterLast(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*%1', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterLastChar
        #// возвращает текст с подстроками, которые находятся после последнего вхожения любого из указанных символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','-=') == 'GH\nOP'
        #//      TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP',',')  == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterLastChar(str s, str characters)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( characters == '' )
        #        return s;
        #
        #    pattern = strfmt(@'(?m)^.*[%1]', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #appendEnd
        #// добавляет строку в конец каждой подстроки текста
        #//
        #// пример:
        #//      TextUtil::appendEnd('ABC-DEF-GH\nIJK-LMN-OP',';') == 'ABC-DEF-GH;\nIJK-LMN-OP;'
        #//      TextUtil::appendEnd('ABC-DEF-GH',            ';') == 'ABC-DEF-GH;'
        #//      TextUtil::appendEnd('',                      ';') == ';'
        #//
        #public static str appendEnd(str text, str start)
        #{
        #    if( text == '' )
        #        return start;
        #
        #    if( start == '' )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, @'(?m)$', start);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendStart
        #// добавляет строку в начало каждой подстроки текста
        #//
        #// пример:
        #//      TextUtil::appendStart('ABC-DEF-GH\nIJK-LMN-OP','* ') == '* ABC-DEF-GH\n* IJK-LMN-OP'
        #//      TextUtil::appendStart('ABC-DEF-GH',            '* ') == '* ABC-DEF-GH'
        #//      TextUtil::appendStart('',                      '* ') == '* '
        #//
        #public static str appendStart(str text, str end)
        #{
        #    if( text == '' )
        #        return end;
        #
        #    if( end == '' )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, @'(?m)^', end);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #before
        #// возвращает текст с подстроками, которые находятся после первого вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','-') == 'ABC\nIJK'
        #//      TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str before(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)%1.*?$', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeChar
        #// возвращает текст с подстроками, которые находятся после первого вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','=-') == 'ABC\nIJK'
        #//      TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)[%1].*?$', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeLast
        #// возвращает текст с подстроками, которые находятся после последнего вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','-') == 'ABC-DEF\nIJK-LMN'
        #//      TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeLast(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)%1(?!.*%1).*$', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeLastChar
        #// возвращает текст с подстроками, которые находятся после последнего вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','=-') == 'ABC-DEF\nIJK-LMN'
        #//      TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP',',')  == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeLastChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)[%1](?!.*[%1]).*$', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #calcIndent
        #// рассчитывает отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как один непробельный значащий символ
        #public static int calcIndent(str text)
        #{
        #    int indent = maxint();
        #    int i;
        #
        #    System.Text.RegularExpressions.Match            rMatch;
        #    System.Text.RegularExpressions.GroupCollection  rGroupCollection;
        #    System.Text.RegularExpressions.Group            rGroup;
        #
        #    if( text == '' )
        #        return 0;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    rMatch = System.Text.RegularExpressions.Regex::Match(text, @'^(\r?\n)*(?<indent> *).*((\r?\n)+( *|\k<indent>.*))*$');
        #    if( rMatch && rMatch.get_Success() )
        #    {
        #        rGroupCollection = rMatch.get_Groups();
        #        rGroup = rGroupCollection.get_Item('indent');
        #        i = rGroup.get_Length();
        #        indent = min(indent, i);
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    if( indent == maxint() )
        #        return 0;
        #
        #    return indent;
        #}
      ENDSOURCE
      SOURCE #callStack
        #// отображаем как в отладчике
        #public static str callStack(int skip = 2, container callStack = xSession::xppCallStack())
        #{
        #    str ret = TextBufferUtil::appendCallStack(null, skip, callStack).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #changeIndent
        #// добавляет или удаляет отступ слева у каждой строки в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #//
        #// text - исходный текст, в котором метод изменяет отступы
        #// identOffset - положительное значение увеличивает отступ, отрицательное значение уменьшает отступ, нулевое значение не меняет текст
        #//
        #public static str changeIndent(str text, int indentOffset)
        #{
        #    str pattern;
        #    str replacement;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( indentOffset == 0 )
        #        return text;
        #
        #    if( indentOffset < 0 )
        #    {
        #        pattern = strfmt('(?m)^ {1,%1}', -indentOffset);
        #        replacement = '';
        #    }
        #    else
        #    {
        #        pattern = '(?m)^';
        #        replacement = strrep(' ', indentOffset);
        #    }
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, replacement);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #drop
        #// в каждой строке многострочного текста:
        #// = удаляет первые n символов, если n > 0
        #// = удаляет последние n символов, если n < 0
        #// возвращает исходный текст, если n == 0
        #public static str drop(str text, int n)
        #{
        #    if( n > 0 )
        #        return TextUtil::dropStart(text, n);
        #
        #    return TextUtil::dropEnd(text, -n);
        #}
      ENDSOURCE
      SOURCE #dropEnd
        #// в каждой строке многострочного текста:
        #// = удаляет последние n символов, если n < 0
        #// возвращает исходный текст, если n => 0
        #public static str dropEnd(str text, int n)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( n >= 0 )
        #        return text;
        #
        #    pattern = strfmt('(?m).{1,%1}$', -n);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #dropStart
        #// в каждой строке многострочного текста:
        #// удаляет первые n символов, если n > 0
        #// возвращает исходный текст, если n <= 0
        #public static str dropStart(str text, int n)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( n <= 0 )
        #        return text;
        #
        #    pattern = strfmt('(?m)^.{1,%1}', n);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #fromInfolog
        #public static str fromInfolog(int fromLine)
        #{
        #    InfologData infologData = infolog.copy(fromLine);
        #    str ret = TextBufferUtil::appendInfolog(null, infologData).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #infolog
        #public static str infolog(InfologData info = infolog.export(), str newLine = '\n')
        #{
        #    str ret = TextBufferUtil::appendInfolog(null, info, newLine).getText();
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #line
        #// возвращает n-ую строку из многострочного текста
        #public static str line(str s, int n)
        #{
        #    str ret = strline(s, n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lines
        #public static System.String[] lines(str text)
        #{
        #    System.String[] ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    ret = System.Text.RegularExpressions.Regex::Split(text, '\n');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padLeft
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #public static str padLeft(str text, int length, char char = ' ')
        #{
        #    TextBuffer                              ret = new TextBuffer();
        #    str                                     s;
        #    int                                     n;
        #    System.Char                             c;
        #    System.String                           ss;
        #    System.Text.RegularExpressions.Match    rMatch;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( char == '' )
        #        return text;
        #
        #    if( length <= 0 )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    c = System.Char::Parse(char);
        #
        #    rMatch = System.Text.RegularExpressions.Regex::Match(text, @'(?m)^.*$');
        #    while( rMatch && rMatch.get_Success() )
        #    {
        #        ss = rMatch.get_Value();
        #        s = ss.PadLeft(length, c);
        #
        #        if( n )
        #            ret.appendText('\n');
        #
        #        ret.appendText(s);
        #
        #        rMatch = rMatch.NextMatch();
        #        ++n;
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #padRight
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padRight(str text, int length, char char = ' ')
        #{
        #    TextBuffer  ret = new TextBuffer();
        #    str         s;
        #
        #    System.Char                     c;
        #    System.String                   ss;
        #    System.String[]                 ssa;
        #    System.Collections.IEnumerator  se;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( char == '' )
        #        return text;
        #
        #    if( length <= 0 )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    ssa = TextUtil::lines(text);
        #    se  = ssa.GetEnumerator();
        #    while( se.MoveNext() )
        #    {
        #        if( ret.size() )
        #        {
        #            ret.appendText('\n');
        #        }
        #        else
        #        {
        #            c = System.Char::Parse(char);
        #        }
        #
        #        ss = se.get_Current();
        #        s  = ss.PadRight(length, c);
        #
        #        ret.appendText(s);
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #strLeft
        #// возвращает текст, в котором каждая строка содержит не более заданной длины справа
        #static str strLeft(str s, int len)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( len > 0 )
        #        pattern = strfmt(@'(?m)(?<=.{%1}).+', len);
        #    else
        #        pattern = strfmt(@'(?m).+', len);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #strRight
        #// возвращает текст, в котором каждая строка содержит не более заданной длины слева
        #static str strRight(str s, int len)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( len > 0 )
        #        pattern = strfmt(@'(?m).+(?=.{%1})', len);
        #    else
        #        pattern = strfmt(@'(?m).+', len);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #toArray
        #// TODO
        #public static container toArray(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #// TODO
        #public static container toList(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toMap
        #// TODO
        #public static container toMap(str s, int startLineNum = 1)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toSet
        #// TODO
        #public static container toSet(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trim
        #// убирает указанные символы в начале и в конце всех строк в многострочном тексте
        #// по умолчанию, убирает пробелы, табуляцию и переводы строк
        #static str trim(str s, str ws = ' \t')
        #{
        #    str ret;
        #    int len = strlen(s);
        #    int fromPos = strnfind(s, ws, 1, len);
        #    int toPos = strnfind(s, ws, len, -len);
        #
        #    if( fromPos && fromPos <= toPos )
        #    {
        #        ret = substr(s, fromPos, toPos - fromPos + 1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimBlankLines
        #static str trimBlankLines(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #    //TODO
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimEnd
        #//TODO
        #public static str trimEnd(str s, str ws = ' \t')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static str trimIndent(str s)
        #{
        #    int indent;
        #
        #    if( s == '' )
        #        return s;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    // удаляем первую и последнюю пустые или пробельные строки
        #    s = System.Text.RegularExpressions.Regex::Replace(s, '^ *\n|\n *$', '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    indent = TextUtil::calcIndent(s);
        #
        #    s = TextUtil::changeIndent(s, -indent);
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #trimStart
        #//TODO
        #public static str trimStart(str s, str ws = ' \t')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: CollectionUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #CollectionUtil
    PROPERTIES
      Name                #CollectionUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #//
        #// TODO work in progress
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class CollectionUtil
        #{
        #}
      ENDSOURCE
      SOURCE #as
        #public static anytype as(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #empty
        #public static boolean empty(anytype collection)
        #{
        #    Enumerator e = CollectionUtil::getEnumerator(collection);
        #
        #    if( e && e.moveNext() )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает объект, у которого можно вызвать метод moveNext или Null
        #// возвращает null, если параметр не является ни коллекцией, ни энумератором
        #//
        #// используйте EnumeratorUtil::getEnumerator() чтобы получить энумератор для любого объекта
        #public static Enumerator getEnumerator(anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::newFromCollection(collection);
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #in
        #public static boolean in(anytype value, anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( value == e.current() )
        #        {
        #            return true;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #is
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean is(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ConUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ConUtil
    PROPERTIES
      Name                #ConUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ConUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static container add(container con, anytype collectionOrValue)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        #
        #    while( e && e.moveNext() )
        #    {
        #        con += e.current(); // ядро бросит исключение, если тип значения не может быть помещен в контейнер
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #contains
        #public static boolean contains(container con, anytype value)
        #{
        #    boolean ret = (confind(con, value) != 0);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAll
        #public static boolean containsAll(container con, anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( ret && e && e.moveNext() )
        #    {
        #        ret = ret && (confind(con, e.current()) != 0);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #conView
        #public static FormRun conView(container con, str caption = '', boolean lookup = false)
        #{
        #    return conView(con, caption, lookup);
        #}
      ENDSOURCE
      SOURCE #countAs
        #public static int countAs(container con, Types type)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( typeof(conpeek(con,i)) == type )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countValue
        #public static int countValue(container con, anytype value)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( conpeek(con,i) == value )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #delete
        #public static container delete(container con, int start, int number)
        #{
        #    container ret = condel(con, start, number);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #distinct
        #// возвращает новый контейнер, в котором присутствуют только уникальные объекты (дубли удалены)
        #public static container distinct(anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #    container ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( !confind(ret, e.current()) )
        #        {
        #            ret += e.current();
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #public static container drop(container con, int n = 1)
        #{
        #    container ret;
        #    int i;
        #    int len = conlen(con);
        #
        #    for( i=n; i<=len; i++ )
        #    {
        #        ret += conpeek(con, 1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #find
        #public static int find(container con, anytype element)
        #{
        #    int ret = confind(con, element);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #public static anytype first(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ConEnumerator getEnumerator(container con)
        #{
        #    ConEnumerator ret = ConEnumerator::construct(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #head
        #public static anytype head(container con)
        #{
        #    anytype ret = ConUtil::first(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #public static boolean in(anytype value, container con)
        #{
        #    boolean ret = (confind(con, value) != 0);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #public static container insert(container con, int start, anytype element)
        #{
        #    container ret = conins(con, start, element);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(container con)
        #{
        #    if( con )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(container con)
        #{
        #    if( con )
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #last
        #public static anytype last(container con)
        #{
        #    int lastPos = conlen(con);
        #    anytype ret = conpeek(con, lastPos);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #len
        #public static int len(container con)
        #{
        #    int ret = conlen(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #match
        #// проверяет есть ли вхожение паттерна в какую-нибудь строку внутри контейнера
        #// проверку выполняет рекурсивно
        #public static boolean match(
        #    str         pattern,
        #    container   con)
        #{
        #    int     len     = conlen(con);
        #    int     i;
        #    Any     value;
        #
        #    for( i=1; i<=len; ++i )
        #    {
        #        value = Any::conpeek(con, i);
        #
        #        switch( value.type() )
        #        {
        #            case Types::String:
        #            case Types::RString:
        #            case Types::VarString:
        #                if( match(pattern, value.asString()) )
        #                    return true;
        #                break;
        #
        #            case Types::Container:
        #                if( ConUtil::match(pattern, value.asContainer()) )
        #                    return true;
        #                break;
        #
        #            case Types::Record:
        #                if( RecordUtil::match(pattern, value.asRecord()) )
        #                    return true;
        #                break;
        #
        #            default:
        #                break;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #maxAs
        #public static anytype maxAs(container con, Types type)
        #{
        #    anytype ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( typeof(conpeek(con,i)) == type )
        #        {
        #            if( typeof(ret) == AnytypeUtil::undefined() )
        #            {
        #                ret = conpeek(con, i);
        #            }
        #            else
        #            {
        #                ret = max(ret, conpeek(con, i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #maxAsValue
        #// возвращает максимум элементов, тип которых совпадает с типом второго параметра
        #//
        #// метод удобно использовать, передавая как второй параметр переменную,
        #// в которую будете разместите результат
        #//
        #// пример использования:
        #//     container con = [1, 'test', 2, 3.01];
        #//     int maxValue = ConUtil::maxAs(con, maxValue); // метод вернет 2
        #//
        #public static anytype maxAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::maxAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #maxCon
        #public static anytype maxCon(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    Types type = typeof(ret);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2; i<=len; i++ )
        #    {
        #        if( typeof(conpeek(con, i)) == type )
        #        {
        #            ret = max(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minAs
        #public static anytype minAs(container con, Types type)
        #{
        #    anytype ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( typeof(conpeek(con,i)) == type )
        #        {
        #            if( typeof(ret) == Types::AnyType )
        #            {
        #                ret = conpeek(con, i);
        #            }
        #            else
        #            {
        #                ret = min(ret, conpeek(con, i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minAsValue
        #// возвращает минимум элементов, тип которых совпадает с типом второго параметра
        #//
        #// метод удобно использовать, передавая как второй параметр переменную,
        #// в которую будете разместите результат
        #//
        #// пример использования:
        #//     container con = [1, 'test', 2, 3.01];
        #//     int minValue = ConUtil::minAs(con, minValue); // метод вернет 1
        #//
        #public static anytype minAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::minAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minCon
        #public static anytype minCon(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    Types type = typeof(ret);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2; i<=len; i++ )
        #    {
        #        if( typeof(conpeek(con, i)) == type )
        #        {
        #            ret = min(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static container newFrom(anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #    container con;
        #
        #    while( e && e.moveNext() )
        #    {
        #        con += e.current();
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #public static container newFromArray(Array array)
        #{
        #    container ret;
        #    int i;
        #
        #    for( i=1; array && i<=array.lastIndex(); ++i )
        #    {
        #        ret += array.value(i);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromBlob
        #public static container newFromBlob(container blob)
        #{
        #    return ContainerClass::blob2Container(blob);
        #}
      ENDSOURCE
      SOURCE #newFromBuf
        #public static container newFromBuf(Common buffer)
        #{
        #    // первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        #    container ret = [buffer.TableId, buffer];
        #    ;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static container newFromList(List list)
        #{
        #    ListEnumerator le = ListUtil::getEnumerator(list);
        #    container ret;
        #
        #    while( le && le.moveNext() )
        #    {
        #        ret += le.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromMap
        #public static container newFromMap(Map map)
        #{
        #    container ret;
        #    MapEnumerator me = MapUtil::getEnumerator(map);
        #
        #    while( me && me.moveNext() )
        #    {
        #        ret += [[me.currentKey(), me.currentValue()]];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static container newFromSet(Set set)
        #{
        #    SetEnumerator se = SetUtil::getEnumerator(set);
        #    container ret;
        #
        #    while( se && se.moveNext() )
        #    {
        #        ret += se.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static container newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    container ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret += e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromXml
        #public static container newFromXml(XmlNode node)
        #{
        #    return Global::containerFromXMLNode(node);
        #}
      ENDSOURCE
      SOURCE #peekAs
        #public static anytype peekAs(container con, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype ret = AnytypeUtil::as(conpeek(con, idx), type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsContainer
        #public static container peekAsContainer(container con, int idx)
        #{
        #    container ret = AnytypeUtil::asContainer(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsDate
        #public static Date peekAsDate(container con, int idx)
        #{
        #    Date ret = AnytypeUtil::asDate(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsDateTime
        #public static UtcDateTime peekAsDateTime(container con, int idx)
        #{
        #    utcdatetime ret = AnytypeUtil::asDateTime(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsEnum
        #public static anytype peekAsEnum(container con, int idx, enumId enumId = 0)
        #{
        #    anytype ret = AnytypeUtil::asEnum(conpeek(con, idx), enumId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsGUID
        #public static GUID peekAsGUID(container con, int idx)
        #{
        #    GUID ret = AnytypeUtil::asGUID(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsInt
        #public static int peekAsInt(container con, int idx)
        #{
        #    int ret = AnytypeUtil::asInt(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsInt64
        #public static Int64 peekAsInt64(container con, int idx)
        #{
        #    Int64 ret = AnytypeUtil::asInt64(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsReal
        #public static Real peekAsReal(container con, int idx)
        #{
        #    Real ret = AnytypeUtil::asInt(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsRecId
        #public static int64 peekAsRecId(container con, int idx)
        #{
        #    Int64 ret = AnytypeUtil::asRecId(conpeek(con, idx));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsRecord
        #public static Common peekAsRecord(container con, int idx, TableId tableId = 0)
        #{
        #    Common ret = AnytypeUtil::asRecord(conpeek(con, idx), tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsValue
        #public static anytype peekAsValue(container con, int idx, anytype asValue)
        #{
        #    anytype ret = AnytypeUtil::asValue(conpeek(con, idx), asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #poke
        #public static container poke(container con, int start, anytype value)
        #{
        #    container ret = conpoke(con, start, value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ratainAll
        #// возвращает контейнер, в котором содержатся элементы, равные value
        #public static container ratainAll(container con, anytype value)
        #{
        #    container ret;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( value == ce.current() )
        #        {
        #            ret += value;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #remove
        #public static container remove(container con, anytype value)
        #{
        #    int i = confind(con, value);
        #
        #    if( i )
        #    {
        #        con = condel(con, i, 1);
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #removeAll
        #public static container removeAll(container con, anytype value)
        #{
        #    int i;
        #
        #    do
        #    {
        #        i = confind(con, value);
        #        if( i )
        #        {
        #            con = condel(con, i, 1);
        #        }
        #    }
        #    while( i );
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #removeAllEnumerator
        #public static container removeAllEnumerator(container con, Enumerator e)
        #{
        #    container ret = con;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ConUtil::removeAll(ret, e.current());
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый контейнер, в котором удалены все пустые элементы
        #public static container removeEmpty(anytype collectionOrValue)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        #    container ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() )
        #        {
        #            ret += e.current(); // ядро бросит исключение, если тип значения не может быть помещен в контейнер
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainAllByEnumerator
        #public static container retainAllByEnumerator(container con, Enumerator e)
        #{
        #    container ret = con;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ConUtil::removeAll(ret, e.current());
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #sumAs
        #public static anytype sumAs(container con, Types type)
        #{
        #    anytype ret;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( typeof(ce.current()) == type )
        #        {
        #            ret += ce.current();
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAsStr
        #public static str sumAsStr(container con)
        #{
        #    str ret;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( AnytypeUtil::isString(ce.current()) )
        #        {
        #            ret += ce.current();
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAsValue
        #public static anytype sumAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::sumAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumCon
        #public static anytype sumCon(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2 ; i<=len ; i++ )
        #    {
        #        ret += conpeek(con, i);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #tail
        #public static container tail(container con)
        #{
        #    container ret = ConUtil::take(con, conlen(con), 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #public static container take(container con, int n = 1, int startFrom = 1)
        #{
        #    container ret;
        #
        #    int len     = conlen(con);
        #    int i       = max(0, startFrom);
        #    int lastPos = min(i+n-1, len);
        #
        #    while( i<=lastPos )
        #    {
        #        ret += conpeek(con, i);
        #        i++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toArray
        #public static Array toArray(container con)
        #{
        #    Array ret = ArrayUtil::newFromCon(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toBlob
        #public static container toBlob(container con)
        #{
        #    ContainerClass containerClass = new ContainerClass(con);
        #
        #    return containerClass.toBlob();
        #}
      ENDSOURCE
      SOURCE #toBuf
        #public static Common toBuf(container con)
        #{
        #    TableId tableId;
        #    Common ret;
        #    ;
        #
        #    // первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        #    // возможны проблемы, если после создания container таблица изменена в AOT.
        #    // метод работает очень быстро.
        #    [tableId, ret] = con;
        #
        #    Debug::assert(tableId == ret.TableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #public static List toList(container con, List list = null)
        #{
        #    Any any;
        #    int i;
        #    int len = conlen(con);
        #
        #    for( i=1; i<=len; ++i )
        #    {
        #        any = Any::conpeek(con, i);
        #
        #        if( !list )
        #        {
        #            list = new List(any.type());
        #        }
        #
        #        if( any.type() == list.typeId() )
        #        {
        #            list.addEnd(any.value());
        #        }
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #toSet
        #public static Set toSet(container con, Set set = null)
        #{
        #    Any any;
        #    int i;
        #    int len = conlen(con);
        #
        #    for( i=1; i<=len; ++i )
        #    {
        #        any = Any::conpeek(con, i);
        #
        #        if( !set )
        #        {
        #            set = new Set(any.type());
        #        }
        #
        #        if( any.type() == set.typeId() )
        #        {
        #            set.add(conpeek(con, i));
        #        }
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(container con, str sep = ',')
        #{
        #    str ret = TextBufferUtil::appendContainer(null, con, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toXmlString
        #public static str toXmlString(container con, int indent = 0)
        #{
        #    return Global::XMLString(con, types::Container, indent);
        #}
      ENDSOURCE
      SOURCE #typeofAll
        #// возвращает
        #//   Types::void - если контейнер пуст
        #//   Types::AnyType - если в контейнере содержатся элементы разного типа
        #//   Types::* - если все элементы одного типа
        #public static Types typeofAll(container con)
        #{
        #    Types type = Types::void;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    if( ce && ce.moveNext() )
        #    {
        #        type = typeof(ce.current());
        #    }
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( type != typeof(ce.current()) )
        #        {
        #            return Types::AnyType;
        #        }
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #zip
        #public static container zip(container con1, container con2, int maxElements = 0)
        #{
        #    container   ret;
        #    int         minLen = min(conlen(con1), conlen(con2));
        #    int         idx;
        #
        #    if( maxElements && maxElements < minLen )
        #    {
        #        minLen = maxElements;
        #    }
        #
        #    for (idx = 1; idx <= minlen; idx++)
        #    {
        #        ret += conpeek(con1, idx) + conpeek(con2, idx);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ListUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ListUtil
    PROPERTIES
      Name                #ListUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ListUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static List add(List list, anytype value)
        #{
        #    if( !list )
        #    {
        #        list = new List(typeof(value));
        #    }
        #    else if( list.typeId() != typeof(value) )
        #    {
        #        return list; // значение с другим типом не будет добавлено
        #    }
        #
        #    list.addEnd(value);
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #append
        #public static List append(List list, anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #    while( e && e.moveNext() )
        #    {
        #        list = ListUtil::add(list, e.moveNext());
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонирует list, не клонирует элементы списка
        #//
        #// see deepClone()
        #public static List clone(List list)
        #{
        #    List ret;
        #
        #    if( list )
        #    {
        #        ret = new List(list.typeId());
        #        ret.appendList(list);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонирует и list, и элементы списка
        #//
        #// see clone()
        #public static List deepClone(List list)
        #{
        #    List ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        packedList = list.pack();
        #        ret = List::create(packedList);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #distinct
        #// возвращает новый список, в котором присутствуют только уникальные объекты (дубли удалены)
        #public static List distinct(List list)
        #{
        #    Set set = SetUtil::newFromList(list);
        #    List ret = ListUtil::newFromSet(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(List list)
        #{
        #    int ret;
        #
        #    if( list )
        #    {
        #        ret = list.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #empty
        #public static boolean empty(List list)
        #{
        #    boolean ret = true;
        #
        #    if( list )
        #    {
        #        ret = list.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ListEnumerator getEnumerator(List list)
        #{
        #    ListEnumerator ret;
        #
        #    if( list )
        #    {
        #        ret = list.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #merge
        #// возвращает новый список, который содержит все элементы первого списка, затем все элементы второго списка
        #public static List merge(List list1, List list2)
        #{
        #    if( !list2 )
        #    {
        #        return ListUtil::clone(list1);
        #    }
        #
        #    if( !list1 )
        #    {
        #        return ListUtil::clone(list2);
        #    }
        #
        #    if( list1.typeId() != list2.typeId() )
        #    {
        #        return ListUtil::clone(list1);
        #    }
        #
        #    return List::merge(list1, list2);
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать list для хранения значений, тип которых совпадает с типом переменной value
        #public static List newBy(anytype value)
        #{
        #    Types type = typeof(value);
        #    List ret = new List(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static List newFrom(anytype collection)
        #{
        #    List list;
        #    Enumerator e;
        #
        #    if( AnytypeUtil::isList(collection) )
        #    {
        #        list = ListUtil::clone(collection);
        #    }
        #    else
        #    {
        #        e = EnumeratorUtil::getEnumerator(collection);
        #        while( e && e.moveNext() )
        #        {
        #            list = ListUtil::add(list, e.current());
        #        }
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static List newFromArray(Array arr)
        #{
        #    List ret;
        #    container packedArray;
        #
        #    if( arr )
        #    {
        #        packedArray = arr.pack();
        #        ret = List::create(packedArray);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static List newFromContainer(container con)
        #{
        #    List ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        ret = ListUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static List newFromList(List list)
        #{
        #    List ret = ListUtil::clone(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает список записей из буфера, который был заполнен командой select
        #public static RecordList newFromSelect(Common selectedRecords, int maxElements = 0)
        #{
        #    RecordList ret = RecordList::fromSelect(selectedRecords, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static List newFromSet(Set set)
        #{
        #    List ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        packedSet = set.pack();
        #        ret = List::create(packedSet);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static List newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    List ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ListUtil::add(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static List nonNull(List list, Types type = Types::AnyType)
        #{
        #    if( !list )
        #    {
        #        list = new List(type);
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(List list)
        #{
        #    container ret = ConUtil::newFromList(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toSet
        #public static Set toSet(List list)
        #{
        #    Set ret = SetUtil::newFromList(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(List list, str sep = ',')
        #{
        #    str ret = StrUtil::newFromList(list, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(List list)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( list )
        #    {
        #        ret = list.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SetUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SetUtil
    PROPERTIES
      Name                #SetUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class SetUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static Set add(Set set, anytype value)
        #{
        #    if( !set )
        #    {
        #        set = new Set(typeof(value));
        #    }
        #    else if( set.typeId() != typeof(value) )
        #    {
        #        return set; // значение с другим типом не будет добавлено
        #    }
        #
        #    set.add(value);
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #addFieldValue
        #public static Set addFieldValue(Set set, Common buf, FieldId fieldId)
        #{
        #    anytype value = RecordUtil::getValue(buf, fieldId);
        #    Set ret = SetUtil::add(set, value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонирует set, не клонирует элементы множества
        #//
        #// see deepClone()
        #public static Set clone(Set set)
        #{
        #    Set ret;
        #
        #    if( set )
        #    {
        #        ret = new Set(set.typeId());
        #        ret = Set::union(ret, set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонирует и set, и элементы множества
        #//
        #// see clone()
        #public static Set deepClone(Set set)
        #{
        #    Set ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        packedSet = set.pack();
        #        ret = Set::create(packedSet);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #difference
        #public static Set difference(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    if( !set1 )
        #    {
        #        return null;
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    return Set::difference(set1, set2);
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(Set set)
        #{
        #    int ret;
        #
        #    if( set )
        #    {
        #        ret = set.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #empty
        #public static boolean empty(Set set)
        #{
        #    boolean ret = true;
        #
        #    if( set )
        #    {
        #        ret = set.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static SetEnumerator getEnumerator(Set set)
        #{
        #    SetEnumerator ret;
        #
        #    if( set )
        #    {
        #        ret = set.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #public static Set in(Set set, anytype value)
        #{
        #    boolean ret;
        #
        #    if( set )
        #    {
        #        ret = set.in(value);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #intersection
        #public static Set intersection(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return null;
        #    }
        #
        #    if( !set1 )
        #    {
        #        return null;
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return null;
        #    }
        #
        #    return Set::union(set1, set2);
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать set для хранения значений, тип которых совпадает с типом переменной value
        #public static Set newBy(anytype value)
        #{
        #    Types type = typeof(value);
        #    Set ret = new Set(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static Set newFrom(anytype collection)
        #{
        #    Set set;
        #    Enumerator e;
        #
        #    if( AnytypeUtil::isSet(collection) )
        #    {
        #        set = SetUtil::clone(collection);
        #    }
        #    else
        #    {
        #        e = EnumeratorUtil::getEnumerator(collection);
        #        while( e && e.moveNext() )
        #        {
        #            set = SetUtil::add(set, e.current());
        #        }
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Set newFromArray(Array arr)
        #{
        #    Set ret;
        #    container packedArray;
        #
        #    if( arr )
        #    {
        #        packedArray = arr.pack();
        #        ret = Set::create(packedArray);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static Set newFromContainer(container con)
        #{
        #    Set ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        ret = SetUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Set newFromList(List list)
        #{
        #    Set ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        packedList = list.pack();
        #        ret = Set::create(packedList);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Set newFromSelect(Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    Set ret;
        #    int elements;
        #    anytype value;    // тип поля не меняется внтури цикла, поэтому одного anytype достаточно
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        value = RecordUtil::getValue(selectedRecord, fieldId);
        #        ret = SetUtil::add(ret, value);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static Set newFromSet(Set set)
        #{
        #    Set ret = SetUtil::clone(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static Set newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    Set ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = SetUtil::add(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Set nonNull(Set set, Types type = Types::AnyType)
        #{
        #    if( !set )
        #    {
        #        set = new Set(type);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(Set set)
        #{
        #    container ret = ConUtil::newFromSet(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #public static List toList(Set set)
        #{
        #    List list = ListUtil::newFromSet(set);
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(Set set, str sep = ',')
        #{
        #    str ret = StrUtil::newFromSet(set, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(Set set)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( set )
        #    {
        #        ret = set.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #union
        #public static Set union(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    if( !set1 )
        #    {
        #        return SetUtil::clone(set2);
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return null;
        #    }
        #
        #    return Set::union(set1, set2);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArrayUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArrayUtil
    PROPERTIES
      Name                #ArrayUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ArrayUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static Array add(Array arr, anytype value)
        #{
        #    int lastIndex;
        #
        #    if( !arr )
        #    {
        #        arr = new Array(typeof(value));
        #    }
        #    else if( arr.typeId() != typeof(value) )
        #    {
        #        return arr; // значение с другим типом не будет добавлено
        #    }
        #
        #    lastIndex = arr.lastIndex();
        #    arr.value(lastIndex+1, value);
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонируе массив, не клонирует элементы массива
        #//
        #// see clone()
        #public static Array clone(Array arr)
        #{
        #    Array ret = ArrayUtil::newFrom(arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонируе и массив, и элементы массива
        #//
        #// see clone()
        #public static Array deepClone(Array arr)
        #{
        #    Array ret;
        #    container packedArray;
        #
        #    if( arr )
        #    {
        #        packedArray = arr.pack();
        #        ret = Array::create(packedArray);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ArrayEnumerator getEnumerator(Array arr)
        #{
        #    ArrayEnumerator ret = ArrayEnumerator::construct(arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static Array newFrom(anytype collection)
        #{
        #    Array arr;
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #    while( e && e.moveNext() )
        #    {
        #        arr = ArrayUtil::add(arr, e.current());
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #newFromCon
        #public static Array newFromCon(container con)
        #{
        #    Array ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1; i<=len; ++i )
        #    {
        #        ret = ArrayUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Array newFromList(List list)
        #{
        #    Array ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        packedList = list.pack();
        #        ret = Array::create(packedList);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает массив значений поля из буфера, который был заполнен командой select
        #public static Array newFromSelect(Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    Array ret;
        #    int elements;
        #    anytype value;    // тип поля не меняется внтури цикла, поэтому одного anytype достаточно
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        value = RecordUtil::getValue(selectedRecord, fieldId);
        #        ret = ArrayUtil::add(ret, value);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Array newFromSet(Set set)
        #{
        #    Array ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        packedSet = set.pack();
        #        ret = Array::create(packedSet);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static Array newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    Array ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ArrayUtil::add(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Array nonNull(Array arr, Types type = Types::AnyType)
        #{
        #    if( !arr )
        #    {
        #        arr = new Array(type);
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(Array arr, str sep = ',')
        #{
        #    str ret = StrUtil::newFromArray(arr, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(Array arr)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( arr )
        #    {
        #        ret = arr.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StackUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StackUtil
    PROPERTIES
      Name                #StackUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StackUtil
        #{
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StructUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StructUtil
    PROPERTIES
      Name                #StructUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StructUtil
        #{
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapUtil
    PROPERTIES
      Name                #MapUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class MapUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static Map add(Map map, anytype key, anytype value)
        #{
        #    if( !map )
        #    {
        #        map = new Map(typeof(key), typeof(value));
        #    }
        #
        #    map.insert(key, value); // ядро бросит исключение, если тип значения не совпадает с типом списка
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #clone
        #public static Map clone(Map map)
        #{
        #    Map ret;
        #    MapEnumerator me;
        #
        #    if (map)
        #    {
        #        ret = new Map(map.keyType(), map.valueType());
        #
        #        me = map.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            map.insert(me.currentKey(), me.currentValue());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(Map map)
        #{
        #    int ret;
        #
        #    if( map )
        #    {
        #        ret = map.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #empty
        #public static boolean empty(Map map)
        #{
        #    boolean ret = true;
        #
        #    if( map )
        #    {
        #        ret = map.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #exists
        #public static boolean exists(Map map, anytype key)
        #{
        #    boolean ret = false;
        #
        #    if( map )
        #    {
        #        ret = map.exists(key);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static MapEnumerator getEnumerator(Map map)
        #{
        #    MapEnumerator ret;
        #
        #    if( map )
        #    {
        #        ret = map.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #public static Map insert(Map map, anytype key, anytype value)
        #{
        #    if( !map )
        #    {
        #        map = new Map(typeof(key), typeof(value));
        #    }
        #
        #    map.insert(key, value); // ядро бросит исключение, если тип значения не совпадает с типом списка
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #lookup
        #public static anytype lookup(Map map, anytype key)
        #{
        #    anytype ret;
        #
        #    if( map && map.exists(key) )
        #    {
        #        ret = map.lookup(key);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lookupOrThrow
        #// бросает исключение, если map isNull или key отсутствует в map
        #public static anytype lookupOrThrow(Map map, anytype key)
        #{
        #    anytype ret = map.lookup(key);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать map для хранения значений, тип которых совпадает с типом переменной value
        #public static Map newBy(anytype key, anytype value)
        #{
        #    Types typeKey = typeof(key);
        #    Types typeValue = typeof(value);
        #    Map ret = new Map(typeKey, typeValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Map nonNull(Map map, Types keyType = Types::AnyType, Types valueType = Types::AnyType)
        #{
        #    if( !map )
        #    {
        #        map = new Map(keyType, valueType);
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #remove
        #public static Map remove(Map map, anytype key)
        #{
        #    if( map )
        #    {
        #        map.remove(key);
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: EnumeratorUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #EnumeratorUtil
    PROPERTIES
      Name                #EnumeratorUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class EnumeratorUtil
        #{
        #}
      ENDSOURCE
      SOURCE #asEnumerable
        #public static anytype asEnumerable(anytype value)
        #{
        #    if( EnumeratorUtil::isEnumerable(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asEnumerator
        #public static anytype asEnumerator(anytype value)
        #{
        #    if( EnumeratorUtil::isEnumerator(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает @nonNull объект, у которого можно вызвать метод moveNext или Null
        #// если в качестве аргумента передана не коллекция, то возвращает энумератор по коллекции из одного элемента
        #// поэтому результат этого метода всегда можно энумерировать
        #//
        #// используйте CollectionUtil::getEnumerator()
        #// если хотите получить энумератор только для коллекции, но не по элементу
        #public static Enumerator getEnumerator(anytype collectionOrValue)
        #{
        #    Enumerator e = EnumeratorUtil::newFromCollection(collectionOrValue);
        #
        #    if( !e )
        #    {
        #        e = OneValueEnumerator::construct(collectionOrValue);
        #    }
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerable(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Container:
        #        case Types::Record:
        #            return true;
        #
        #        case Types::Class:
        #            return DictClassUtil::isEnumerable(value);
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerator(anytype value)
        #{
        #    return AnytypeUtil::isImplement(value, classnum(Enumerator));
        #}
      ENDSOURCE
      SOURCE #newFromCollection
        #// возвращает объект, у которого можно вызвать метод moveNext или Null
        #// возвращает null, если параметр не является ни коллекцией, ни энумератором
        #//
        #// используйте EnumeratorUtil::getEnumerator() чтобы получить энумератор для любого объекта
        #public static Enumerator newFromCollection(anytype collection)
        #{
        #    Object obj;
        #
        #    if( collection )
        #    {
        #        if( EnumeratorUtil::isEnumerator(collection) )
        #        {
        #            return collection;
        #        }
        #
        #        switch( typeof(collection) )
        #        {
        #            case Types::Container:
        #                return ConEnumerator::construct(collection);
        #
        #            case Types::Record:
        #                return RecordEnumerator::construct(collection);
        #
        #            case Types::Class:
        #                if( ObjectUtil::isEnumerable(collection) )
        #                {
        #                    obj = collection;
        #                    return obj.getEnumerator();
        #                    // проверки на пустое значение и isEnumerable выше гарантируют,
        #                    // что метод getEnumerator существует и определен правильно
        #                }
        #        }
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArrayEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArrayEnumerator
    PROPERTIES
      Name                #ArrayEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public class ArrayEnumerator implements Enumerator
        #{
        #    Array   arr;
        #    int     idx;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( arr )
        #    {
        #        // мы не делаем никаких проверок индекса
        #        // ядро выбросит исключение, если индекс выходит за пределы массива
        #        return arr.value(idx);
        #    }
        #
        #    return AnytypeUtil::undefined();
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'Array enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(Array _arr)
        #{;
        #    arr = _arr;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if(arr && idx < arr.lastIndex())
        #    {
        #        idx++;
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Array _arr)
        #{
        #    this.init(_arr);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    return AnytypeUtil::toString(this.current());
        #}
      ENDSOURCE
      SOURCE #construct
        #public static ArrayEnumerator construct(Array arr)
        #{
        #    return new ArrayEnumerator(arr);
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse an array.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ConEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ConEnumerator
    PROPERTIES
      Name                #ConEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public class ConEnumerator implements Enumerator
        #{
        #    container   con;
        #    int         len;
        #    int         idx;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    // никаких проверок:
        #    // если индекс выходит за границы контейнера, то conPeek возвратит целый 0
        #    return conPeek(con, idx);
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'container enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(container _con)
        #{
        #    con = _con;
        #    len = conlen(con);
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if( idx < len )
        #    {
        #        idx++;
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(container _con)
        #{
        #    this.init(_con);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    return AnytypeUtil::toString(this.current());
        #}
      ENDSOURCE
      SOURCE #construct
        #public static server ConEnumerator construct(container con)
        #{
        #    return new ConEnumerator(con);
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse a container.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: OneValueEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #OneValueEnumerator
    PROPERTIES
      Name                #OneValueEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// enumerator для ОДНОГО значения произвольного типа
        #class OneValueEnumerator implements Enumerator
        #{
        #    anytype currentValue;
        #    int pos; // 0: before, 1: inside, >1: after. Inside if (pos == 1)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( pos == 1 )
        #    {
        #        return currentValue;
        #    }
        #
        #    return AnytypeUtil::undefined();
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return strfmt('anytype[%1] enumerator', typeof(currentValue));
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// повторный вызов этого метода не приведет к изменению типа переменной currentValue. И не должен приводить.
        #// не вызывайте этот метод напрямую.
        #public void init(anytype value)
        #{
        #    currentValue = value;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    pos++;
        #
        #    return (pos == 1);
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(anytype value)
        #{
        #    this.init(value);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    pos = 0;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    if( pos < 1 )
        #    {
        #        return '(before)';
        #    }
        #    else if( pos > 1 )
        #    {
        #        return '(end)';
        #    }
        #
        #    return strfmt('[%1]', currentValue);
        #}
      ENDSOURCE
      SOURCE #construct
        #public static OneValueEnumerator construct(anytype value)
        #{
        #    return new OneValueEnumerator(value);
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordEnumerator
    PROPERTIES
      Name                #RecordEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// enumerator по записям, которые выбраны оператором select
        #// работает по постоянным и временным таблицам
        #class RecordEnumerator implements Enumerator
        #{
        #    // для временных таблиц переменные указывают на разные буфера в куче
        #    // для регулярных таблиц переменные указывают на один и тот же буфер в куче
        #    Common origBuf;
        #    Common currentBuf;
        #
        #    int pos; // 0: before, 1: inside, >1: after. Inside if (pos == 1)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( pos == 1 )
        #    {
        #        return currentBuf;
        #    }
        #
        #    return RecordUtil::commonRecord();
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return strfmt('record[%2:%3] enumerator', currentBuf.TableId, tableid2name(currentBuf.TableId));
        #}
      ENDSOURCE
      SOURCE #init
        #// не вызывайте этот метод напрямую.
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// повторный вызов этого метода не приведет к изменению типа переменной currentValue. И не должен приводить.
        #public void init(Common buf)
        #{
        #    origBuf = buf;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if( pos == 0 )
        #    {
        #        if( currentBuf.isTmp() )
        #        {
        #            // создаем отдельный буфер на временные данные
        #            currentBuf = RecordUtil::makeRecord(origBuf.TableId);
        #            currentBuf.setTmp();
        #            currentBuf.setTmpData(origBuf);
        #            select currentBuf;
        #        }
        #        else
        #        {
        #            currentBuf = origBuf;
        #            // обе переменные разделяют один и тот же буфер в куче для регулярных таблиц
        #            // нет способа создать clone буфера и при этом сохранить запросы select на разделенных буферах
        #        }
        #    }
        #    else if( pos == 1 && currentBuf.RecId )
        #    {
        #        next currentBuf;
        #        // next изменит состояние буфера в куче.
        #        // поэтому у регулярных таблиц здесь изменится и currentBuf, и origBuf
        #        // а для временных таблиц здесь изменится только currentBuf
        #    }
        #
        #    if( currentBuf.RecId )
        #    {
        #        pos = 1;
        #        return true;
        #    }
        #
        #    pos = 2;
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Common value)
        #{
        #    this.init(value);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    if( currentBuf.isTmp() )
        #    {
        #        pos = 0;
        #    }
        #    else
        #    {
        #        throw error(Error::missingOverride(funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    if( pos < 1 )
        #    {
        #        return strfmt('%1(before)', tableId2name(currentBuf.TableId));
        #    }
        #    else if( pos > 1 )
        #    {
        #        return strfmt('%1(end)', tableId2name(currentBuf.TableId));
        #    }
        #
        #    return RecordUtil::getInfo(currentBuf);
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordEnumerator construct(anytype value)
        #{
        #    return new RecordEnumerator(value);
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrSplitEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrSplitEnumerator
    PROPERTIES
      Name                #StrSplitEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// делит строку на подстроки, разделенные строкой delimiter
        #// Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// делает одну итерацию на всю исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=')   => ['ABC','DEF','GH']
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',2) => ['ABC','DEF:=GH']
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',1) => ['ABC:=DEF:=GH']
        #//
        #class StrSplitEnumerator implements Enumerator
        #{
        #    str     string;
        #    int     stringLenPlus1;
        #    str     delimiterStr;
        #    int     delimiterLen;
        #    int     maxSubstrings;
        #
        #    int     currentIdx; // индекс текущего чанка (не более, чем maxSubstrings)
        #    int     currentPos; // начальная позиция текущего чанка
        #    int     currentLen; // длина текущего чанка
        #
        #    int     nextPos;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    // никаких проверок:
        #    // substr вернет что-нибудь, если параметры странные. скорее всего пустую строку.
        #    str ret = substr(string, currentPos, currentLen);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'Str split enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(str s, str _delimiter, int _maxSubstrings = 0)
        #{
        #    string = s;
        #    stringLenPlus1 = strlen(s) + 1;
        #    delimiterStr = _delimiter;
        #    delimiterLen = strlen(_delimiter);
        #    maxSubstrings = _maxSubstrings;
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #// вычисляет параметры для метода current(): currentPos, currentLen и currentIdx
        #// currentIdx - сколько раз вызывался метод moveNext()
        #//
        #public boolean moveNext()
        #{
        #    int pos;
        #    ;
        #
        #    currentIdx++;
        #    currentPos = nextPos;
        #
        #    // ещё не знаем есть ли ещё разделител. поэтому пока считаем,
        #    // что следующая итерация будет последней, а current() пока должен вернуть пустую строку
        #    nextPos = stringLenPlus1 + 1;
        #    currentLen = 0;
        #
        #    // начнем проверки
        #    if( currentPos > stringLenPlus1 )
        #    {
        #        return false;
        #    }
        #
        #    if( delimiterLen <= 0  )
        #    {
        #        if( currentIdx <= 1 )
        #        {
        #            currentLen = stringLenPlus1; // current() должен вернуть все оставшееся в строке
        #            return true;
        #        }
        #
        #        return false;
        #    }
        #
        #    if( maxSubstrings )
        #    {
        #        if( currentIdx == maxSubstrings )
        #        {
        #            currentLen = stringLenPlus1; // current() должен вернуть все оставшееся в строке
        #            return true;
        #        }
        #        else if( currentIdx > maxSubstrings )
        #        {
        #            return false;
        #        }
        #    }
        #
        #    // где наш разделитель?
        #    pos = strscan(string, delimiterStr, currentPos, stringLenPlus1);
        #    if( pos == 0 )
        #    {
        #        currentLen = stringLenPlus1; // current() должен вернуть все оставшееся в строке
        #        return true;
        #    }
        #
        #    // вот наш разделитель!
        #    // установим правильную длину и правильную позицию для следующей итерации
        #    currentLen = pos - currentPos;
        #    nextPos = pos + delimiterLen;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(str s, str delimiter, int _maxSubstrings = 0)
        #{
        #    this.init(s, delimiter, _maxSubstrings);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #// устанавливает индексы в начальное состояние
        #// никак не запоминает уже найденные позиции подстрок
        #public void reset()
        #{
        #    currentIdx = 0;
        #    currentPos = 0;
        #    currentLen = 0;
        #
        #    nextPos = 1;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    str ret;
        #
        #    if( currentIdx )
        #    {
        #        if( currentPos <= stringLenPlus1 )
        #        {
        #            ret = strfmt('{%1}', this.current());
        #        }
        #        else
        #        {
        #            ret = '{after}';
        #        }
        #    }
        #    else
        #    {
        #        ret = '{before}';
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static server StrSplitEnumerator construct(str s, str delimiter, int maxSubstrings = 0)
        #{
        #    return new StrSplitEnumerator(s, delimiter, maxSubstrings);
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse a splitted string chunks.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrSplitEnumeratorTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrSplitEnumeratorTest
    PROPERTIES
      Name                #StrSplitEnumeratorTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysUtil
        #//
        #class StrSplitEnumeratorTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testSplit
        #void testSplit()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_around
        #void testSplit_around()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct(':=ABC:=DEF:=GH:=',':=');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_Empty
        #void testSplit_Empty()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('',':=');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('',e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyDelimiter
        #void testSplit_EmptyDelimiter()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH','');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF:=GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyDelimiter_max4
        #void testSplit_EmptyDelimiter_max4()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH','',4);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF:=GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyEmptyDelimiter
        #void testSplit_EmptyEmptyDelimiter()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('','');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('',e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max0
        #void testSplit_max0()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',0);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max1
        #void testSplit_max1()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',1);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF:=GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max2
        #void testSplit_max2()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',2);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF:=GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max3
        #void testSplit_max3()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',3);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max4
        #void testSplit_max4()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',4);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF', e.current());
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictClass unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictClass
    PROPERTIES
      Name                #SysDictClass
      Extends             #DictClass
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #as
        #static public Object as(Object _class, classId _classId)
        #{
        #    if (_class && SysDictClass::is(_class, _classId))
        #        return _class;
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static SysDictClass construct(ClassId classId)
        #{
        #    return new SysDictClass(classId);
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Object _class, classId _classId)
        #{
        #    boolean ret = false;
        #
        #    if( _classId )
        #    {
        #        ret = SysDictClass::isEqualOrSuperclass(classidget(_class), _classId);
        #
        #        if( !ret )
        #        {
        #            ret = new SysDictClass(classidget(_class)).isImplementing(_classId);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictEnum unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictEnum
    PROPERTIES
      Name                #SysDictEnum
      Extends             #DictEnum
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #label2value
        #//mazzy 08.12.2020
        #//Eshp CL005594 2019/09/25
        #public int label2value(
        #    str         _labelStr,
        #    LanguageId  _languageId = CompanyInfo::languageId())
        #{
        #    int ret = this.label2valueNoThrow(_labelStr, _languageId);
        #    ;
        #
        #    if (ret < 0)
        #    {
        #        throw error(strfmt(@'Не удалось преобразовать текст "%1" в элемент Enum "%2" (%3).',
        #            _labelStr, this.label(), this.name()));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #label2valueNoThrow
        #//mazzy 08.12.2020
        #//Eshp CL005594 2019/09/25
        #public int label2valueNoThrow(
        #    str         _labelStr,
        #    LanguageId  _languageId     = CompanyInfo::languageId())
        #{
        #    Label   label   = new Label(_languageId);
        #    int     idx;
        #    int     value;
        #    str     labelValue;
        #    int     ret     = -1;
        #    ;
        #
        #    for (idx = 0; idx < this.values(); idx++)
        #    {
        #        value = this.index2Value(idx);
        #        if (int2str(value) == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #
        #        labelValue = label.extractString(this.index2LabelId(idx));
        #        if (labelValue == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #
        #        if (this.index2Symbol(idx) == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #fromEnum
        #public static SysDictEnum fromEnum(anytype enum)
        #{
        #    enumId          enumId          = DictEnum::value2id(enum);
        #    SysDictEnum     sysDictEnum     = new SysDictEnum(enumId);
        #
        #    return sysDictEnum;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictTable unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictTable
    PROPERTIES
      Name                #SysDictTable
      Extends             #DictTable
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #fieldsWithEDT
        #// 04.02.2021, mazzy, основано на методе this.fields()
        #public Set fieldsWithEDT(ExtendedTypeId edt)
        #{
        #    int cnt;
        #    int i;
        #    int j;
        #    tableId tableId = this.id();
        #    SysDictField sysDictField;
        #    SysDictField sysDictFieldArray;
        #    Set set = new Set(Types::Class);
        #
        #    if (!edt)
        #    {
        #        return set;
        #    }
        #
        #    //
        #    // Include fields
        #    //
        #    cnt = this.fieldCnt();
        #    for (i=1; i<=cnt; i++)
        #    {
        #        sysDictField = new SysDictField(tableId, this.fieldCnt2Id(i));
        #
        #        //
        #        // Skip fields not stored in the database
        #        // This is typical system fields, like ModifiedBy, CreatedBy, etc.
        #        //
        #        if (sysDictField && sysDictField.saveContents() && SysDictType::isEqualOrExtending(sysDictField.extendedTypeId(), edt))
        #        {
        #            for (j=1; j<=sysDictField.arraySize(); j++)
        #            {
        #                sysDictFieldArray = new SysDictField(tableId, this.fieldCnt2Id(i), j);
        #                set.add(sysDictFieldArray);
        #            }
        #        }
        #    }
        #    return set;
        #}
      ENDSOURCE
      SOURCE #fieldsWithEnum
        #// 04.02.2021, mazzy, основано на методе this.fields()
        #public Set fieldsWithEnum(EnumId enumId)
        #{
        #    int cnt;
        #    int i;
        #    int j;
        #    tableId tableId = this.id();
        #    SysDictField sysDictField;
        #    SysDictField sysDictFieldArray;
        #    Set set = new Set(Types::Class);
        #
        #    if (!enumId)
        #    {
        #        return set;
        #    }
        #
        #    //
        #    // Include fields
        #    //
        #    cnt = this.fieldCnt();
        #    for (i=1; i<=cnt; i++)
        #    {
        #        sysDictField = new SysDictField(tableId, this.fieldCnt2Id(i));
        #
        #        //
        #        // Skip fields not stored in the database
        #        // This is typical system fields, like ModifiedBy, CreatedBy, etc.
        #        //
        #        if (sysDictField && sysDictField.saveContents() && sysDictField.enumId() == enumId)
        #        {
        #            for (j=1; j<=sysDictField.arraySize(); j++)
        #            {
        #                sysDictFieldArray = new SysDictField(tableId, this.fieldCnt2Id(i), j);
        #                set.add(sysDictFieldArray);
        #            }
        #        }
        #    }
        #    return set;
        #}
      ENDSOURCE
      SOURCE #sysDictFieldGroup
        #// ava 31/08/2015 TSM02096
        #SysDictFieldGroup sysDictFieldGroup(str _fieldGroupName)
        #{
        #    int i;
        #    ;
        #
        #    for(i = 1; i <= this.fieldGroupCnt(); i++)
        #        if( this.fieldGroup(i) == _fieldGroupName )
        #            return new SysDictFieldGroup(this.id(), _fieldGroupName);
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    return strFmt('%1 [%2]', this.name(), this.id());
        #}
      ENDSOURCE
      SOURCE #as
        #public static Common as(Common rec, TableId tableOrMapId)
        #{
        #    if( SysDictTable::is(rec, tableOrMapId) )
        #        return rec;
        #
        #    return RecordUtil::commonRecord();
        #}
      ENDSOURCE
      SOURCE #construct
        #//TSUM001815 DYask 26.02.2018
        #public static SysDictTable construct(tableId _tableId)
        #{
        #    SysDictTable sysDictTable = new SysDictTable(_tableId);
        #
        #    return sysDictTable;
        #}
        #
      ENDSOURCE
      SOURCE #fieldEnumerator
        #//mazzy 30.01.2020
        #public static SetEnumerator fieldEnumerator(tableId tableId)
        #{
        #    SysDictTable    dt      = new SysDictTable(tableId);
        #    SetEnumerator   fe      = dt ? dt.fields().getEnumerator() : null;
        #
        #    return fe;
        #}
      ENDSOURCE
      SOURCE #fieldIdWithEDT
        #// находит id n-ого поля с указанным типом
        #// порядок полей может не совпадать с объявленным в AOT
        #public static FieldId fieldIdWithEDT(TableId tableId, ExtendedTypeId edt, int occurrence = 1)
        #{
        #    SysDictField df = SysDictTable::fieldWithEDT(tableId, edt, occurrence);
        #
        #    if( df )
        #    {
        #        return df.id();
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #fieldIdWithEnum
        #// находит id n-ого поля с указанным enum
        #// порядок полей может не совпадать с объявленным в AOT
        #public static FieldId fieldIdWithEnum(TableId tableId, EnumId enumId, int occurrence = 1)
        #{
        #    SysDictField df = SysDictTable::fieldWithEnum(tableId, enumId, occurrence);
        #
        #    if( df )
        #    {
        #        return df.id();
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #fieldNames
        #// mazzy 30.01.2020
        #// Внимание! наименования полей могут совпадать, поэтому set названий полей может быть меньше, чем полей в таблице
        #// используйте с осторожностью
        #public static Set fieldNames(tableId tableId, boolean includeSystem = false)
        #{
        #    Set             set     = new Set(Types::String);
        #    SetEnumerator   fe      = SysDictTable::fieldEnumerator(tableId);
        #    SysDictField    df;
        #;
        #    while( fe && fe.moveNext() )
        #    {
        #        df = fe.current();
        #
        #        if( df && (includeSystem || !df.isSystem()) )
        #        {
        #            set.add(df.name());
        #        }
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #fieldWithEDT
        #// находит n-ое поле с указанным типом
        #// порядок полей может не совпадать с объявленным в AOT
        #// используйте SysDictTable.fieldsWithEDT, чтобы найти все поля
        #public static SysDictField fieldWithEDT(TableId tableId, ExtendedTypeId edt, int occurrence = 1)
        #{
        #    SysDictTable    dt       = new SysDictTable(tableId);
        #    Set             fields   = dt ? dt.fieldsWithEDT(edt) : null;
        #    SetEnumerator   se       = fields ? fields.getEnumerator() : null;
        #    SysDictField    df;
        #
        #    while( se && se.moveNext() && occurrence > 0 )
        #    {
        #        df = se.current();
        #        occurrence--;
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #fieldWithEnum
        #// находит n-ое поле с указанным enum
        #// порядок полей может не совпадать с объявленным в AOT
        #// используйте SysDictTable.fieldsWithEDT, чтобы найти все поля
        #public static SysDictField fieldWithEnum(TableId tableId, EnumId enumId, int occurrence = 1)
        #{
        #    SysDictTable    dt       = tableId  ? new SysDictTable(tableId) : null;
        #    Set             fields   = dt       ? dt.fieldsWithEnum(enumId) : null;
        #    SetEnumerator   se       = fields   ? fields.getEnumerator() : null;
        #    SysDictField    df;
        #
        #    while( se && se.moveNext() && occurrence > 0 )
        #    {
        #        df = se.current();
        #        occurrence--;
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #formRefName
        #// mazzy 10.03.2021
        #public static MenuItemName formRefName(TableId tableId)
        #{
        #    DictTable dt = new DictTable(tableId);
        #
        #    if( dt )
        #    {
        #        return dt.formRef();
        #    }
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #getMandatoryFields
        #// mazzy, 07.04.2020
        #static client server List getMandatoryFields(tableId _tableId)
        #{
        #    List                    fieldIdList  = new List(Types::Integer);
        #    SysDictTable            sysDictTable = new SysDictTable(_tableId);
        #    SysDictField            sysDictField;
        #    int                     i;
        #    ;
        #
        #    for (i=1;i<=sysDictTable.fieldCnt();i++)
        #    {
        #        sysDictField = new SysDictField(_tableId, sysDictTable.fieldCnt2Id(i));
        #        if( sysDictField && sysDictField.saveContents() && sysDictField.mandatory() )
        #        {
        #            fieldIdList.addEnd(sysDictField.id());
        #        }
        #    }
        #
        #    return fieldIdList;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Common rec, TableId tableOrMapId)
        #{
        #    if( rec.TableId == tableOrMapId )
        #        return true;
        #
        #    if( tableOrMapId && SysDictTable::isTableMapped(tableOrMapId, rec.TableId) )
        #        return true;
        #
        #    return false;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ClassIdUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ClassIdUtil
    PROPERTIES
      Name                #ClassIdUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом ClassId
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ObjectUtil
        #// @see DictClassUtil
        #//
        #abstract class ClassIdUtil
        #{
        #}
      ENDSOURCE
      SOURCE #containsGetEnumeratorMethod
        #// TODO перенести в отдельый класс?
        #// для утиной типизации: есть метод getEnumerator,
        #// у которого нет параметров и который возвращает объект с типом Enumerator
        #private static boolean containsGetEnumeratorMethod(ClassId classId)
        #{
        #    SysDictMethod sdm = new SysDictMethod(UtilElementType::ClassInstanceMethod, classId, methodstr(Enumerable, getEnumerator));
        #
        #    if( sdm &&
        #        sdm.parameterCnt() == 0 &&
        #        sdm.returnType() == Types::Class &&
        #        ClassIdUtil::isImplement(sdm.returnId(), classnum(Enumerator)) )
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #dictClass_NonNull
        #// используйте <c>new DictClass(classId)<c> чтобы создать объект DictClass без проверки на null
        #//
        #public static DictClass dictClass_NonNull(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    ;
        #
        #    dc = DictClassUtil::nonNull(dc);
        #
        #    return dc;
        #}
      ENDSOURCE
      SOURCE #enumerableClasses
        #public static container enumerableClasses()
        #{
        #    return [
        #        classnum(List),
        #        classnum(Map),
        #        classnum(Set),
        #        classnum(Array),
        #        classnum(Enumerable)
        #    ];
        #}
      ENDSOURCE
      SOURCE #extendedBy
        #public static List extendedBy(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    List list;
        #
        #    if( dc )
        #    {
        #        list = dc.extendedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #implementedBy
        #// @warning медленный метод. перебирает все классы в AOT
        #public static List implementedBy(ClassId classId)
        #{
        #    SysDictClass dc = new SysDictClass(classId);
        #    List list;
        #
        #    if( dc )
        #    {
        #        list = dc.implementedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(ClassId classId, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    DictClass dictClass;
        #    int       n;
        #    ;
        #
        #    while( classId && potentialClassAncestorOrInterfaceId )
        #    {
        #        if( classId == potentialClassAncestorOrInterfaceId )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( n = dictClass.implementsCnt(); n > 0; --n )
        #            {
        #                if( dictClass.implements(n) == potentialClassAncestorOrInterfaceId )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для класса, для которого можно получить enumerator
        #public static boolean isEnumerable(ClassId classId)
        #{
        #    if( ClassIdUtil::isOneOf(classId, ClassIdUtil::enumerableClasses()) )
        #    {
        #        return true;
        #    }
        #
        #    if( ClassIdUtil::containsGetEnumeratorMethod(classId) )
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends, без implements
        #public static boolean isExtend(ClassId classId, ClassId potentialClassAncestorId)
        #{
        #    DictClass dictClass;
        #
        #    while( classId && potentialClassAncestorId )
        #    {
        #        if( classId == potentialClassAncestorId )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(ClassId classId, ClassId interfaceId)
        #{
        #    DictClass dictClass;
        #    int       n;
        #
        #    while( classId && interfaceId )
        #    {
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( n = dictClass.implementsCnt(); n > 0; --n )
        #            {
        #                if( dictClass.implements(n) == interfaceId )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(ClassId classId)
        #{
        #    boolean ret = (classId == 0 || classId == ClassIdUtil::objectClassId());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(ClassId classId, anytype potentialAncestorIds)
        #{
        #    Set         set = SetUtil::newFrom(potentialAncestorIds);
        #    DictClass   dictClass;
        #    int         i;
        #
        #    while( classId && set )
        #    {
        #        if( set.in(classId) )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( i = dictClass.implementsCnt(); i > 0; --i )
        #            {
        #                if( set.in(dictClass.implements(i)) )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(ClassId classId)
        #{
        #    boolean ret = (classId != 0 && classId != ClassIdUtil::objectClassId());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name2id
        #public static ClassId name2id(ClassName className)
        #{
        #    Dictionary dict = new Dictionary();
        #    ClassId classId;
        #
        #    if( dict )
        #    {
        #        classId = dict.className2Id(className);
        #    }
        #
        #    return classId;
        #}
      ENDSOURCE
      SOURCE #objectClassId
        #// возвращает код класса Object
        #public static ClassId objectClassId()
        #{
        #    // Object obj;
        #    //
        #    // return claggidget(obj);
        #
        #    return classnum(Object);
        #
        #    //return 65535;
        #}
      ENDSOURCE
      SOURCE #path
        #static TreeNodePath path(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    TreeNodePath ret = DictClassUtil::path(dc);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(ClassId classId)
        #{
        #    DictClass       dc  = new DictClass(classId);
        #    ListEnumerator  le  = DictClassUtil::subClassListEnumerator(dc);
        #
        #    return le;
        #}
      ENDSOURCE
      SOURCE #sysDictClass_NonNull
        #public static SysDictClass sysDictClass_NonNull(ClassId classId)
        #{
        #    SysDictClass dc = new SysDictClass(classId);
        #
        #    if( dc )
        #    {
        #        dc = new SysDictClass(classnum(Object));
        #    }
        #
        #    return dc;
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #private static void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
      SOURCE #treeNode
        #// возвращает null, если класс не найден
        #public static TreeNode treeNode(ClassId classId)
        #{
        #    TreeNodePath path = ClassIdUtil::path(classId);
        #    TreeNode treeNode;
        #
        #    if( path )
        #    {
        #        treeNode = TreeNode::findNode(path);
        #    }
        #
        #    return treeNode;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictClassUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictClassUtil
    PROPERTIES
      Name                #DictClassUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictClass
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ClassIdUtil
        #// @see ObjectUtil
        #//
        #abstract class DictClassUtil
        #{
        #}
      ENDSOURCE
      SOURCE #extendedBy
        #public static List extendedBy(DictClass dictClass)
        #{
        #    List list;
        #
        #    if( dictClass )
        #    {
        #        list = dictClass.extendedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #implementedBy
        #// @warning медленный метод. перебирает все классы в AOT
        #public static List implementedBy(DictClass dictClass)
        #{
        #    List list;
        #
        #    if( dictClass )
        #    {
        #        list = ClassIdUtil::implementedBy(dictClass.id());
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(DictClass dictClass, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::is(dictClass.id(), potentialClassAncestorOrInterfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для класса, для которого можно получить enumerator
        #public static boolean isEnumerable(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isEnumerable(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends
        #public static boolean isExtend(DictClass dictClass, ClassId potentialClassAncestorId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isExtend(dictClass.id(), potentialClassAncestorId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(DictClass dictClass, ClassId interfaceId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isImplement(dictClass.id(), interfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isNotSpecified(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(DictClass dictClass, anytype potentialAncestorIds)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isOneOf(dictClass.id(), potentialAncestorIds);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassIdUtil::isSpecified(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictClass nonNull(DictClass dictClass)
        #{
        #    if( !dictClass )
        #    {
        #        dictClass = new DictClass(classnum(Object));
        #    }
        #
        #    return dictClass;
        #}
      ENDSOURCE
      SOURCE #path
        #// взято из SysDictClass.path
        #public static TreeNodePath path(DictClass dictClass)
        #{
        #    TreeNodePath ret;
        #
        #    if( dictClass )
        #    {
        #        ret = xRefNames::calcPath(xRefKind::Class,dictClass.name(),'',dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(DictClass dictClass)
        #{
        #    List list = DictClassUtil::extendedBy(dictClass);
        #
        #    return ListUtil::getEnumerator(list);
        #}
      ENDSOURCE
      SOURCE #treeNode
        #// возвращает null, если класс не найден
        #public static TreeNode treeNode(DictClass dictClass)
        #{
        #    TreeNodePath path = DictClassUtil::path(dictClass);
        #    TreeNode treeNode = TreeNode::findNode(path);
        #
        #    return treeNode;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ObjectUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ObjectUtil
    PROPERTIES
      Name                #ObjectUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом Object (в том числе и с типом DictClass)
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ClassIdUtil
        #// @see DictClassUtil
        #//
        #abstract class ObjectUtil
        #{
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
      SOURCE #as
        #static public Object as(Object obj, classId potentialClassAncestorOrInterfaceId)
        #{
        #    if (ObjectUtil::is(obj, potentialClassAncestorOrInterfaceId))
        #    {
        #        return obj;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(Object obj, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassIdUtil::is(classId, potentialClassAncestorOrInterfaceId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для объекта, для которого можно получить enumerator
        #public static boolean isEnumerable(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassIdUtil::isEnumerable(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEqual
        #public static boolean isEqual(Object obj1, Object obj2)
        #{
        #    if( obj1 && obj2 )
        #    {
        #        return obj1.equal(obj2);
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends
        #public static boolean isExtend(Object obj, ClassId potentialClassAncestorId)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassIdUtil::isExtend(classId, potentialClassAncestorId);
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(Object obj, ClassId interfaceId)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassIdUtil::isImplement(classId, interfaceId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(Object obj, anytype potentialAncestorIds)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassIdUtil::isOneOf(classId, potentialAncestorIds);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    ListEnumerator ret = ClassIdUtil::subClassListEnumerator(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TableIdUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TableIdUtil
    PROPERTIES
      Name                #TableIdUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом TableId
        #
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see DictTableUtil
        #//
        #abstract class TableIdUtil
        #{
        #}
      ENDSOURCE
      SOURCE #commonTableId
        #public static TableId commonTableId()
        #{
        #    // Common rec;
        #    //
        #    // return rec.TableId;
        #
        #    return tablenum(Common);
        #
        #    // return 65535;
        #}
      ENDSOURCE
      SOURCE #dictTable_NonNull
        #// используйте new DictTable чтобы создать объект без проверки на null
        #public static DictTable dictTable_NonNull(TableId tableId)
        #{
        #    DictTable dt = new DictTable(tableId);
        #    ;
        #    dt = DictTableUtil::nonNull(dt);
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(TableId tableId)
        #{
        #    boolean ret = (tableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(TableId tableId)
        #{
        #    boolean ret = (tableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(TableId tableId)
        #{
        #    boolean ret = (tableId == 0 || tableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(TableId tableId)
        #{
        #    boolean ret = (tableId && tableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(TableId tableId = 0)
        #{
        #    Common record;
        #    DictTable dt;
        #
        #    if( tableId )
        #    {
        #        dt = new DictTable(tableId);
        #        if( dt )
        #        {
        #            record = dt.makeRecord();
        #        }
        #    }
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictTable nonNull(DictTable dt)
        #{
        #    if( !dt )
        #    {
        #        dt = new DictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #sysDictTable_NonNull
        #// используйте new SysDictTable чтобы создать объект без проверки на Null
        #public static SysDictTable sysDictTable_NonNull(TableId tableId)
        #{
        #    SysDictTable dt = new SysDictTable(tableId);
        #    ;
        #
        #    if( !dt )
        #    {
        #        dt = new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #sysNonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictTable sysNonNull(SysDictTable dt)
        #{
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictTableUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictTableUtil
    PROPERTIES
      Name                #DictTableUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictTable
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see TableIdUtil
        #//
        #abstract class DictTableUtil
        #{
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() == tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() != tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() == 0 || dt.id() == tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() != 0 && dt.id() != tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(DictTable dt)
        #{
        #    Common record;
        #    ;
        #
        #    if( dt )
        #    {
        #        record = dt.makeRecord();
        #    }
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictTable nonNull(DictTable dt)
        #{
        #    if( !dt )
        #    {
        #        dt = new DictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #sysNonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictTable sysNonNull(SysDictTable dt)
        #{
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordUtil
    PROPERTIES
      Name                #RecordUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает табличные буферы
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class RecordUtil
        #{
        #}
      ENDSOURCE
      SOURCE #cacheLookup
        #public static RecordCacheLevel cacheLookup(Common rec)
        #{
        #    RecordCacheLevel ret = RecordUtil::dictTable(rec).cacheLookup();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clone
        #public static Common clone(Common orig, RefTableId expectedTableId = 0)
        #{
        #    Common clone;
        #
        #    if( expectedTableId &&
        #        expectedTableId != orig.TableId &&
        #        expectedTableId != tablenum(Common) )
        #    {
        #        throw error(strFmt('%1: Не совпадают TableId. Ожидается %2, фактическое значение %3',
        #                        funcname(),
        #                        SysDictTable::construct(expectedTableId).toString(),
        #                        SysDictTable::construct(orig.TableId).toString()
        #        ));
        #    }
        #
        #    clone.data(orig);
        #
        #    return clone;
        #}
      ENDSOURCE
      SOURCE #commonRecord
        #public static Common commonRecord()
        #{
        #    Common rec;
        #
        #    return rec;
        #}
      ENDSOURCE
      SOURCE #DEL_commonTableId
        #public static TableId DEL_commonTableId()
        #{
        #    // Common rec;
        #    //
        #    // return rec.TableId;
        #
        #    return 65535;
        #}
      ENDSOURCE
      SOURCE #dictTable
        #// всегда возвращает not nullable объект. Полезно в выражениях
        #public static DictTable dictTable(Common rec)
        #{
        #    DictTable dt = new DictTable(rec.TableId);
        #
        #    if( !dt )
        #    {
        #        dt = new DictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #findFromUniqueIndexFields
        #// ищет по значениям из полей, которые входят в уникальный индекс
        #public static Common findFromUniqueIndexFields(Common rec)
        #{
        #    KeyData     keyData     = SysDictTable::getKeyData(rec).pack();
        #    Common      ret         = SysDictTable::findFromKeyData(rec.TableId, keyData);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findRef
        #// TODO refRecord
        #public static str findRef(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #findRefTitleField2
        #// TODO refTitleField2 - title field 2 from reference table
        #public static str findRefTitleField2(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #findReTitleField1
        #// TODO refTitleField2 - title field 1 from reference table
        #public static str findReTitleField1(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #getInfo
        #// mazzy, 18.12.2020
        #//
        #// возвращает строку, которая содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в информационных сообщениях
        #//
        #// пример использования:
        #// str s = SysDictTable::getInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// результат будет похож на: "RContractTable[CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]"
        #public static str getInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    str valueInfo = RecordUtil::getValuesInfo(rec, fieldIdCollection, uniqueCollection, mandatoryCollection);
        #    str ret = strFmt('%1[%2]', tableId2name(rec.TableId), valueInfo);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValue
        #public static anytype getValue(Common record, FieldId fieldid)
        #{
        #    // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    anytype value = record.(fieldid);
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #getValues
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValues(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static container getValues(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set         fields  = new Set(Types::Integer);
        #    container   ret;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        Enumerator e = collection ? EnumeratorUtil::getEnumerator(collection) : null;
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                ret += rec.(fieldId);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValuesInfo
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValuesInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static str getValuesInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set fields = new Set(Types::Integer);
        #    TextBuffer text;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        DictField df;
        #        str info;
        #        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                df = new DictField(rec.TableId, fieldId);
        #                info = strfmt("%1=%2", df.label(), rec.(df.id()));
        #
        #                text = TextBufferUtil::appendIfNotEmpty(text, ', ');
        #                text = TextBufferUtil::appendStr(text, info);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return TextBufferUtil::getText(text);
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public static boolean hasTableAccess(Common rec, AccessType neededAccessType)
        #{
        #    AccessType accessType = RecordUtil::dictTable(rec).rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(Common record)
        #{
        #    boolean ret = (record.TableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// возвращает true, если таблица не содержит ни одной записи
        #// возвращает false, если хотя бы одна запись есть.
        #//
        #// метод особенно полезен для временных таблиц
        #public static boolean isEmpty(Common record)
        #{
        #    Common buf = RecordUtil::makeRecord(record.TableId);
        #
        #    if( record.isTmp() )
        #    {
        #        buf.setTmp();
        #        buf.setTmpData(record);
        #    }
        #
        #    select firstOnly firstFast buf;
        #
        #    return (buf.RecId == 0);
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(Common record)
        #{
        #    boolean ret = (record.TableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// возвращает false, если таблица не содержит ни одной записи
        #// возвращает true, если хотя бы одна запись есть.
        #//
        #// метод особенно полезен для временных таблиц
        #public static boolean isNotEmpty(Common record)
        #{
        #    return !RecordUtil::isEmpty(record);
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(Common record)
        #{
        #    boolean ret = (record.TableId == 0 || record.TableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(Common record)
        #{
        #    boolean ret = (record.TableId != 0 && record.TableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(TableId tableId)
        #{
        #    Common record;
        #    DictTable dt;
        #
        #    if( tableId )
        #    {
        #        dt = new DictTable(tableId);
        #        if( dt )
        #        {
        #            record = dt.makeRecord();
        #        }
        #    }
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #makeRecordTmp
        #public static Common makeRecordTmp(TableId tableId)
        #{
        #    Common record = RecordUtil::makeRecord(tableId);
        #    ;
        #
        #    record.setTmp();
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #match
        #// проверяет есть ли вхожение паттерна в какое-нибудь поле
        #// проверку выполняет рекурсивно, если есть поля-контейнеры
        #public static boolean match(
        #    str         pattern,
        #    Common      record,
        #    boolean     includeSystemFields     = false)
        #{
        #    SysDictTable    sysDictTable    = new SysDictTable(record.TableId);
        #    Set             fields          = sysDictTable.fields();
        #    SetEnumerator   fe              = fields ? fields.getEnumerator() : null;
        #    SysDictField    field;
        #    Any             value;
        #;
        #    while( fe && fe.moveNext() )
        #    {
        #        field = fe.current();
        #        if( !includeSystemFields && field.isSystem() )
        #            continue;
        #
        #        switch( field.type() )
        #        {
        #            case Types::String:
        #            case Types::RString:
        #            case Types::VarString:
        #                value = Any::field(record, field.id());
        #                if( match(pattern, value.asString()) )
        #                    return true;
        #                break;
        #
        #            case Types::Container:
        #                value = Any::field(record, field.id());
        #                if( ConUtil::match(pattern, value.asContainer()) )
        #                    return true;
        #                break;
        #
        #            case Types::Record:
        #                value = Any::field(record, field.id());
        #                if( RecordUtil::match(pattern, value.asRecord()) )
        #                    return true;
        #                break;
        #
        #            default:
        #                break;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #setValue
        #public static anytype setValue(Common record, fieldId fieldid, anytype value)
        #{
        #    // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    record.(fieldid) = value;
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #sysDictTable
        #// всегда возвращает not nullable объект. Полезно в выражениях
        #public static SysDictTable sysDictTable(Common rec)
        #{
        #    SysDictTable dt = new SysDictTable(rec.TableId);
        #
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #titleField1
        #// TODO TitleField2
        #public static str titleField1(Common rec)
        #{
        #}
      ENDSOURCE
      SOURCE #titleField2
        #// TODO TitleField2
        #public static str titleField2(Common rec)
        #{
        #}
      ENDSOURCE
      SOURCE #tmpFilter
        #public static Common tmpFilter(Common buf, FieldId filterFieldId, AnyType filterValue)
        #{
        #    Common rec = RecordUtil::makeRecordTmp(buf.TableId);
        #
        #    Query       query = SysQuery::query(buf.TableId, filterFieldId, filterValue);
        #    QueryRun    queryRun = new QueryRun(query);
        #    ;
        #
        #    queryRun.setCursor(buf);
        #    while (queryRun.next())
        #    {
        #        rec = queryRun.get(buf.TableId);
        #        rec.insert();
        #    }
        #
        #    return rec;
        #}
        #
      ENDSOURCE
      SOURCE #tmpSelect
        #// buf - результат запроса select
        #public static Common tmpSelect(Common buf)
        #{
        #    Common rec = RecordUtil::makeRecordTmp(buf.TableId);
        #    ;
        #
        #    while( buf )
        #    {
        #        rec = buf.data(); //  clone, включая системные поля
        #        rec.insert();
        #    }
        #
        #    return rec;
        #}
        #
      ENDSOURCE
      SOURCE #validateAndDelete
        #public static boolean validateAndDelete(Common buf)
        #{
        #    if( !buf.validateDelete() )
        #    {
        #        return false;
        #    }
        #
        #    buf.delete();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public static Common validateAndDeleteOrThrow(Common buf)
        #{;
        #    RecordUtil::validateDeleteOrThrow(buf);
        #    buf.delete();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #public static boolean validateAndInsert(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.insert();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public static Common validateAndInsertOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.insert();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #public static boolean validateAndUpdate(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.update();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public static Common validateAndUpdateOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.update();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #public static boolean validateAndWrite(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.write();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public static Common validateAndWriteOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.write();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public static boolean validateDelete(Common buf)
        #{
        #    if( !buf.validateDelete() )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public static Common validateDeleteOrThrow(Common buf)
        #{
        #    if( !buf.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error for %1', RecordUtil::getInfo(buf)));
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public static boolean validateWrite(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public static Common validateWriteOrThrow(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error for %1', RecordUtil::getInfo(buf)));
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordList unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordList
    PROPERTIES
      Name                #RecordList
      Extends             #List
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addEnd
        #public anytype addEnd(anytype value)
        #{
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        buf = super(value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #addStart
        #public anytype addStart(anytype value)
        #{
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        buf = super(value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #appendEnumerator
        #// возвращает число добавленных элементов
        #public int appendEnumerator(Enumerator e, int maxElements = 0)
        #{
        #    int elements;
        #    Common buf;
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        buf = this.addEnd(e.current());
        #        elements += this.isAssignableBuf(buf);
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendList
        #// @override
        #public void appendList(List list)
        #{
        #    if( list &&
        #        confind([Types::Record, Types::Integer, Types::String, Types::RString, Types::VarString], list.typeId()) )
        #    {
        #        this.appendEnumerator(list.getEnumerator());
        #    }
        #}
      ENDSOURCE
      SOURCE #appendMarked
        #// добавляет все отмеченные на форме записи
        #// возвращает число добавленных элементов
        #public int appendMarked(FormDataSource fds, int maxElements = 0)
        #{
        #    int elements;
        #    common buf = fds ? fds.getFirst(1) : null;
        #
        #    while( fds && buf && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        buf = this.addEnd(buf);
        #        elements = this.isAssignableBuf(buf);
        #
        #        buf = fds.getNext();
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendQuery
        #// добавляет в список datasource из query, которые получат значения в выборке из базы
        #// Получится список неинициализированых буферов
        #// возвращает число добавленных элементов
        #public int appendQuery(Query q, int maxElements = 0)
        #{
        #    int elements;
        #    QueryBuildDataSource qbds;
        #    int qbdsId;
        #
        #    if( q )
        #    {
        #        qbdsId = q.nextUniqueId();
        #        while( qbdsId && (maxElements == 0 || elements <= maxElements) )
        #        {
        #            qbds = q.dataSourceUniqueId(qbdsId);
        #
        #            if (qbds &&
        #                qbds.table() &&
        #                qbds.enabled() &&
        #                confind([JoinMode::InnerJoin, JoinMode::OuterJoin], qbds.joinMode()))
        #            {
        #                elements += this.addEnd(qbds.table());
        #            }
        #
        #            qbdsId = q.nextUniqueId();
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendRecIdEnumerator
        #// добавляет табличные буфера с указанными RecId
        #// возвращает число добавленных элементов
        #public int appendRecIdEnumerator(TableId tableId, Enumerator e, boolean selectForUpdate = false, int maxElements = 0)
        #{
        #    int       elements;
        #    RecId     recId;
        #    common    buf;
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        recId = AnytypeUtil::asRecId(e.current());
        #        if( recId )
        #        {
        #            buf = RecordUtil::commonRecord(); // на случай, если в списке табличные буфера разного типа
        #            buf.selectForUpdate(selectForUpdate);
        #            select firstonly buf where buf.RecId == recId;
        #
        #            buf = this.addEnd(e.current());
        #            elements += this.isAssignableBuf(buf);
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendSelect
        #// добавляет все записи из табличного буфера, который был заполнен командой select
        #// возвращает число добавленных элементов
        #//
        #// пример:
        #//
        #// {
        #//     CustTable ct;
        #//     select ct where ct.Name like 'Micro*';
        #//     SysRecordList::fromList(ct);
        #// }
        #//
        #public int appendSelect(Common selectedBuf, int maxElements = 0)
        #{
        #    int elements;
        #    Common buf;
        #
        #    while( selectedBuf && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        buf = this.addEnd(selectedBuf);
        #        elements += this.isAssignableBuf(buf);
        #
        #        next selectedBuf;
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #assignable
        #public Common assignable(anytype value)
        #{
        #    Common buf = AnytypeUtil::toBuf(value);
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/StrUtil
        #//
        #// Класс RecordList содержит список записей из таблиц *разного типа* (в том числе могут быть типа Common)
        #// для записей всех типов вполне успешно срабатывают табличные методы initValue, validateWrite, write, insert, update и т.д.
        #// класс позволяет единообразно обслуживать записи из списка
        #//
        #// класс во многом похож на RecordLinkList. отличия:
        #// * работает предсказуемым образом
        #// * гарантировано держит все записи в памяти
        #// * позволяет создавать несколько энумераторов и делать вложенные циклы по одному списку
        #// * не вмешивается и не копирует записи, поэтому внутренние флаги и проперти в записи сохраняются.
        #//   это значит что:
        #//   * методы update получат правильный флаг forupdate
        #//   * оператор next будет правильно работать с записями, которые выбраны из списка
        #//   * запись из map останется записью из map
        #// * методы pack/unpack позволяют эффективно передавать значения между клиентом и сервером (внутренние флаги и проперти сбрасываются)
        #// * методы validateDelete и validateWrite сначала проверят все записи, лишь потом выполнят действия для всех записей
        #// * реализованы методы merge и appendList и другие методы базового класса List
        #//
        #// по сравнению с RecordLinkList этот класс не позволяет:
        #// * получить доступ к записи по индексу (см. второй параметр в RecordLinkList.get)
        #// * перейти к предыдущей записи в цикле (см. метод RecordLinkList.prev)
        #// * удалять элементы из списка
        #//
        #// TODO добавить выборку табличных буферов из QueryRun
        #class RecordList extends List
        #{
        #    Set tableIds;
        #}
      ENDSOURCE
      SOURCE #deleteDatabase
        #// выполняет удаление без валиадции.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordList deleteDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        buf.delete();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public boolean hasTableAccess(AccessType neededAccessType)
        #{
        #    AccessType accessType = this.rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #initValue
        #// выполняет initValue для буферов с пустым recId.
        #public void initValue()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( !buf.RecId )
        #        {
        #            buf.initValue();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// выполняет вставку без валиадции для буферов с пустым recId.
        #// Может, стоит использовать метод validateAndInsert?
        #public RecordList insertDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( !buf.RecId )
        #        {
        #            buf.insert();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #isAssignableBuf
        #public boolean isAssignableBuf(Common buf)
        #{
        #    boolean ret = buf.TableId && !RecordUtil::isCommon(buf);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Types _type = Types::Record)
        #{
        #    anytype contract = Debug::assert(_type == Types::Record);
        #
        #    super(Types::Record);
        #}
      ENDSOURCE
      SOURCE #rights
        #// возвращает минимальный уровень доступа
        #// пустой список записей имеет максимальный уровень доступа
        #public AccessType rights()
        #{
        #    AccessType ret = AccessType::Delete;
        #    AccessType rights;
        #
        #    SetEnumerator se = this.tableIds().getEnumerator();
        #    TableId tableId;
        #
        #    while( se && se.moveNext() )
        #    {
        #        tableId = se.current();
        #        rights = new DictTable(tableId).rights(); // так мы получаем права с учетом свойства таблицы maxAccessMode
        #        ret = min(ret, rights);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #selectForUpdate
        #// устанавливает режим выборки для всех табличных буферов в true, если selectForUpdate == true
        #// не изменяет флаг у табличных буферов, если selectForUpdate == false
        #public void selectForUpdate(boolean selectForUpdate = false)
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( selectForUpdate && le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        buf.selectForUpdate(selectForUpdate);
        #    }
        #}
      ENDSOURCE
      SOURCE #setTmp
        #public void setTmp()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        buf.setTmp();
        #    }
        #}
      ENDSOURCE
      SOURCE #tableIds
        #public Set tableIds()
        #{
        #    if( !tableIds )
        #        tableIds = new Set(Types::Integer);
        #
        #    return tableIds;
        #}
      ENDSOURCE
      SOURCE #updateDatabase
        #// выполняет обновление без валиадции для буферов с заполненным recId.
        #// Может, стоит использовать метод validateAndupdate?
        #public RecordList updateDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( buf.RecId )
        #        {
        #            buf.update();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndDelete
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, удаляет
        #public boolean validateAndDelete()
        #{
        #    boolean valid = this.validateDelete();
        #
        #    if( valid )
        #    {
        #        this.deleteDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public RecordList validateAndDeleteOrThrow()
        #{
        #    this.validateDeleteOrThrow();
        #    this.deleteDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #// выполняет валидацию всех еще не вставленных записей (recId == 0),
        #// а затем, если валидация успешна, вставку еще не вставленных записей
        #public boolean validateAndInsert()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.insertDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public RecordList validateAndInsertOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.insertDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #// выполняет валидацию всех уже вставленных записей (recId != 0),
        #// а затем, если валидация успешна, update уже вставленных записей
        #public boolean validateAndUpdate()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.updateDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public RecordList validateAndUpdateOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, запись всех буферов (Аксапта сама разбирается нужно вставить или обновить буфер)
        #public boolean validateAndWrite()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.writeDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public RecordList validateAndWriteOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public boolean validateDelete()
        #{
        #    boolean valid = true;
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        valid = buf.validateDelete();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public RecordList validateDeleteOrThrow()
        #{
        #    if( !this.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error in %1', funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public boolean validateWrite()
        #{
        #    boolean valid = true;
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        valid = buf.validateWrite();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public RecordList validateWriteOrThrow()
        #{
        #    if( !this.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error in %1', funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #writeDatabase
        #// выполняет запись без валиадции всех буферов.
        #// Может, стоит использовать метод validateAndWrite?
        #public RecordList writeDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common rec;
        #
        #    while( le && le.moveNext() )
        #    {
        #        rec = le.current(); // строка для отладчика
        #        rec.write();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordList construct()
        #{
        #    RecordList recordList = new RecordList(Types::Record);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf
        #// табличные буфера как параметры, чтобы не потерять внутренние флаги
        #// такие как SelectForUpdate, formDataSource, был сделан select, isTmp
        #public static RecordList fromBuf(
        #    Common buf1 = null,
        #    Common buf2 = null,
        #    Common buf3 = null,
        #    Common buf4 = null,
        #    Common buf5 = null,
        #    Common buf6 = null,
        #    Common buf7 = null,
        #    Common buf8 = null,
        #    Common buf9 = null,
        #    Common buf10 = null,
        #    Common buf11 = null,
        #    Common buf12 = null)
        #{
        #    RecordList recordList = RecordList::construct();
        #
        #    if( !prmisdefault(buf1) ) recordList.addEnd(buf1);
        #    if( !prmisdefault(buf2) ) recordList.addEnd(buf2);
        #    if( !prmisdefault(buf3) ) recordList.addEnd(buf3);
        #    if( !prmisdefault(buf4) ) recordList.addEnd(buf4);
        #    if( !prmisdefault(buf5) ) recordList.addEnd(buf5);
        #    if( !prmisdefault(buf6) ) recordList.addEnd(buf6);
        #    if( !prmisdefault(buf7) ) recordList.addEnd(buf7);
        #    if( !prmisdefault(buf8) ) recordList.addEnd(buf8);
        #    if( !prmisdefault(buf9) ) recordList.addEnd(buf9);
        #    if( !prmisdefault(buf10) ) recordList.addEnd(buf10);
        #    if( !prmisdefault(buf11) ) recordList.addEnd(buf11);
        #    if( !prmisdefault(buf12) ) recordList.addEnd(buf12);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf1
        #public static RecordList fromBuf1(Common buf)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf2
        #public static RecordList fromBuf2(Common buf1, Common buf2)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf3
        #public static RecordList fromBuf3(Common buf1, Common buf2, Common buf3)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf4
        #public static RecordList fromBuf4(Common buf1, Common buf2, Common buf3, Common buf4)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf5
        #public static RecordList fromBuf5(Common buf1, Common buf2, Common buf3, Common buf4, Common buf5)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #    recordList.addEnd(buf5);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf6
        #public static RecordList fromBuf6(Common buf1, Common buf2, Common buf3, Common buf4, Common buf5, Common buf6)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #    recordList.addEnd(buf5);
        #    recordList.addEnd(buf6);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBufCon
        #// табличные буфера в контейнере потеряют внутренние флаги
        #// такие как SelectForUpdate, formDataSource, был сделан select, isTmp
        #public static RecordList fromBufCon(container records, TableId tableId = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    Common buf;
        #    int len = conlen(records);
        #    int i;
        #
        #    for (i=1; i<=len; i++)
        #    {
        #        buf = ConUtil::peekAsRecord(records, i, tableId);
        #        if( tableId == 0 || RecordUtil::isNotCommon(buf) )
        #        {
        #            recordList.addEnd(buf);
        #        }
        #    }
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromCon
        #public static RecordList fromCon(container tableIds_tableNames_records)
        #{
        #    RecordList recordList = RecordList::construct();
        #    int len = conlen(tableIds_tableNames_records);
        #    int i;
        #
        #    for (i=1; i<=len; i++)
        #    {
        #        recordList.addEnd(conpeek(tableIds_tableNames_records, i));
        #    }
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromEnumerator
        #public static RecordList fromEnumerator(Enumerator e, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendEnumerator(e, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromList
        #// возвращает объект, содержащий клон списка
        #// внимание: объекты (элементы списка) являются общими для старого и нового списка, а сами списки - разные
        #public static RecordList fromList(List list)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendList(list);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromMarked
        #// добавляет все отмеченные на форме записи
        #// возвращает число добавленных элементов
        #public static RecordList fromMarked(FormDataSource fds, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendMarked(fds, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromQuery
        #// добавляет в список те datasource из query, которые получат значения в выборке из базы
        #public static RecordList fromQuery(Query q, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendQuery(q, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromSelect
        #// добавляет все записи из буфера, который был заполнен командой select
        #//
        #// пример:
        #//
        #// {
        #//     ...
        #//     select custVendTable where custVendTable.Name like 'Micro*';
        #//     recordList = SysRecordList::fromSelect(custVendTable);
        #//     rle = recordList.getEnumerator()
        #//
        #//     while( rle && rle.moveNext() )
        #//     {
        #//        rle.current(); // возвращает табличный буфер
        #//     }
        #// }
        #//
        #public static RecordList fromSelect(Common rec, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendSelect(rec, maxElements);
        #
        #    return recordList;
        #}
        #
        #
        #
      ENDSOURCE
      SOURCE #fromTableId
        #public static RecordList fromTableId(TableId tableId)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(tableId);
        #
        #    return recordList;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordMap unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordMap
    PROPERTIES
      Name                #RecordMap
      Extends             #Map
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #assignable
        #public Common assignable(anytype value)
        #{
        #    Common buf = AnytypeUtil::toBuf(value);
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс содержит map записей из таблиц *разного типа* (в том числе могут быть типа Common)
        #// для записей всех типов вполне успешно срабатывают табличные методы initValue, validateWrite, write, insert, update и т.д.
        #// класс позволяет единообразно обслуживать записи из списка
        #//
        #class RecordMap extends Map
        #{
        #    Set tableIds;
        #}
      ENDSOURCE
      SOURCE #deleteDatabase
        #// выполняет удаление без валиадции.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap deleteDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        buf.delete();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public boolean hasTableAccess(AccessType neededAccessType)
        #{
        #    AccessType accessType = this.rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #initValue
        #// выполняет initValue для буферов с пустым recId.
        #public void initValue()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.current();
        #        if( !buf.RecId )
        #        {
        #            buf.initValue();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #insert
        #public boolean insert(anytype key, anytype value)
        #{
        #    boolean ret;
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        ret = super(key, value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// выполняет вставку без валиадции для буферов с пустым recId.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap insertDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.current();
        #        if( !buf.RecId )
        #        {
        #            buf.insert();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #isAssignableBuf
        #public boolean isAssignableBuf(Common buf)
        #{
        #    boolean ret = buf.TableId && !RecordUtil::isCommon(buf);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Types _keyType, Types _valueType = Types::Record)
        #{
        #    anytype contract = Debug::assert(_valueType == Types::Record);
        #
        #    super(_keyType, Types::Record);
        #}
      ENDSOURCE
      SOURCE #rights
        #// возвращает минимальный уровень доступа
        #// пустой список записей имеет максимальный уровень доступа
        #public AccessType rights()
        #{
        #    AccessType ret = AccessType::Delete;
        #    AccessType rights;
        #
        #    SetEnumerator se = this.tableIds().getEnumerator();
        #    TableId tableId;
        #
        #    while( se && se.moveNext() )
        #    {
        #        tableId = se.current();
        #        rights = new DictTable(tableId).rights(); // так мы получаем права с учетом свойства таблицы maxAccessMode
        #        ret = min(ret, rights);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #selectForUpdate
        #// устанавливает режим выборки для всех табличных буферов в true, если selectForUpdate == true
        #// не изменяет флаг у табличных буферов, если selectForUpdate == false
        #public void selectForUpdate(boolean selectForUpdate = false)
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( selectForUpdate && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();
        #        buf.selectForUpdate(selectForUpdate);
        #    }
        #}
      ENDSOURCE
      SOURCE #setTmp
        #public void setTmp()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        buf.setTmp();
        #    }
        #}
      ENDSOURCE
      SOURCE #tableIds
        #public Set tableIds()
        #{
        #    if( !tableIds )
        #        tableIds = new Set(Types::Integer);
        #
        #    return tableIds;
        #}
      ENDSOURCE
      SOURCE #updateDatabase
        #// выполняет обновление без валиадции для буферов с заполненным recId.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap updateDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();
        #        if( buf.RecId )
        #        {
        #            buf.update();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndDelete
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, удаляет
        #public boolean validateAndDelete()
        #{
        #    boolean valid = this.validateDelete();
        #
        #    if( valid )
        #    {
        #        this.deleteDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public void validateAndDeleteOrThrow()
        #{
        #    this.validateDeleteOrThrow();
        #    this.deleteDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #// выполняет валидацию всех еще не вставленных записей (recId == 0),
        #// а затем, если валидация успешна, вставку еще не вставленных записей
        #public boolean validateAndInsert()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.insertDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public void validateAndInsertOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.insertDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #// выполняет валидацию всех уже вставленных записей (recId != 0),
        #// а затем, если валидация успешна, update уже вставленных записей
        #public boolean validateAndUpdate()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.updateDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public void validateAndUpdateOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, запись всех буферов (Аксапта сама разбирается нужно вставить или обновить буфер)
        #public boolean validateAndWrite()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.writeDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public void validateAndWriteOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public boolean validateDelete()
        #{
        #    boolean valid = true;
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        valid = buf.validateDelete();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public void validateDeleteOrThrow()
        #{
        #    if( !this.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error in %1', funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public boolean validateWrite()
        #{
        #    boolean valid = true;
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        valid = buf.validateWrite();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public void validateWriteOrThrow()
        #{
        #    if( !this.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error in %1', funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #writeDatabase
        #// выполняет запись без валиадции всех буферов.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap writeDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue(); // строка для отладчика
        #        buf.writeDatabase();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordMap construct(Types keyType)
        #{
        #    RecordMap recordMap = new RecordMap(keyType, Types::Record);
        #
        #    return recordMap;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysRecordInsertList unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysRecordInsertList
    PROPERTIES
      Name                #SysRecordInsertList
      Extends             #RecordInsertList
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #add
        #// добавляет запись к набору RecordInsertList
        #// перед добавлением выполняет validateVrite, если это не запрещено параметрами класса
        #public int add(Common record)
        #{
        #    int ret;
        #
        #    if (this.skipValidateWrite() || record.validateWrite())
        #    {
        #        ret = super(record);    // внимание! на клиенте всегда возвращает 0
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysRecordInsertList extends RecordInsertlist
        #{
        #    boolean skipValidateWrite;
        #
        #    int elements;
        #    int lastInserted;
        #}
      ENDSOURCE
      SOURCE #elements
        #// всего элементов было добавлено в этот список
        #public int elements()
        #{
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// возвращает число записей, которые были вставлены в базу данной командой
        #public int insertDatabase()
        #{
        #    int ret;
        #
        #    if( elements )
        #    {
        #        ret = super();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #skipValidateWrite
        #public boolean skipValidateWrite(boolean _skipValidateWrite = skipValidateWrite)
        #{
        #    skipValidateWrite = _skipValidateWrite;
        #    return skipValidateWrite;
        #}
      ENDSOURCE
      SOURCE #construct
        #// создает объект на сервере
        #// используйте new(), если вы хотите вручную управлять местом создания объекта
        #public server static SysRecordInsertList construct(
        #    TableId     tableId,
        #    boolean     skipInsertMethod    = false,
        #    boolean     skipDatabaseLog     = false,
        #    boolean     skipEvents          = false,
        #    boolean     skipAosValidation   = false,
        #    boolean     skipRLSValidation   = false,
        #    boolean     skipValidateWrite   = false)
        #{
        #    SysRecordInsertList ril = new SysRecordInsertList(
        #                                    tableId,
        #                                    skipInsertMethod,
        #                                    skipDatabaseLog,
        #                                    skipEvents,
        #                                    skipAosValidation,
        #                                    skipRLSValidation);
        #    ;
        #
        #    ril.skipValidateWrite(skipValidateWrite);
        #
        #    return ril;
        #}
      ENDSOURCE
      SOURCE #fromRecord
        #// создает объект на сервере
        #// используйте new(), если вы хотите вручную управлять местом создания объекта
        #public server static SysRecordInsertList fromRecord(
        #    Common      record,
        #    boolean     skipValidateWrite   = false,
        #    boolean     skipRLSValidation   = record.recordLevelSecurity())
        #{
        #    SysRecordInsertList     ril     = SysRecordInsertList::construct(
        #                                            record.tableId,
        #                                            record.skipDataMethods(),
        #                                            record.skipDatabaseLog(),
        #                                            record.skipEvents(),
        #                                            record.skipAosValidation(),
        #                                            skipRLSValidation);
        #    ;
        #
        #    ril.skipValidateWrite(skipValidateWrite);
        #
        #    return ril;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: FieldIdUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #FieldIdUtil
    PROPERTIES
      Name                #FieldIdUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом FieldId
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see DictFieldUtil
        #//
        #abstract class FieldIdUtil
        #{
        #}
      ENDSOURCE
      SOURCE #baseType
        #public static Types baseType(TableId tableId, FieldId fieldId)
        #{
        #    DictField df = FieldIdUtil::dictField(tableId, fieldId);
        #    Types type = TypeUtil::undefined();
        #
        #    if( df )
        #    {
        #        type = df.baseType();
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #dictField
        #public static DictField dictField(TableId tableId, FieldId fieldId)
        #{
        #    DictField df;
        #
        #    if( tableId && fieldId )
        #    {
        #        df = new DictField(tableId, fieldId);
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #dictField_NonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictField dictField_NonNull(TableId tableId, FieldId id)
        #{
        #    DictField df = FieldIdUtil::dictField(tableId, id);
        #    ;
        #
        #    df = DictFieldUtil::nonNull(df);
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictField nonNull(DictField df)
        #{
        #    if( !df )
        #    {
        #        df = new DictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #RecId
        #public static FieldId recId()
        #{
        #    return fieldnum(Common, RecId);
        #}
      ENDSOURCE
      SOURCE #sysDictField
        #public static SysDictField sysDictField(TableId tableId, FieldId fieldId, int arrayIndex = 0)
        #{
        #    SysDictField df;
        #
        #    if( tableId && fieldId )
        #    {
        #        df = new SysDictField(tableId, fieldId, arrayIndex);
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #sysDictField_NonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictField sysDictField_NonNull(TableId tableId, FieldId id, int arrayIndex = 0)
        #{
        #    SysDictField df = FieldIdUtil::sysDictField(tableId, id, arrayIndex);
        #    ;
        #
        #    if( !df )
        #    {
        #        df = new SysDictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #sysNonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictField sysNonNull(SysDictField df)
        #{
        #    if( !df )
        #    {
        #        df = new SysDictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #TableId
        #public static FieldId tableId()
        #{
        #    return fieldnum(Common, TableId);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictFieldUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictFieldUtil
    PROPERTIES
      Name                #DictFieldUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictField
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see FieldIdUtil
        #//
        #abstract class DictFieldUtil
        #{
        #}
      ENDSOURCE
      SOURCE #baseType
        #public static Types baseType(DictField df)
        #{
        #    Types type = TypeUtil::undefined();
        #
        #    if( df )
        #    {
        #        type = df.baseType();
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictField nonNull(DictField df)
        #{
        #    if( !df )
        #    {
        #        df = new DictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArgsUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArgsUtil
    PROPERTIES
      Name                #ArgsUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты типа Args
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ArgsUtil
        #{
        #}
      ENDSOURCE
      SOURCE #assertCallerFormName
        #public static void assertCallerFormName(Args args, FormName formName, str _funcname = '')
        #{
        #    if( ArgsUtil::callerFormName(args) == formName)
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertCallerType
        #public static void assertCallerType(Args args, classId potentialAncestorClassId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkCallerType(args, potentialAncestorClassId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnum
        #public static void assertEnum(Args args, Anytype enum, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkEnum(args, enum) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnumType
        #public static void assertEnumType(Args args, EnumId enumId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkEnumType(args, enumId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertFormDatasource
        #public static void assertFormDatasource(Args args, str _funcname = '')
        #{
        #    if (args && args.dataset() && args.record().isFormDataSource())
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertParm
        #public static void assertParm(Args args, str matchPattern = '.', str _funcname = '')
        #{
        #    if ( ArgsUtil::checkParm(args, matchPattern) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecord
        #public static void assertRecord(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecordExists
        #public static void assertRecordExists(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecordExists(args, tableId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecordTableIds
        #public static void assertRecordTableIds(Args args, container tableIds, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecordTableIds(args, tableIds) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #caller
        #public static Object caller(Args args, classId potentialAncestorClassId)
        #{
        #    Object ret;
        #
        #    if( args )
        #    {
        #        ret = SysDictClass::as(args.caller(), potentialAncestorClassId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #callerFormName
        #public static str callerFormName(Args args)
        #{
        #    FormRun formRun = ArgsUtil::caller(args, classnum(FormRun));
        #    str formName;
        #
        #    if( formRun )
        #    {
        #        formName = formRun.form().name();
        #    }
        #
        #    return formName;
        #}
      ENDSOURCE
      SOURCE #checkCallerType
        #public static boolean checkCallerType(Args args, classId potentialAncestorClassId)
        #{
        #    boolean checkOk = args && SysDictClass::is(args.caller(), potentialAncestorClassId);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkEnum
        #public static boolean checkEnum(Args args, Anytype enum)
        #{
        #    boolean checkOk;
        #
        #    if( args && typeof(enum) == types::Enum )
        #    {
        #        checkOk = (enum == args.parmEnum());
        #    }
        #
        #    return checkOk;
        #}
        #
      ENDSOURCE
      SOURCE #checkEnumType
        #public static boolean checkEnumType(Args args, EnumId enumId)
        #{
        #    boolean checkOk = (args && args.parmEnumType() == enumId);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkParm
        #// параметр parm содержит паттерн.
        #// возвращает true, если parm-строка соответствует regexp-выражению в matchPattern (метод использует функцию match для проверки)
        #// если не указать matchPattern, то возвращает true, если parm не пустой (содержит хотя бы один символ)
        #// возвращает true, если matchPattern является пустой строкой
        #public static boolean checkParm(Args args, str matchPattern = '.')
        #{
        #    boolean checkOk = (args && match(matchPattern, args.parm()));
        #
        #    return checkOk;
        #}
        #
      ENDSOURCE
      SOURCE #checkRecord
        #// запись из указанной таблицы (или любой таблицы для tableId = 0)
        #public static boolean checkRecord(Args args, TableId tableId = 0)
        #{
        #    boolean ret = false;
        #    int dataset;
        #
        #    if( args )
        #    {
        #        dataset = args.dataset();
        #
        #        if( dataset )
        #        {
        #            ret = (dataset == tableId || TableIdUtil::isNotSpecified(tableId));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkRecordExists
        #// запись существует (recId != 0) и запись из указанной таблицы (или любой таблицы для tableId = 0)
        #public static boolean checkRecordExists(Args args, TableId tableId = 0)
        #{
        #    boolean checkOk = (ArgsUtil::checkRecord(args, tableId) && args.record() && args.record().RecId != 0);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkRecordTableIds
        #// возвращает true, если:
        #// * коллекция содержит tableId, совпадающий с tableId таблицы
        #// * коллекция содержит 0 или CommonTableId
        #// * коллекция пустая и записи в args не переданы
        #// возвращает false в остальных случаях
        #
        #// коллекция - это одно значение, container, Set, List, Array
        #public static boolean checkRecordTableIds(Args args, anytype tableIdCollection)
        #{
        #    TableId dataset = ArgsUtil::dataset(args);
        #    Enumerator e;
        #
        #    if( dataset == 0 && CollectionUtil::empty(tableIdCollection) )
        #    {
        #        return true;
        #    }
        #
        #    e = AnytypeUtil::getEnumerator(tableIdCollection);
        #
        #    while( dataset && e && e.moveNext() )
        #    {
        #        if( confind([dataset, 0], e.current()) )
        #        {
        #            return true;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #copyArgs
        #public static Args copyArgs(Args fromArgs, Args toArgs = null)
        #{
        #    if (fromArgs)
        #    {
        #        if (!toArgs)
        #        {
        #            toArgs = new Args();
        #        }
        #
        #        SysArgs::copyArgs(fromArgs, toArgs);
        #    }
        #
        #    return toArgs;
        #}
        #
      ENDSOURCE
      SOURCE #dataset
        #public static TableId dataset(Args args)
        #{
        #    TableId dataset = 0;
        #
        #    if( args )
        #    {
        #        dataset = args.dataset();
        #    }
        #
        #    return dataset;
        #}
      ENDSOURCE
      SOURCE #enum
        #// убедиться что в аргументах enum указанного типа и
        #// вернуть значение этого enum из аргументов
        #// бросает исключение, если enum не указанного типа
        #public static int enum(Args args, EnumId enumId, str _funcname = '')
        #{;
        #    ArgsUtil::assertEnumType(args, enumId, _funcname);
        #
        #    return args.parmEnum();
        #}
      ENDSOURCE
      SOURCE #enumOrDefault
        #// тоже самое, что и ArgsUtil::getEnum()
        #// но если в аргументах не нужный enum не выдает ошибку, а возвращает дефолтное значение.
        #public static int enumOrDefault(Args args, anytype defaultEnumValue)
        #{
        #    if( typeof(defaultEnumValue) == Types::Enum )
        #    {
        #        if( ArgsUtil::checkEnumType(args, AnytypeUtil::enumId(defaultEnumValue)) )
        #        {
        #            return args.parmEnum();
        #        }
        #
        #        return defaultEnumValue;
        #    }
        #
        #    throw error::wrongUseOfFunction(funcname());
        #}
      ENDSOURCE
      SOURCE #markedList
        #public static container markedList(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    List            ret = new List(Types::Int64);
        #    FormDataSource  fds;
        #    common          record;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        fds = args.record().dataSource();
        #        if( fds && fds.anyMarked() )
        #        {
        #            // marked records
        #            for( record = fds.getFirst(true) ; record ; record = fds.getNext() )
        #            {
        #                ret.addEnd(record.RecId);
        #            }
        #        }
        #
        #        if( ret.elements() == 0 )
        #        {
        #            // or a record itself
        #            record = ArgsUtil::record(args, tableId, _funcname);
        #            ret.addEnd(record.RecId);
        #        }
        #    }
        #
        #    return ret.pack();
        #}
      ENDSOURCE
      SOURCE #markedRecIds
        #public static container markedRecIds(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    container       ret;
        #    FormDataSource  fds;
        #    common          record;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        fds = args.record().dataSource();
        #        if( fds && fds.anyMarked() )
        #        {
        #            // marked records
        #            for( record = fds.getFirst(true) ; record ; record = fds.getNext() )
        #            {
        #                ret += record.RecId;
        #            }
        #        }
        #
        #        if( !ret )
        #        {
        #            // or a record itself
        #            record = ArgsUtil::record(args, tableId, _funcname);
        #            ret = [record.RecId];
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedSet
        #// возвращает set со значениями в указанном поле в промаркированных на форме записях
        #// если args не содержит записей или содержит записи "не того" типа, то null
        #// если на форме нет промарктированных записей, то вернет set из одной записи (из args.record)
        #// если опустить параметр _field, то возвратит значения recId
        #public static Set markedSet(Args args, DictField _field = null)
        #{
        #    Set             ret;
        #    DictField       field  = DictFieldUtil::nonNull(_field);
        #    Common          record = ArgsUtil::recordAs(args, field.tableid());
        #    FormDataSource  fds;
        #    Common          marked;
        #
        #    if( RecordUtil::isNotCommon(record) )
        #    {
        #        fds = record.dataSource();
        #        if( fds && fds.anyMarked() )
        #        {
        #            // marked records
        #            for( marked = fds.getFirst(true) ; marked ; marked = fds.getNext() )
        #            {
        #                ret = SetUtil::addFieldValue(ret, marked, field.id());
        #            }
        #        }
        #
        #        if( !ret )
        #        {
        #            // or a record itself
        #            ret = SetUtil::addFieldValue(ret, record, field.id());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedSets
        #// возвращает map(key=fieldId, value=set), содержащий set со значениями в указанном поле в промаркированных на форме записях
        #// если args не содержит записей или содержит записи "не того" типа, то вернет пустой map
        #// если опустить параметр _field, то возвратит значения одного поля - recId
        #// если на форме нет промарктированных записей, то вернет набор из одной записи (из args.record)
        #public static Map markedSets(Args args, TableId tableId, anytype fieldIdContainer)
        #{
        #    Map         ret = new Map(Types::Integer, Types::Class); // {FieldId, Set(FieldValue)}
        #    Enumerator  e;
        #    DictField   field;
        #    Set         set;
        #
        #    if( ArgsUtil::checkRecord(args, tableid) )
        #    {
        #        // можно переделать, чтобы вместо вложенных циклов был один цикл
        #        e = AnytypeUtil::getEnumerator(fieldIdContainer);
        #        while( tableId && e && e.moveNext() )
        #        {
        #            field = FieldIdUtil::dictField_NonNull(tableId, e.current());
        #            set = ArgsUtil::markedSet(args, field);
        #            ret.insert(field.id(), set);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #record
        #public static Common record(Args args, TableId tableId = 0, str _funcname = '')
        #{;
        #    ArgsUtil::assertRecord(args, tableId, _funcname);
        #
        #    return args.record();
        #}
      ENDSOURCE
      SOURCE #recordAs
        #public static Common recordAs(Args args, TableId tableId = 0)
        #{
        #    Common ret;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        ret = args.record();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArgsUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArgsUtilTest
    PROPERTIES
      Name                #ArgsUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #
        #// not yet implemented
        #// - the test testAssertFormDatasource() when a record.isFormDataSource()
        #// - tests for ArgsUtil::getMarkedRecIds()
        #class ArgsUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName
        #void testAssertCallerFormName()
        #{
        #    Args        args            = new Args();
        #
        #    str         formName        = formstr(SysUserInfo);
        #    Args        formRunArgs     = new Args(formName);
        #    FormRun     formRun         = classFactory.formRunClass(formRunArgs);
        #;
        #    args.caller(formRun);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_Empty
        #void testAssertCallerFormName_Empty()
        #{
        #    Args    args        = new Args();
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_NotForm
        #void testAssertCallerFormName_NotForm()
        #{
        #    Args    args        = new Args();
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_NotMatch
        #void testAssertCallerFormName_NotMatch()
        #{
        #    Args        args            = new Args();
        #
        #    str         formName        = formstr(SysUserInfo);
        #    Args        formRunArgs     = new Args(formName);
        #    FormRun     formRun         = classFactory.formRunClass(formRunArgs);
        #;
        #    args.caller(formRun);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formstr(SysUserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_Null
        #void testAssertCallerFormName_Null()
        #{
        #    Args    args;
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType
        #void testAssertCallerType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Ancestor
        #void testAssertCallerType_Ancestor()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classnum(SysTestAssert));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Empty
        #void testAssertCallerType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Interface
        #void testAssertCallerType_Interface()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classnum(SysTestable));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_NotMatch
        #void testAssertCallerType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classnum(FormRun));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Null
        #void testAssertCallerType_Null()
        #{
        #    Args    args;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType
        #void testAssertEnumType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_Empty
        #void testAssertEnumType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_NotMatch
        #void testAssertEnumType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(LedgerTransType));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_Null
        #void testAssertEnumType_Null()
        #{
        #    Args    args;
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Empty
        #void testAssertFormDatasource_Empty()
        #{
        #    Args        args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(args);
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Fail
        #void testAssertFormDatasource_Fail()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(args);
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Null
        #void testAssertFormDatasource_Null()
        #{
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(null);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord
        #void testAssertRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Empty
        #void testAssertRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Map
        #void testAssertRecord_Map()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record  = CustTrans::find(0);
        #;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, tablenum(CustTrans));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_MapEmpty
        #void testAssertRecord_MapEmpty()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record;
        #;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, tablenum(CustTrans));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_NotMatch
        #void testAssertRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Null
        #void testAssertRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists
        #void testAssertRecordExists()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_Empty
        #void testAssertRecordExists_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_NotMatch
        #void testAssertRecordExists_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_Null
        #void testAssertRecordExists_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType
        #void testCheckCallerType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Ancestor
        #void testCheckCallerType_Ancestor()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classnum(SysTestAssert)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Empty
        #void testCheckCallerType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Interface
        #void testCheckCallerType_Interface()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classnum(SysTestable)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_NotMatch
        #void testCheckCallerType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classnum(FormRun)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Null
        #void testCheckCallerType_Null()
        #{
        #    Args    args;
        #;
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType
        #void testCheckEnumType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.assertTrue(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_Empty
        #void testCheckEnumType_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_NotMatch
        #void testCheckEnumType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(LedgerTransType)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_Null
        #void testCheckEnumType_Null()
        #{
        #    Args    args;
        #;
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord
        #void testCheckRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Empty
        #void testCheckRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Map
        #void testCheckRecord_Map()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record  = CustTrans::find(0);
        #;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, tablenum(CustTrans)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_MapEmpty
        #void testCheckRecord_MapEmpty()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record;
        #;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecord(args, tablenum(CustTrans)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_NotMatch
        #void testCheckRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecord(args, tablenum(UserGroupInfo)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Null
        #void testCheckRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.assertFalse(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists
        #void testCheckRecordExists()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_Empty
        #void testCheckRecordExists_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_NotMatch
        #void testCheckRecordExists_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, tablenum(UserGroupInfo)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_Null
        #void testCheckRecordExists_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testEnum
        #void testEnum()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #    args.parmEnum(NoYes::Yes);
        #
        #    // as Integers!
        #    this.assertEquals(0+NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_Empty
        #void testEnum_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_NotMatch
        #void testEnum_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(LedgerTransType));
        #    args.parmEnum(LedgerTransType::Sales);
        #
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_Null
        #void testEnum_Null()
        #{
        #    Args    args;
        #;
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault
        #void testEnumDefault()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(SysModule));
        #    args.parmEnum(SysModule::Ledger);
        #
        #    // as Integers!
        #    this.assertEquals(0+SysModule::Ledger, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_Empty
        #void testEnumDefault_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_NotMatch
        #void testEnumDefault_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(LedgerTransType));
        #    args.parmEnum(LedgerTransType::Sales);
        #
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_Null
        #void testEnumDefault_Null()
        #{
        #    Args    args;
        #;
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testRecord
        #void testRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(bufCmp(record,ArgsUtil::record(args, record.TableId)));
        #}
      ENDSOURCE
      SOURCE #testRecord_Empty
        #void testRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(bufCmp(record,ArgsUtil::record(args, record.TableId)));
        #}
      ENDSOURCE
      SOURCE #testRecord_NotMatch
        #void testRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::record(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testRecord_Null
        #void testRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::record(args, record.TableId);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysQuery unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysQuery
    PROPERTIES
      Name                #SysQuery
      Extends             #Query
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addRangesFromCon
        #// добавить каждое значение контейнера как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromCon(QueryBuildDataSource qbds, FieldId fieldId, container con)
        #{
        #    ConEnumerator ce;
        #
        #    if( qbds && fieldId && con )
        #    {
        #        ce = ConEnumerator::construct(con);
        #        while (ce && ce.moveNext())
        #        {
        #            qbds.addRange(fieldId).value(queryValue(ce.current()));
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromEnumerator
        #// добавить каждое значение энумератора как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static void addRangesFromEnumerator(QueryBuildDataSource qbds, FieldId fieldId, Enumerator e)
        #{
        #    if( qbds && fieldId )
        #    {
        #        while (e && e.moveNext())
        #        {
        #            qbds.addRange(fieldId).value(queryValue(e.current()));
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #addRangesFromKeyData
        #// Can't be an instance method because new queryRun() until takes a query!
        #static QueryBuildDataSource addRangesFromKeyData(
        #    QueryBuildDataSource    qbds,
        #    KeyData                 keyData     // Must be a unique list of values!
        #    )
        #{
        #    Map                     keyDataMap;
        #    MapEnumerator           me;
        #
        #    // A local a method is used because the a variable can change type for each while loop
        #    anytype a()
        #    {
        #        anytype a;
        #        [a] = me.currentValue();
        #        return a;
        #    }
        #    //Only do Map::create() when container has at least 4 parameters. version,domain type,
        #    //range type and size
        #    if (conlen(keyData) >= 4)
        #    {
        #        keyDataMap = Map::create(keyData);
        #
        #        me = keyDataMap.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            qbds.addRange(me.currentKey()).value(queryValue(a()));
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromList
        #// добавить каждое значение списка как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromList(QueryBuildDataSource qbds, FieldId fieldId, List list)
        #{
        #    ListEnumerator le;
        #
        #    if( qbds && fieldId && list )
        #    {
        #        le = list.getEnumerator();
        #        while (le && le.moveNext())
        #        {
        #            qbds.addRange(fieldId).value(queryValue(le.current()));
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromQbds
        #// копирует критерии из датасорса.
        #// не удаляет и не изменяет уже установленные критерии
        #//
        #// чтобы заменить существующие и добавить новые, используйте mergeRangesFromQbds
        #public static QueryBuildDataSource addRangesFromQbds(QueryBuildDataSource dest, QueryBuildDataSource source)
        #{
        #    return SysQuery::mergeRangeValuesFromQbds_Impl(dest, source, true);
        #}
      ENDSOURCE
      SOURCE #addRangesFromSet
        #// добавить каждое значение множества как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromSet(QueryBuildDataSource qbds, FieldId fieldId, Set set)
        #{
        #    SetEnumerator se;
        #
        #    if( qbds && fieldId && set )
        #    {
        #        se = set.getEnumerator();
        #        while (se && se.moveNext())
        #        {
        #            qbds.addRange(fieldId).value(queryValue(se.current()));
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #countLoops_MRC
        #public client server static Integer countLoops_MRC(QueryRun _queryRun)
        #{
        #    container c = SysQuery::countPrim_MRC(_queryRun.pack(false));
        #
        #    return conpeek(c,2);
        #}
      ENDSOURCE
      SOURCE #countPrim_MRC
        #private server static container countPrim_MRC(container _queryPack)
        #{
        #    Query                   countQuery;
        #    QueryRun                countQueryRun;
        #    QueryBuildDataSource    qbds;
        #    QueryBuildFieldList     qbfl;
        #    Common                  common;
        #    Integer                 counter;
        #    Integer                 loops;
        #
        #    Integer                 tmxGroupNumber;
        #    Integer                 tmxDataSourceNumber;
        #    ;
        #    countQueryRun   = new QueryRun(_queryPack);
        #    countQuery      = countQueryRun.query();
        #    tmxGroupNumber  = countQuery.groupByFieldCount();
        #
        #    for (tmxDataSourceNumber = 1; tmxDataSourceNumber <= countQuery.dataSourceCount(); tmxDataSourceNumber++)
        #    {
        #        qbds = countQuery.dataSourceNo(tmxDataSourceNumber);
        #        qbds.update(false);
        #
        #        qbfl = qbds.fields();
        #        qbfl.dynamic(false);
        #        qbfl.clearFieldList();
        #        qbds.addSelectionField(fieldNum(Common,RecId),SelectionField::Count);
        #    }
        #
        #    countQueryRun = new QueryRun(countQuery);
        #    while (countQueryRun.next())
        #    {
        #        common  = countQueryRun.getNo(1);
        #        counter += common.RecId;
        #        loops++;
        #    }
        #
        #    return [counter,(tmxGroupNumber ? loops : counter)];
        #}
      ENDSOURCE
      SOURCE #countTotal_MRC
        #public client server static Integer countTotal_MRC(QueryRun _queryRun)
        #{
        #    container c = SysQuery::countPrim_MRC(_queryRun.pack(false));
        #
        #    return conpeek(c,1);
        #}
      ENDSOURCE
      SOURCE #dateTime2strExtQuery_MRC
        #// pkoz, 21.08.2018
        #// см.
        #// https://blogs.msdn.microsoft.com/emeadaxsupport/2010/05/10/passing-utcdatetime-values-in-extended-query-syntax/
        #// http://www.book.axforum.info/forums/showthread.php?t=32991
        #
        #public static str dateTime2strExtQuery_MRC(utcDateTime _utcDateTime)
        #{
        #    str     ret;
        #    ;
        #
        #
        #    If(_utcDateTime==DateTimeUtil::minValue())
        #    {
        #        ret = @'1900-01-01T00:00:00';
        #    }
        #    else
        #    {
        #        ret = DateTimeUtil::toStr(_utcDateTime);
        #    }
        #
        #    return ret;
        #}
        #
        #/*
        #https://blogs.msdn.microsoft.com/emeadaxsupport/2010/05/10/passing-utcdatetime-values-in-extended-query-syntax/
        #// на случай если страничка недоступна
        #
        #
        #Passing UtcDateTime values in extended query syntax
        #
        #Recently I was looking into the issue of passing UtcDateTime values into a query in X++ using extended query syntax.
        #
        #
        #First I will just clarify what I mean when saying "extended query syntax":
        #
        #
        #This is extended query syntax:
        #
        #('(validUntilDate = %1)', DateTimeUtil::toStr(utcRefDateTime));
        #
        #This is the regular syntax for ranges:
        #
        #('%1', queryValue(utcRefDateTime));
        #
        #As you can see in my examples above, for the regular syntax using queryValue() is fine, but when using the extended query syntax, there are 3 basic rules for utcDateTime values:
        #- it's necessary to use DateTimeUtil::toStr() to pass utcDateTime values.
        #- The query string needs to have brackets around it.
        #- No speechmarks/quotations should be used around the utcDateTime value.
        #
        #
        #So working example:
        #
        #queryStr = strfmt(@"((StartDate < %2) && (EndDate < %2) && (validUntilDate = %1))", DateTimeUtil::toStr(2010-01-10T14:00:00), DateTimeUtil::toStr(2010-01-10T17:00:00));
        #
        #
        #And a failing example with brackets missing:
        #
        #queryStr = strfmt(@"((StartDate < %2) && EndDate < %2 && (validUntilDate = %1))", DateTimeUtil::toStr(2010-01-10T14:00:00), DateTimeUtil::toStr(2010-01-10T17:00:00));
        #
        #Failing with speechmarks/quotations:
        #
        #queryStr = strfmt(@"((StartDate < %2) && (EndDate < '%2') && (validUntilDate = %1))", DateTimeUtil::toStr(2010-01-10T14:00:00), DateTimeUtil::toStr(2010-01-10T17:00:00));
        #
        #
        #There is an exception to these rules, that is when using 1900-01-01T00:00:00. Most functions in X++ are returning this as NULL when converting to a string but for the extended range syntax to work correctly we need it to be returned as a string, so
        #the following functions cannot be used:
        #
        #
        #
        #QueryValue()
        #dateTime2Str()
        #DateTimeUtil::toStr()
        #Global::utcDateTimeNull()
        #DateTimeUtil::minValue()
        #
        #
        #So in my environment I have introduced a new global function to make it easier for me to convert utcDateTime values to strings for extended query ranges, called dateTime2strQuery()
        #
        #
        #
        #static str dateTime2strQuery(utcDateTime _utcDateTime)
        #{
        #str cvtDateTime;
        #;
        #
        #
        #If(_utcDateTime==DateTimeUtil::minValue())
        #    cvtDateTime = '1900-01-01T00:00:00';
        #else
        #  cvtDateTime = DateTimeUtil::toStr(_utcDateTime);
        #
        #
        #return cvtDateTime;
        #}
        #
        #
        #So now my working example looks like this:
        #
        #queryStr = strfmt(@"((StartDate < %2) && (EndDate < %2) && (validUntilDate = %1))", dateTime2strQuery(2010-01-10T14:00:00), dateTime2strQuery(2010-01-10T17:00:00));
        #
        #*/
      ENDSOURCE
      SOURCE #findGroupByField
        #//mazzy 05.02.2020
        #public static QueryGroupByField findGroupByField(
        #    Query                   _query,
        #    QueryBuildDataSource    _qbds,
        #    fieldId                 _fieldId)
        #{
        #    int                 groupFields;
        #    int                 i;
        #    QueryGroupByField   queryGroupByField;
        #;
        #
        #    if (_query && _qbds)
        #    {
        #        groupFields = _query.groupByFieldCount();
        #        for (i=1; i <= groupFields; ++i)
        #        {
        #            queryGroupByField = _query.groupByField(i);
        #
        #            if (queryGroupByField
        #                && queryGroupByField.fieldID() == _fieldId
        #                && queryGroupByField.dataSource().table() == _qbds.table())
        #            {
        #                break;
        #            }
        #        }
        #    }
        #
        #    return queryGroupByField;
        #}
      ENDSOURCE
      SOURCE #findOrCreateGroupByField
        #//mazzy 05.02.2020
        #public static QueryGroupByField findOrCreateGroupByField(Query _query, QueryBuildDataSource _queryBuildDataSource, fieldId _fieldId)
        #{
        #    QueryGroupByField    queryGroupByField;
        #
        #    if (_query && _queryBuildDataSource)
        #    {
        #        queryGroupByField = SysQuery::findGroupByField(_query, _queryBuildDataSource, _fieldId);
        #
        #        if (!queryGroupByField)
        #        {
        #            queryGroupByField = _queryBuildDataSource.addGroupByField(_fieldId);
        #        }
        #    }
        #
        #    return queryGroupByField;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRange
        #public static QueryBuildRange findOrCreateRange(QueryBuildDataSource _queryBuildDataSource, fieldId _fieldId)
        #{
        #    QueryBuildRange queryBuildRange;
        #
        #    if (_queryBuildDataSource)
        #    {
        #        queryBuildRange = _queryBuildDataSource.findRange(_fieldId);
        #
        #        if (!queryBuildRange && _fieldId)
        #        {
        #            queryBuildRange = _queryBuildDataSource.addRange(_fieldId);
        #        }
        #    }
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRangeValue
        #// mazzy 03.12.2019
        #// сразу устанавливает value (включая контейнер), выполняет экранирование
        #// пустое значение не изменяет критерий! чтобы очистить, используйте .findOrCreateRange(...).Value(SysQuery::valueUnlimited())
        #public static QueryBuildRange findOrCreateRangeValue(
        #    QueryBuildDataSource    _queryBuildDataSource,
        #    fieldId                 _fieldId,
        #    Anytype                 _value,
        #    boolean                 _usingExtendedQuery_MRC     = false)
        #{
        #    QueryBuildRange     queryBuildRange     = SysQuery::findOrCreateRange(_queryBuildDataSource, _fieldId);
        #    str                 strValue;
        #    ;
        #
        #    if (queryBuildRange)
        #    {
        #        strValue = SysQuery::value_MRC(_value, _usingExtendedQuery_MRC);
        #
        #        if( strValue )
        #        {
        #            // 08.08.2021 попробуем посмотреть как много фильтров превышает диапазон.
        #            // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #            ExtendedTypeIdUtil::isLengthEnoughOrWarning(typeid(Range), strValue);
        #
        #            queryBuildRange.value(strValue);
        #        }
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRangeValueNot
        #// mazzy 03.12.2019
        #// сразу устанавливает value (включая контейнер), выполняет экранирование
        #// пустое значение не изменяет критерий! чтобы очистить, используйте .findOrCreateRange(...).Value(SysQuery::valueUnlimited())
        #public static QueryBuildRange findOrCreateRangeValueNot(
        #    QueryBuildDataSource    _queryBuildDataSource,
        #    fieldId                 _fieldId,
        #    Anytype                 _value,
        #    boolean                 _usingExtendedQuery_MRC     = false)
        #{
        #    QueryBuildRange     queryBuildRange     = SysQuery::findOrCreateRange(_queryBuildDataSource, _fieldId);
        #    str                 strValue;
        #    ;
        #
        #    if (queryBuildRange)
        #    {
        #        strValue = SysQuery::valueNot(_value, _usingExtendedQuery_MRC);
        #
        #        if( strValue )
        #        {
        #            // 08.08.2021 попробуем посмотреть как много фильтров превышает диапазон.
        #            // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #            ExtendedTypeIdUtil::isLengthEnoughOrWarning(typeid(Range), strValue);
        #
        #            queryBuildRange.value(strValue);
        #        }
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #mergeRangeValuesFromQbds
        #// реализация: заменяет и добавляет значения критериев из датасорса.
        #// не копирует link и dynalink
        #
        #// используйте addRangesFromQbds или mergeRangesFromQbds
        #public static QueryBuildDataSource mergeRangeValuesFromQbds(
        #    QueryBuildDataSource    dest,
        #    QueryBuildDataSource    source)
        #{
        #    return SysQuery::mergeRangeValuesFromQbds_Impl(dest, source, false);
        #}
      ENDSOURCE
      SOURCE #mergeRangeValuesFromQbds_Impl
        #// реализация: заменяет и добавляет значения критериев из датасорса.
        #// не копирует link и dynalink
        #
        #// используйте addRangesFromQbds или mergeRangesFromQbds
        #protected static QueryBuildDataSource mergeRangeValuesFromQbds_Impl(
        #    QueryBuildDataSource    dest,
        #    QueryBuildDataSource    source,
        #    boolean                 addSameFieldRange   = false)
        #{
        #    QueryBuildRange     sourceRange;
        #    QueryBuildRange     destRange;
        #    int                 i;
        #    ;
        #
        #    if (source && dest && source.table() == dest.table())
        #    {
        #        for (i = 1; i <= source.rangeCount(); i++)
        #        {
        #            sourceRange = source.range(i);
        #            if (sourceRange && sourceRange.value())
        #            {
        #                if (!addSameFieldRange)
        #                {
        #                    dest.clearRange(sourceRange.field());
        #                }
        #                destRange = dest.addRange(sourceRange.field());
        #                if (destRange)
        #                {
        #                    destRange.value(sourceRange.value());
        #                    destRange.enabled(sourceRange.enabled());
        #                    destRange.status(sourceRange.status());
        #                }
        #            }
        #        }
        #    }
        #
        #    return dest;
        #}
      ENDSOURCE
      SOURCE #query
        #// mazzy 26.12.2019
        #public static Query query(
        #    TableId     _tableId,
        #    FieldId     _fieldId    = 0,
        #    Anytype     _value      = null)
        #{
        #    Query                   q       = new Query();
        #    QueryBuildDataSource    qbds    = q.addDataSource(_tableId);
        #    ;
        #
        #    if (_fieldId && qbds && !prmisdefault(_value))
        #    {
        #        SysQuery::findOrCreateRangeValue(qbds, _fieldId, _value);
        #    }
        #
        #    return q;
        #}
      ENDSOURCE
      SOURCE #queryRun
        #// mazzy 26.12.2019
        #public static QueryRun queryRun(
        #    TableId     _tableId,
        #    FieldId     _fieldId    = 0,
        #    Anytype     _value      = null)
        #{
        #    Query       q   = SysQuery::query(_tableId, _fieldId, _value);
        #    QueryRun    qr  = new QueryRun(q);
        #    ;
        #
        #    return qr;
        #}
      ENDSOURCE
      SOURCE #take
        #// получить из запроса n записей, начиная со startFrom
        #public static QueryRun take(Query q, int n, int startFrom = 1)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    ;
        #
        #    qr = QueryRunUtil::take(qr, n, startFrom);
        #
        #    return qr;
        #}
      ENDSOURCE
      SOURCE #value
        #public static str value(anytype a)
        #{
        #    str quotableStr = ' *",.()\\';
        #    str s;
        #    int t;
        #
        #    str doEscape(str s1)
        #    {
        #        int i = 1;
        #        int pos;
        #        int len = strlen(s1);
        #        str result;
        #        pos = strfind(s1, quotableStr, i, len - i + 1);
        #        while (pos)
        #        {
        #            result += substr(s1, i, pos - i) + '\\' + substr(s1, pos, 1);
        #            i = pos + 1;
        #            if (i<=len)
        #                pos = strfind(s1, quotableStr, i, len - i + 1);
        #            else
        #                pos = 0;
        #        }
        #
        #        if (i == 1)
        #            return s1;
        #
        #        if (i<=len)
        #            result += substr(s1, i, len - i + 1);
        #
        #        return result;
        #    }
        #
        #    t = typeof(a);
        #    switch (t)
        #    {
        #        case Types::Enum:
        #            return enum2Value(a);
        #        case Types::Real:
        #            return num2str(a,0,16,1,0);
        #        case Types::Date:
        #        case Types::UtcDateTime:
        #            return strfmt('\"%1\"',a);  // must be double quotes
        #        case
        #            Types::String,
        #            Types::RString,
        #            Types::VarString:
        #        {
        #            s = a;
        #            if (!s)
        #                return SysQuery::valueEmptyString();
        #            return strfmt('%1',doEscape(s));  // must be double quotes
        #        }
        #        //mazzy 03.12.2019 -->
        #        case Types::Container:
        #            return Any::construct(a).toQueryValue();
        #        case Types::Class:
        #            if (ObjectUtil::isEnumerable(a))
        #            {
        #                return Any::construct(a).toQueryValue();
        #            }
        #       //mazzy 03.12.2019 <--
        #    }
        #    // <GEEU>
        #
        #    // to avoid stack trace on unsupported value 'null'
        #    if (! new DictEnum(enumnum(Types)).value2Symbol(t))
        #        return SysQuery::valueUnlimited();
        #
        #        // </GEEU>
        #    return strfmt('%1',a);
        #}
      ENDSOURCE
      SOURCE #value_MRC
        #public static str value_MRC(
        #    anytype     a,
        #    boolean     _usingExtendedQuery_MRC = false //+GRD_fixQueryValue_pkoz, Исправление преобразования типов для расширенного Query, pkoz, 27.02.2009
        #    // см. http://www.axaptapedia.com/Expressions_in_query_ranges
        #    )
        #{
        #    // pkoz, 27.02.2009 -->
        #    /*
        #    str quotableStr = ' *",.()';
        #    */
        #    str quotableStr = ' *",.()\\';
        #    // забыли про экранирование слеша. Баг проявлялся в TradeLoopTrans классе при печати документов со слешем в номере - не видел строчек.
        #    // pkoz, 27.02.2009 <--
        #
        #    str s;
        #    int t;
        #
        #    str doEscape(str s1)
        #    {
        #        int i = 1;
        #        int pos;
        #        int len = strlen(s1);
        #        str result;
        #        pos = strfind(s1, quotableStr, i, len - i + 1);
        #        while (pos)
        #        {
        #            result += substr(s1, i, pos - i) + '\\' + substr(s1, pos, 1);
        #            i = pos + 1;
        #            if (i<=len)
        #                pos = strfind(s1, quotableStr, i, len - i + 1);
        #            else
        #                pos = 0;
        #        }
        #
        #        if (i == 1)
        #            return s1;
        #
        #        if (i<=len)
        #            result += substr(s1, i, len - i + 1);
        #
        #        return result;
        #    }
        #
        #    t = typeof(a);
        #    switch (t)
        #    {
        #        case Types::Enum:
        #            // -->
        #            if (_usingExtendedQuery_MRC)
        #            {
        #                return int2str(any2int(a));
        #            }
        #            // <--
        #            return enum2Value(a);
        #        case Types::Real:
        #            return num2str(a,0,16,1,0);
        #        case Types::Date:
        #            // GRD_fixQueryValue_pkoz, Исправление даты для расширенного Query, pkoz, 27.02.2009 -->
        #            if (_usingExtendedQuery_MRC)
        #            {
        #                return date2StrXpp(a);
        #            }
        #            // GRD_fixQueryValue_pkoz, Исправление даты для расширенного Query, pkoz, 27.02.2009 <--
        #            return strfmt('\"%1\"',a);  // must be double quotes
        #
        #        case Types::UtcDateTime:
        #            // GRD_fixQueryValue_pkoz, Исправление даты для расширенного Query, pkoz, 21.08.2018 -->
        #            if (_usingExtendedQuery_MRC)
        #            {
        #                return SysQuery::dateTime2strExtQuery_MRC(a);
        #            }
        #            // GRD_fixQueryValue_pkoz, Исправление даты для расширенного Query, pkoz, 21.08.2018 <--
        #
        #            return strFmt('\"%1\"',a);  // must be double quotes
        #
        #        case
        #            Types::String,
        #            Types::RString,
        #            Types::VarString:
        #        {
        #            s = a;
        #            if (!s)
        #                return SysQuery::valueEmptyString();
        #
        #            // -->
        #            if (_usingExtendedQuery_MRC)
        #            {
        #                return strfmt(@'"%1"', doEscape(s));
        #            }
        #            // <--
        #
        #            return strfmt('%1',doEscape(s));  // must be double quotes
        #        }
        #
        #        //mazzy 03.12.2019 -->
        #        case Types::Container:
        #            return Any::construct(a).toQueryValue(_usingExtendedQuery_MRC);
        #        case Types::Class:
        #            if (SysDictClass::isEqualOrSuperclass(classidget(a), classnum(Set)) ||
        #                SysDictClass::isEqualOrSuperclass(classidget(a), classnum(List)) ||
        #                SysDictClass::isEqualOrSuperclass(classidget(a), classnum(Array)))
        #            {
        #                return Any::construct(a).toQueryValue();
        #            }
        #       //mazzy 03.12.2019 <--
        #    }
        #    return strfmt('%1',a);
        #}
        #
        #/*
        #http://www.axaptapedia.com/Expressions_in_query_ranges
        #// на случай если страничка недоступна
        #
        #Expressions in query ranges
        #
        #Introduction
        #This is a method of specifying ranges on queries which allows you to perform complex comparisons, and create complex join situations which would be impossible using the standard syntax.
        #
        #Syntax
        #To use the special syntax, you should first add a range to your QueryBuildDataSource object in the normal way. Note that for this special syntax, it does not matter which field you use to add the range.
        #
        #To specify the range value itself, certain rules must be followed:
        #
        #The entire expression must be enclosed within single-quotes, not double-quotes
        #The entire expression must be enclosed in parenthesis (brackets)
        #Each sub-expression must be enclosed in its own set of parenthesis
        #For fields in the current table, simply the field name can be used
        #For fields in other tables, a prefix of the relevant datasource name must be added. This is not always the same as the table name.
        #String values should be surrounded by double-quotes, and wrapped in a call to queryValue()
        #Enum values should be specified by their integer value
        #Date values should be formatted using Date2StrXpp()
        #Blank string like ‘ ’ will not work as expected, use sysquery::valueEmptyString().
        #Examples
        #In the example below, we construct a query and add a single datasource.
        #
        #The range is then added, using the DataAreaId field on each table. Any field can be used, but using an unusual one such as DataAreaId helps remind a casual reader of the code that it's not a normal range.
        #
        #query = new Query();
        #dsInventTable = query.addDataSource(tableNum(InventTable));
        #
        #// Add our range
        #queryBuildRange = dsInventTable.addRange(fieldNum(InventTable, DataAreaId));
        #Given the above, the following are valid range specifications:
        #
        #Simple criteria
        #Find the record where ItemId is B-R14. Take note of the single quotes and parenthesis surrounding the entire expression.
        #
        #queryBuildRange.value(strFmt('(ItemId == "%1")', queryValue("B-R14")));
        #Find records where the ItemType is Service. Note the use of any2int().
        #
        #queryBuildRange.value(strFmt('(ItemType == %1)', any2int(ItemType::Service)));
        #Find records where the ItemType is Service or the ItemId is B-R14. Note the nesting of the parenthesis in this example.
        #
        #queryBuildRange.value(strFmt('((ItemType == %1) || (ItemId == "%2"))',
        #    any2int(ItemType::Service),
        #    queryValue("B-R14")));
        #Find records where the modified date is after 1st January 2000. Note the use of Date2StrXpp() to format the date correctly.
        #
        #queryBuildRange.value(strFmt('(ModifiedDate > %1)', Date2StrXpp(01\01\2000)));
        #Find records where the Field is blank (null) or an empty string. For more see Sys::Query Docs[1]
        #
        #qbrStatement = this.query().dataSourceName("BankAccountTrans2").addRange(fieldnum(BankAccountTrans,AccountStatement));
        #//qbrStatement.value("!?*");//this is the old way that may not work in future versions of AX
        #qbrStatement.value(sysquery::valueEmptyString());//this is the new way
        #Complex criteria with combined AND and OR clauses
        #Find all records where the ItemType is Service, or both the ItemType is Item and the ProjCategoryId is Spares. This is not possible to achieve using the standard range syntax.
        #
        #Note also that in this example, we are using the fieldStr() method to specify our actual field names and again, that we have nested our parenthesis for each sub-expression.
        #
        #queryBuildRange.value(strFmt('((%1 == %2) || ((%1 == %3) && (%4 == "%5")))',
        #    fieldStr(InventTable, ItemType),
        #    any2int(ItemType::Service),
        #    any2int(ItemType::Item),
        #    fieldStr(InventTable, ProjCategoryId),
        #    queryValue("Spares")));
        #WHERE clauses referencing fields from multiple tables
        #For this example below, we construct a query consisting of two joined datasources (using an Exists join). Note that we specify the datasource names when adding the datasources to the query.
        #
        #The ranges are then added, using the DataAreaId field on each table as described in the earlier example.
        #
        #query = new Query();
        #dsInventTable = query.addDataSource(tableNum(InventTable), tableStr(InventTable));
        #dsInventItemBarCode = dsInventTable.addDataSource(tableNum(InventItemBarCode), tableStr(InventItemBarCode));
        #dsInventItemBarCode.relations(true);
        #dsInventItemBarCode.joinMode(JoinMode::ExistsJoin);
        #
        #// Add our two ranges
        #queryBuildRange1 = dsInventTable.addRange(fieldNum(InventTable, DataAreaId));
        #queryBuildRange2 = dsInventItemBarCode.addRange(fieldNum(InventItemBarCode, DataAreaId));
        #Find all records where a bar code record exists for an item and was modified later than the item was modified.
        #
        #In this example, we are using the range on the BarCode table. Therefore the unqualified ModifiedDate reference will relate to InventItemBarCode.ModifiedDate. The other field is a fully-qualified one, using the DatasourceName.FieldName syntax.
        #
        #queryBuildRange2.value(strFmt('(ModifiedDate > InventTable.ModifiedDate)'));
        #Note that if we had added our InventTable datasource using the following code
        #
        #dsInventTable = query.addDataSource(tableNum(InventTable), "InventTableCustomName"); // Note that we are manually specifying a different datasource name
        #then the query range would need to appear as follows
        #
        #queryBuildRange2.value(strFmt('(ModifiedDate > InventTableCustomName.ModifiedDate)'));
        #Conditional joins
        #We will modify our previous example slightly, to remove the automatic addition of relations for the join.
        #
        #query = new Query();
        #dsInventTable = query.addDataSource(tableNum(InventTable), "InventTable");
        #dsInventItemBarCode = dsInventTable.addDataSource(tableNum(InventItemBarCode), "InventItemBarCode");
        #dsInventItemBarCode.joinMode(JoinMode::ExistsJoin);
        #
        #// Add our two ranges
        #queryBuildRange1 = dsInventTable.addRange(fieldNum(InventTable, DataAreaId));
        #queryBuildRange2 = dsInventItemBarCode.addRange(fieldNum(InventItemBarCode, DataAreaId));
        #We can now use the query expression to specify whatever we like as the join criteria.
        #
        #Find all records where either the ItemType is Service, or the ItemType is Item and a barcode exists. The join criteria is only applied in the second half of the expression, so all Service items will appear irrespective of whether they have a bar
        #code. Priot to Ax 2012, this was not possible to achieve using the standard query ranges. From that version onwards, however, the QueryFilter class can be used to achieve the same result.
        #
        #queryBuildRange2.value(strFmt('((%1.%2 == %3) || ((%1.%2 == %4) && (%1.%5 == %6)))',
        #    query.dataSourceTable(tableNum(InventTable)).name(), // InventTable %1
        #    fieldStr(InventTable, ItemType), // ItemType %2
        #    any2int(ItemType::Service), // %3
        #    any2int(ItemType::Item), // %4
        #    fieldStr(InventTable, ItemId), // ItemId %5
        #    fieldStr(InventItemBarCode, ItemId))); // %6
        #Using the techniques above, it is possible to create queries with almost as much flexibility as using SQL statements directly.
        #
        #Filter on array fields
        #queryBuildRange.value(strFmt('((%1.%2 == "%4") || (%1.%3 == "%5"))',
        #    queryBuildDataSource.name(),
        #    fieldid2name(tablenum(<table>), fieldid2ext(fieldnum(<table>, Dimension), Dimensions::code2ArrayIdx(SysDimension::Center))),
        #    fieldid2name(tablenum(<table>), fieldid2ext(fieldnum(<table>, Dimension), Dimensions::code2ArrayIdx(SysDimension::Purpose))),
        #    "some dim2 value",
        #    "some dim3 value"));
        #Note: you must always specify the datasource name if you use Query Expression syntax to filter on array fields. See also Limitations section at the bottom of the page.
        #
        #Using wildcards and comma-separated range values
        #Again, the previous example here was using standard syntax, not the special syntax using expressions. It's not possible to modify the above examples to work with wildcards.
        #
        #The above statement applies to AX versions < 5.0
        #
        #AX 5.0 introduced solution to wildcards - while you still cannot directly use wildcards in ranges, now it supports the 'LIKE' keyword.
        #
        #(AccountNum LIKE "*AA*" || Name LIKE "*AA*")
        #Limitations
        #The use of the extended query syntax is not supported by the new having filtering available in Ax 2012.
        #
        #There are two major limitations to the Query Expressions syntax. The first is the loss of support for wildcards and comma-separated range values, and the second is the inability to reference array fields such as dimensions in some older kernel
        #versions.
        #
        #Whilst in standard queries you can specify "AA*" or "A,B,C" as criteria, and they will be parsed by Axapta and sent through correctly to the database, these will simply be passed directly through when using the Query Expressions engine. As a result,
        #they will not return the expected results. On a related noted, the use of 'like' is not supported, so there is no way to use wildcards in any form.
        #
        #Query Expressions syntax for array fields such as the Dimension field is known to be suppported since the version 5.0.1500.2116 (RU4) for AX 2009. Previous kernel versions are not tested to support Query Expressions syntax for array fields; it is
        #also known not to work at all in Axapta 3.
        #
        #There is a discussion regarding the use of array fields on the Discussion page for this article. Please contribute to that discussion if possible!
        #*/
        #
      ENDSOURCE
      SOURCE #valueNot
        #//mazzy 19.12.2019
        #public static str valueNot(anytype a, boolean _usingExtendedQuery_MRC = false)
        #{
        #    str        ret;
        #    TextBuffer text;
        #    Enumerator e = CollectionUtil::getEnumerator(a);
        #    ;
        #
        #    if( e )
        #    {
        #        while( e.moveNext() )
        #        {
        #            text = TextBufferUtil::appendCollectionItem(text, SysQuery::valueNot(e.current()), ',');
        #        }
        #
        #        ret = text.getText();
        #    }
        #    else
        #    {
        #        ret = strfmt('!%1',SysQuery::value_MRC(a, _usingExtendedQuery_MRC));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysQueryTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysQueryTest
    PROPERTIES
      Name                #SysQueryTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysQueryTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testValue_Container
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_Container()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    str             range       = SysQuery::value(con);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertNotEqual(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
      SOURCE #testValue_List
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_List()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    List            list        = ListUtil::newFrom(con);
        #    str             range       = SysQuery::value(list);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertNotEqual(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
      SOURCE #testValue_Set
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_Set()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    Set             set         = SetUtil::newFrom(con);
        #    str             range       = SysQuery::value(set);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertNotEqual(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
      SOURCE #testValueNot_Container
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_Container()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    str             range       = SysQuery::valueNot(con);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertEquals(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
      SOURCE #testValueNot_List
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_List()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    List            list        = ListUtil::newFrom(con);
        #    str             range       = SysQuery::valueNot(list);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertEquals(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
      SOURCE #testValueNot_Set
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_Set()
        #{
        #    InventLocation  inventLocation;
        #    container       con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    Set             set         = SetUtil::newFrom(con);
        #    str             range       = SysQuery::valueNot(set);
        #    Query           q           = new Query();
        #    QueryRun        qr;
        #    boolean         found;
        #    ;
        #
        #    q.addDataSource(inventLocation.TableId)
        #        .addRange(fieldnum(InventLocation, InventLocationType))
        #        .value(range);
        #
        #    qr = new QueryRun(q);
        #    while(qr.next())
        #    {
        #        inventLocation = qr.get(inventLocation.TableId);
        #        this.assertEquals(0, confind(con, inventLocation.InventLocationType));
        #        found = true;
        #    }
        #
        #    this.assertTrue(found);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: QueryRunUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #QueryRunUtil
    PROPERTIES
      Name                #QueryRunUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class QueryRunUtil
        #{
        #}
      ENDSOURCE
      SOURCE #getByName
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Common getByName(QueryRun qr, str dsName)
        #{
        #    Query                   q       = qr && dsName ? qr.query() : null;
        #    QueryBuildDataSource    qbds    = q ? q.dataSourceName(dsName) : null;
        #    Common                  ret;
        #
        #    if( qbds )
        #    {
        #        ret = qr.getNo(qbds.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// получить из запроса n записей, начиная со startFrom
        #public static QueryRun take(QueryRun qr, int n, int startFrom = 1)
        #{
        #    if( qr && n )
        #    {
        #        qr.enablePositionPaging(true);
        #        qr.addPageRange(startFrom, n);
        #    }
        #
        #    return qr;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SessionUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SessionUtil
    PROPERTIES
      Name                #SessionUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class SessionUtil
        #{
        #}
      ENDSOURCE
      SOURCE #clientSessionTable
        #public static server SysClientSessions clientSessionTable(int _sessionId = 0)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    SysClientSessions clientSessions;
        #    ;
        #
        #    new SkipAOSValidationPermission().assert();
        #
        #    //BP deviation documented
        #    clientSessions.skipAosValidation(true);
        #
        #    select clientSessions
        #    where clientSessions.SessionId == sessId;
        #
        #    return clientSessions;
        #}
      ENDSOURCE
      SOURCE #clientType
        #public static ClientType clientType(int _sessionId = 0)
        #{
        #    return SessionUtil::session().clientKind();
        #
        #}
      ENDSOURCE
      SOURCE #isInRoleAdmin
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает true если:
        #// пользователь наделен правами локального администратора
        #// и текущая сессия была запущена runAsAdministrator
        #//
        #public static boolean isInRoleAdmin()
        #{
        #    #define.CacheOwner('SessionFlags')
        #    #define.CacheKey('isInRoleAdmin')
        #
        #    boolean ret;
        #    anytype cached = classfactory.globalCache().get(#CacheOwner, #CacheKey, '');
        #
        #    if( typeof(cached) == Types::Integer )
        #    {
        #        ret = cached;
        #    }
        #    else
        #    {
        #        ret = SessionUtil::isInRoleAdmin_Slow();
        #
        #        classfactory.globalCache().set(#CacheOwner, #CacheKey, ret);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInRoleAdmin_Slow
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает true если:
        #// пользователь наделен правами локального администратора
        #// и текущая сессия была запущена runAsAdministrator
        #//
        #// используйте метод isInRoleAdmin(), в котором выполняется кэширование
        #//
        #public static boolean isInRoleAdmin_Slow()
        #{
        #    anytype perm = new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    System.Security.Principal.WindowsIdentity    id = System.Security.Principal.WindowsIdentity::GetCurrent();
        #    System.Security.Principal.WindowsPrincipal   principal = new System.Security.Principal.WindowsPrincipal(id);
        #    System.Security.Principal.WindowsBuiltInRole admin = System.Security.Principal.WindowsBuiltInRole::Administrator;
        #
        #    boolean ret = principal.IsInRole(admin);
        #    ;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #serverSessionTable
        #public static server SysServerSessions serverSessionTable(int _sessionId = 0)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    SysClientSessions clientSessions;
        #    SysServerSessions serverSessions;
        #    ;
        #
        #    new SkipAOSValidationPermission().assert();
        #
        #    //BP deviation documented
        #    clientSessions.skipAosValidation(true);
        #    //BP deviation documented
        #    serverSessions.skipAosValidation(true);
        #
        #    select serverSessions
        #    exists join clientSessions
        #    where clientSessions.ServerId == serverSessions.ServerId
        #       && clientSessions.SessionId == sessId;
        #
        #    return serverSessions;
        #}
      ENDSOURCE
      SOURCE #session
        #public static Session session(int _sessionId = 0, boolean _checkSession = false)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    Session ret = new Session(sessId, _checkSession);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: Timer unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Timer
    PROPERTIES
      Name                #Timer
      Extends             #SysStopwatch
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс с коротким и запоминающимся названием.
        #// Но у многих такой класс уже есть.
        #//
        #// Дополнительно к методу StartNew (как в .net-библиотеке)
        #// класс имеет StartNow (очень многие привыкли в аксапте писать именно так)
        #class Timer extends SysStopwatch
        #{
        #}
      ENDSOURCE
      SOURCE #toString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public str toString()
        #{
        #    return this.elapsed();
        #}
      ENDSOURCE
      SOURCE #construct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Timer construct()
        #{
        #    Timer timer = new Timer();
        #
        #    return timer;
        #}
        #
      ENDSOURCE
      SOURCE #startNew
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Timer startNew()
        #{
        #    Timer timer = Timer::construct();
        #    ;
        #
        #    timer.start();
        #
        #    return timer;
        #}
      ENDSOURCE
      SOURCE #startNow
        #public static Timer startNow()
        #{
        #    Timer timer = Timer::construct();
        #    ;
        #
        #    timer.start();
        #
        #    return timer;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysStopwatch unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysStopwatch
    PROPERTIES
      Name                #SysStopwatch
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс обертка класса System.Diagnostics.Stopwatch
        #// см. https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch
        #//
        #// быстрый и эффективный класс:
        #// + не задействует метод new(), поэтому можно спокойно использовать classFactory.createClass() и другие фабрики
        #// + объекты создаются в памяти только по необходимости
        #// + минимум вычислений на X++, форматирование и преобразование в строку выполняется в .net
        #// + скрывает взаимодействие с CLR - программист может просто использовать X++ класс в своем коде
        #// + метод stopwatch() возвращает CLR-объект  - программист может получить доступ ко всей функциональности .net-объекта
        #// + метод toString() позволяет видеть время выполнения в отладчике
        #//
        #class SysStopwatch
        #{
        #    System.Diagnostics.Stopwatch stopwatch;
        #}
      ENDSOURCE
      SOURCE #elapsed
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает строку со временем выполнения в формате [-][d.]hh:mm:ss (без миллисекунд)
        #public str elapsed()
        #{
        #    str   ret;
        #    int64 ticks;
        #    int64 ticksPerSecond = 10000000; // https://docs.microsoft.com/en-us/dotnet/api/system.timespan.tickspersecond
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ticks = stopwatch.get_ElapsedTicks();
        #    ticks -= ticks mod ticksPerSecond;  // отбросим миллисекунды
        #
        #    ret = System.TimeSpan::FromTicks(ticks).ToString();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedFormated
        #public str elapsedFormated(boolean _stop = false)
        #{
        #    System.TimeSpan ts;
        #    str             ret;
        #    ;
        #
        #    if (_stop)
        #    {
        #        this.stop();
        #    }
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    if (stopwatch)
        #    {
        #        ts = stopwatch.get_Elapsed();
        #    }
        #    else
        #    {
        #        ts = System.TimeSpan::FromTicks(0);
        #    }
        #
        #    if (ts)
        #    {
        #        ret = ts.ToString();
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ElapsedMilliseconds
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public int64 elapsedMilliseconds()
        #{
        #    int64 ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_ElapsedMilliseconds();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedTicks
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public int64 elapsedTicks()
        #{
        #    int64 ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_ElapsedTicks();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedWide
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает строку со временем выполнения в формате [-][d.]hh:mm:ss[.ffffff] (с миллисекундами)
        #public str elapsedWide()
        #{
        #    str ret;
        #    System.TimeSpan timespan;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    timespan = stopwatch.get_Elapsed();
        #
        #    ret = timespan.ToString();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureInitialized
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #protected void ensureInitialized()
        #{
        #    if( !stopwatch )
        #    {
        #        stopwatch = new System.Diagnostics.Stopwatch();
        #    }
        #}
      ENDSOURCE
      SOURCE #init
        #protected void init()
        #{;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    if (stopwatch)
        #    {
        #        stopwatch = new System.Diagnostics.Stopwatch();
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
      SOURCE #initAndStart
        #protected void initAndStart()
        #{;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    stopwatch = System.Diagnostics.Stopwatch::StartNew();
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
      SOURCE #isRunning
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public boolean isRunning()
        #{
        #    boolean ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_IsRunning();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #protected void new(boolean startNow = false)
        #{
        #    if (startNow)
        #    {
        #        this.initAndStart();
        #    }
        #}
      ENDSOURCE
      SOURCE #reset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch reset()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Reset();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #start
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch start()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Start();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #stop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch stop()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Stop();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #stopPrintElapsed
        #public int64 stopPrintElapsed(boolean _formated = true, str _text = '')
        #{
        #    int64 ret;
        #    ;
        #
        #    this.stop();
        #
        #    ret = this.elapsedMilliseconds();
        #
        #    if (!_text)
        #    {
        #        _text = 'ELAPSED: ';
        #    }
        #
        #    if (_formated)
        #    {
        #        debug::printDebug(_text, this.elapsedFormated());
        #    }
        #    else
        #    {
        #        debug::printDebug(_text, ret, " MS");
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #stopwatch
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public System.Diagnostics.Stopwatch stopwatch()
        #{
        #    this.ensureInitialized();
        #
        #    return stopwatch;
        #}
      ENDSOURCE
      SOURCE #toString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public str toString()
        #{
        #    return this.elapsed();
        #}
      ENDSOURCE
      SOURCE #construct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static SysStopwatch construct()
        #{
        #    return new SysStopwatch();
        #}
        #
      ENDSOURCE
      SOURCE #contruct
        #public static SysStopWatch contruct(boolean startNow = false)
        #{
        #    return new SysStopWatch(startNow);
        #}
      ENDSOURCE
      SOURCE #startNew
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static SysStopwatch startNew()
        #{
        #    return SysStopwatch::construct().start();
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysStopwatchTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysStopwatchTest
    PROPERTIES
      Name                #SysStopwatchTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysStopwatchTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConstruct()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertTrue(SysDictClass::is(stopwatch, classnum(SysStopwatch)));
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testConstruct_False
        #void testConstruct_False()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct(false);
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(SysDictClass::is(sysStopWatch, classnum(SysStopWatch)));
        #    this.assertFalse(sysStopWatch.isRunning());
        #
        #}
      ENDSOURCE
      SOURCE #testConstruct_True
        #void testConstruct_True()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct(true);
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(SysDictClass::is(sysStopWatch, classnum(SysStopWatch)));
        #    this.assertTrue(sysStopWatch.isRunning());
        #
        #}
      ENDSOURCE
      SOURCE #testElapsed
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsed()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsed();
        #
        #    this.assertTrue(match(@'^:d:d\::d:d\::d:d$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testElapsed_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsed_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertEquals('00:00:00', stopwatch.elapsed());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted
        #void testElapsedFormatted()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertEquals('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted_Start
        #void testElapsedFormatted_Start()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted_StartNew
        #void testElapsedFormatted_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedMilliseconds()
        #{
        #    SysStopwatch sysStopWatch = SysStopWatch::startNew();
        #    int64 zero = 0;
        #;
        #    sleep(50);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedMilliseconds_NotStarted()
        #{
        #    SysStopwatch sysStopWatch = SysStopWatch::construct();
        #    int64 zero = 0;
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertEquals(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_Start
        #void testElapsedMilliseconds_Start()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #    int64           zero = 0;
        #;
        #    sysStopWatch.start();
        #    sleep(100);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_StartNew
        #void testElapsedMilliseconds_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #    int64           zero = 0;
        #;
        #    sleep(100);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedWideFormat
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedWideFormat()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsedWide();
        #
        #    this.assertTrue(match(@'^:d:d\::d:d\::d:d\.:d+$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testElapsedWideFormat_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedWideFormat_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertEquals('00:00:00', stopwatch.elapsedWide());
        #}
      ENDSOURCE
      SOURCE #testIsReset
        #void testIsReset()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.reset();
        #}
      ENDSOURCE
      SOURCE #testIsReset_startNew
        #void testIsReset_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.reset();
        #}
      ENDSOURCE
      SOURCE #testIsRunning
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    sleep(50);
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Immediately
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Immediately()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Reset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Reset()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    stopwatch.reset();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Start
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Start()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartNew
        #void testIsRunning_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartReset
        #void testIsRunning_StartReset()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #    sysStopWatch.reset();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertFalse(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartStop
        #void testIsRunning_StartStop()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #    sysStopWatch.stop();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertFalse(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Stop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Stop()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testReset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testReset()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.reset();
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testReset_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testReset_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #    int64 zero = 0;
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStart
        #void testStart()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #}
      ENDSOURCE
      SOURCE #testStart_startNew
        #void testStart_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.start();
        #}
      ENDSOURCE
      SOURCE #testStartNew
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStartNew()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertTrue(SysDictClass::is(stopwatch, classnum(SysStopwatch)));
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStop()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.stop();
        #
        #    this.assertNotEqual(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStop_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.stop();
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop_startNew
        #void testStop_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.stop();
        #}
      ENDSOURCE
      SOURCE #testToString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsed();
        #
        #    this.assertTrue(match(@':d:d\::d:d\::d:d$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testToString_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertEquals('00:00:00', stopwatch.toString());
        #}
      ENDSOURCE
      SOURCE #testToString_StartNew
        #void testToString_StartNew()
        #{
        #    SysStopWatch    sysStopWatch    = SysStopWatch::startNew();
        #    str             pattern         = @'^\d\d:\d\d:\d\d(\.\d+)?$';
        #    str             s;
        #    System.Text.RegularExpressions.Match regExpMatch;
        #;
        #    sleep(100);
        #
        #    s = sysStopWatch.toString();
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    regExpMatch = System.Text.RegularExpressions.Regex::Match(s, pattern);
        #
        #    this.assertTrue(regExpMatch && regExpMatch.get_Success(), strfmt('"%1" does not match "%2"', s, pattern));
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: PrevCurr unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #PrevCurr
    PROPERTIES
      Name                #PrevCurr
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс текущее и предыдущее значение,
        #// позволяет в цикле определить, что текущее значение отличается от предыдущего.
        #// Отлично работает и на первой итерации, когда предыдущего значения еще нет.
        #//
        #// Пример использования:
        #//
        #// container con = [1,1,2,2,3,3,3,2];
        #// Enumerator e = ConUtil::getEnumerator(con);
        #// PrevCurr prevCurr = PrevCurr::construct();
        #//
        #// while( e && e.moveNext() )
        #// {
        #//     if( prevCurr.isChanged(e.current()) )
        #//     {
        #//         info(strfmt("%1", e.current()));
        #//     }
        #// }
        #//
        #// Пример выведет в инфолог: 1,2,3,2
        #//
        #class PrevCurr
        #{
        #    Any current;
        #    Any previous;
        #}
      ENDSOURCE
      SOURCE #current
        #// сюда можно передать параметр любого типа, включая объект типа Any
        #public anytype current(anytype newCurrent = null)
        #{
        #    anytype ret;
        #
        #    if( !prmIsDefault(newCurrent) )
        #    {
        #        previous = current;
        #        current = Any::construct(newCurrent);
        #    }
        #
        #    if( current )
        #    {
        #        ret = current.value();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isChanged
        #// устанавливает newCurrent, если newCurrent был передан как параметр
        #// возвращает true, если текущее значение (current) отличается от предыдущего
        #// возвращает true, если и предыдущее, и текущее не были установлены ни разу
        #// возвращает false, если текущее значение совпадает с предыдущим
        #//
        #// параметром можно передать параметр любого типа, включая объект типа Any
        #public boolean isChanged(anytype newCurrent = null)
        #{
        #    boolean ret;
        #
        #    if( !prmisdefault(newCurrent) )
        #    {
        #        this.current(newCurrent);
        #    }
        #
        #    ret = !Any::isEqual(current, previous);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #prev
        #// сюда можно передать параметр любого типа, включая объект типа Any
        #public anytype prev(anytype newPrev = null)
        #{
        #    anytype ret;
        #
        #    if( !prmIsDefault(newPrev) )
        #    {
        #        previous = Any::construct(newPrev);
        #    }
        #
        #    if( previous )
        #    {
        #        ret = previous.value();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    previous = null;
        #    current = null;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static PrevCurr construct()
        #{
        #    return new PrevCurr();
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: PRN

; Microsoft Dynamics AX Project : SysUtil unloaded
; --------------------------------------------------------------------------------
  PROJECTVERSION 2
  
  PROJECT #SysUtil
   SHARED
  PROPERTIES
    Name                #SysUtil
  ENDPROPERTIES
  
    PROJECTCLASS ProjectNode
    GROUP #Error
      PROPERTIES
        Name                #Error
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 123
        NODETYPE 329
        NAME #Error
      ENDNODE
      ENDGROUP
      
    GROUP #Any
      PROPERTIES
        Name                #Any
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50014
        NODETYPE 329
        NAME #Any
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50016
        NODETYPE 329
        NAME #AnyTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50017
        NODETYPE 329
        NAME #AnytypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Types
      PROPERTIES
        Name                #Types
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50046
        NODETYPE 329
        NAME #DictTypeUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50068
        NODETYPE 329
        NAME #ExtendedTypeIdUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50065
        NODETYPE 329
        NAME #TypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #CLR
      PROPERTIES
        Name                #CLR
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50020
        NODETYPE 329
        NAME #ClrTypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Str
      PROPERTIES
        Name                #Str
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50030
        NODETYPE 329
        NAME #StrUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50056
        NODETYPE 329
        NAME #StrUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50036
        NODETYPE 329
        NAME #TextBufferUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50037
        NODETYPE 329
        NAME #TextUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Collection
      PROPERTIES
        Name                #Collection
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50042
        NODETYPE 329
        NAME #CollectionUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50023
        NODETYPE 329
        NAME #ConUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50025
        NODETYPE 329
        NAME #ListUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50029
        NODETYPE 329
        NAME #SetUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50041
        NODETYPE 329
        NAME #ArrayUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50051
        NODETYPE 329
        NAME #StackUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50055
        NODETYPE 329
        NAME #StructUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50070
        NODETYPE 329
        NAME #MapUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Enumerator
      PROPERTIES
        Name                #Enumerator
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50021
        NODETYPE 329
        NAME #EnumeratorUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50040
        NODETYPE 329
        NAME #ArrayEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50022
        NODETYPE 329
        NAME #ConEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50026
        NODETYPE 329
        NAME #OneValueEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50048
        NODETYPE 329
        NAME #RecordEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50053
        NODETYPE 329
        NAME #StrSplitEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50054
        NODETYPE 329
        NAME #StrSplitEnumeratorTest
      ENDNODE
      ENDGROUP
      
    GROUP #Class
      PROPERTIES
        Name                #Class
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      GROUP #Standard
        PROPERTIES
          Name                #Standard
          ProjectGroupType    #All
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 5434
          NODETYPE 329
          NAME #SysDictionary
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 1568
          NODETYPE 329
          NAME #SysDictClass
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 982
          NODETYPE 329
          NAME #SysDictEnum
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 935
          NODETYPE 329
          NAME #SysDictTable
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 641
          NODETYPE 329
          NAME #SysDictField
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 5313
          NODETYPE 329
          NAME #SysDictMethod
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 978
          NODETYPE 329
          NAME #SysDictType
        ENDNODE
        ENDGROUP
        
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50067
        NODETYPE 329
        NAME #ClassIdUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50043
        NODETYPE 329
        NAME #DictClassUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50047
        NODETYPE 329
        NAME #ObjectUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Record
      PROPERTIES
        Name                #Record
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50072
        NODETYPE 329
        NAME #TableIdUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50045
        NODETYPE 329
        NAME #DictTableUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50028
        NODETYPE 329
        NAME #RecordUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50049
        NODETYPE 329
        NAME #RecordList
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50050
        NODETYPE 329
        NAME #RecordMap
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50033
        NODETYPE 329
        NAME #SysRecordInsertList
      ENDNODE
      ENDGROUP
      
    GROUP #Field
      PROPERTIES
        Name                #Field
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50069
        NODETYPE 329
        NAME #FieldIdUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50044
        NODETYPE 329
        NAME #DictFieldUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Misc
      PROPERTIES
        Name                #Misc
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      GROUP #Args
        PROPERTIES
          Name                #Args
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50019
          NODETYPE 329
          NAME #ArgsUtil
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50066
          NODETYPE 329
          NAME #ArgsUtilTest
        ENDNODE
        ENDGROUP
        
      GROUP #Query
        PROPERTIES
          Name                #Query
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 2881
          NODETYPE 329
          NAME #SysQuery
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50032
          NODETYPE 329
          NAME #SysQueryTest
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50027
          NODETYPE 329
          NAME #QueryRunUtil
        ENDNODE
        ENDGROUP
        
      GROUP #Session
        PROPERTIES
          Name                #Session
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50013
          NODETYPE 329
          NAME #SessionUtil
        ENDNODE
        ENDGROUP
        
      GROUP #Timer
        PROPERTIES
          Name                #Timer
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50038
          NODETYPE 329
          NAME #Timer
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50001
          NODETYPE 329
          NAME #SysStopwatch
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50002
          NODETYPE 329
          NAME #SysStopwatchTest
        ENDNODE
        ENDGROUP
        
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50071
        NODETYPE 329
        NAME #PrevCurr
      ENDNODE
      ENDGROUP
      
  ENDPROJECT
  

***Element: END

Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Error unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Error
    PROPERTIES
      Name                #Error
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classIdMismatch
        #//mazzy 24.03.2021
        #public static LabelType classIdMismatch(str _funcName, ClassId actual, ClassId expected)
        #{
        #    SysDictClass actualDc = new SysDictClass(actual);
        #    SysDictClass expectedDc = new SysDictClass(expected);
        #
        #    str actualStr = actualDc ? actualDc.toString() : strfmt('%1',actual);
        #    str expectedStr = expectedDc ? expectedDc.toString() : strfmt('%1', expected);
        #
        #    LabelType ret = strfmt('Class mismatch at %1: Actual: %2, Expected %3', _funcName, actualStr, expectedStr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedEmptyString
        #// в качестве описания можно использовать название переменной
        #public static LabelType unsupportedEmptyString(str _funcName, anytype _description = '')
        #{
        #    LabelType ret = strfmt("unsupported empty string in %1 %2", _funcName, _description);
        #
        #    return ret;
        #    }
      ENDSOURCE
      SOURCE #unsupportedEnum
        #public static LabelType unsupportedEnum(str _funcName, anytype enumValue = '')
        #{
        #    LabelType ret;
        #;
        #
        #    if (typeof(enumValue) == Types::Enum)
        #    {
        #        ret = strfmt("Enum <%1:%2> не поддерживается %3. Обратитесь к разработчикам.", EnumId2Name(DictEnum::value2id(enumValue)), enumValue, _funcName);
        #    }
        #    else
        #    {
        #        ret = strfmt("Enum <%1> не поддерживается %2. Обратитесь к разработчикам.", enumValue, _funcName);
        #    }
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedNull
        #public static LabelType unsupportedNull(str _funcName, anytype _varNameOrText = '')
        #{
        #    LabelType ret = strfmt("unsupported Null in %1 %2", _funcName, _varNameOrText);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #unsupportedType
        #public static LabelType unsupportedType(str _funcName, anytype type = '')
        #{
        #    LabelType ret = strfmt("unsupported Type %1 - %2", type, _funcName);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: Any unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Any
    PROPERTIES
      Name                #Any
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addOrNothing
        #// возвращает this.value()+value2, если типы совместимы
        #// возвращает не определенный Anytype, если типы несовместимы
        #//
        #// Внимание! не изменяет текущее value, а возвращает сумму
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или Types::Anytype
        #//
        #// @see addOrIgnore, addOrReplace
        #public anytype addOrNothing(anytype value2)
        #{
        #    anytype ret = AnytypeUtil::addOrNothing(this.value(), value2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOrValue1
        #// возвращает this.value()+value2, если типы совместимы
        #// возвращает value1, если типы несовместимы (игнорирует value2)
        #//
        #// Внимание! не изменяет текущее value, а возвращает сумму
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или тип первого аргумента
        #//
        #// @see addOrValue2, addOrNothing
        #public anytype addOrValue1(anytype value2)
        #{
        #    anytype ret = AnytypeUtil::addOrValue1(this.value(), value2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOrValue2
        #// возвращает this.value()+value2, если типы совместимы
        #// возвращает value2, если типы несовместимы (value2 заменяет собой value1)
        #//
        #// Внимание! не изменяет текущее value, а возвращает сумму
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или тип второго аргумента
        #//
        #// @see addOrValue1, addOrNothing
        #public anytype addOrValue2(anytype value2)
        #{
        #    anytype ret = AnytypeUtil::addOrValue2(this.value(), value2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #as
        #public anytype as(Types type, int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::as(this.value(), type, potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #asArray
        #public Array asArray()
        #{
        #    return AnytypeUtil::asArray(this.value());
        #}
      ENDSOURCE
      SOURCE #asClass
        #public Object asClass(ClassId potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::asClass(this.value(), potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #asContainer
        #public container asContainer()
        #{
        #    return AnytypeUtil::asContainer(this.value());
        #}
      ENDSOURCE
      SOURCE #asDate
        #public Date asDate()
        #{
        #    return AnytypeUtil::asDate(this.value());
        #}
      ENDSOURCE
      SOURCE #asDateTime
        #public UtcDateTime asDateTime()
        #{
        #    return AnytypeUtil::asDateTime(this.value());
        #}
      ENDSOURCE
      SOURCE #asEnum
        #public anytype asEnum(enumId enumId = 0)
        #{
        #    return AnytypeUtil::asEnum(this.value(), enumId);
        #}
      ENDSOURCE
      SOURCE #asGUID
        #public GUID asGUID()
        #{
        #    return AnytypeUtil::asGUID(this.value());
        #}
      ENDSOURCE
      SOURCE #asInt
        #public int asInt()
        #{
        #    return AnytypeUtil::asInt(this.value());
        #}
      ENDSOURCE
      SOURCE #asInt64
        #public int64 asInt64()
        #{
        #    return AnytypeUtil::asInt64(this.value());
        #}
      ENDSOURCE
      SOURCE #asList
        #public List asList()
        #{
        #    return AnytypeUtil::asList(this.value());
        #}
      ENDSOURCE
      SOURCE #asMap
        #public Map asMap()
        #{
        #    return AnytypeUtil::asMap(this.value());
        #}
      ENDSOURCE
      SOURCE #asObject
        #public Object asObject()
        #{
        #    return AnytypeUtil::asObject(this.value());
        #}
      ENDSOURCE
      SOURCE #asReal
        #public Real asReal()
        #{
        #    return AnytypeUtil::asReal(this.value());
        #}
      ENDSOURCE
      SOURCE #asRecId
        #public int64 asRecId()
        #{
        #    return AnytypeUtil::asRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #asRecord
        #public Common asRecord(TableId tableId = 0)
        #{
        #    return AnytypeUtil::asRecord(this.value(), tableId);
        #}
      ENDSOURCE
      SOURCE #asRecVersion
        #public int64 asRecVersion()
        #{
        #    return AnytypeUtil::asRecVersion(this.value());
        #}
      ENDSOURCE
      SOURCE #asSet
        #public Set asSet()
        #{
        #    return AnytypeUtil::asSet(this.value());
        #}
      ENDSOURCE
      SOURCE #asString
        #public str asString()
        #{
        #    return AnytypeUtil::asString(this.value());
        #}
      ENDSOURCE
      SOURCE #asTime
        #public timeOfDay asTime()
        #{
        #    return AnytypeUtil::asTime(this.value());
        #}
      ENDSOURCE
      SOURCE #asValue
        #public anytype asValue(anytype asValue)
        #{
        #    anytype ret = AnytypeUtil::as(this.value(), asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс содержит неизменяемое значение любого типа
        #// чтобы переприсвоить значение, создайте новый объект этого типа
        #//
        #// Чем отличается этот класс от Anytype и от SysAnyType?
        #// 1.
        #// Аксапта позволяет установить произвольное значение в переменную типа anytype только один раз.
        #// Во время первой инициализации тип переменной фиксируется, в дальнейшем тип изменить нельзя.
        #//
        #// Anytype var = 1;
        #// var = 2;         // ok
        #// var = '';        // результат не определен. В большинстве версий аксапты будет 0;
        #//
        #// 2.
        #// Чтобы обойти эту проблему в Аксапту ввели тип SysAnyType
        #// SysAnyType позволяет в любой момент установить действительно любое значение.
        #// Но ради этого тип сделали очень тяжелым - в куче хранится map, key и сам объект в качестве value
        #// кроме того, каждое обращение к value - это lookup внутри map
        #//
        #// SysAnyType var = new SysAnyType(1);
        #// var.value('');   // будет хранить пустую строку
        #//
        #// 3.
        #// Данный класс Any не позволяет изменять значение хранимого объекта.
        #// Поэтому данный класс может просто хранить ref на объект произвольного типа
        #// Но! переприсвоить значение можно просто пересоздав объект Any
        #//
        #// Any var = new Any(1);        // ok
        #// var = new Any('');           // ok
        #//
        #// у Any есть несколько специализированных конструкторов и обычный construct
        #//
        #// Any var = Any::constuct(1);  // ok
        #// var = Any::constuct('');     // ok
        #//
        #// Класс проявляется в цикле (обратите внимание на специализированный конструктор conpeek)
        #//
        #// container con = [1, '', 31\01\2019];
        #// Any var;
        #// for(i=1; i<=conlen(con); ++i)
        #// {
        #//     var = Any::conpeek(con, i);
        #// }
        #class Any
        #{
        #    Anytype value;
        #}
      ENDSOURCE
      SOURCE #ensureEmpty
        #public Any ensureEmpty()
        #{
        #    if (this.value())
        #    {
        #        throw error(Error::wrongUseOfFunction(funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #ensureInTypes
        #public Any ensureInTypes(container typeCon)
        #{
        #    if (confind(typeCon, this.type()))
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #ensureNotEmpty
        #public Any ensureNotEmpty()
        #{
        #    if (this.value())
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public Any ensureType(Types type, int potentialAncestorId = 0)
        #{
        #    if (AnytypeUtil::is(this.value(), type, potentialAncestorId))
        #    {
        #        return this;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #equalsTo
        #public boolean equalsTo(Any type2)
        #{
        #    //Is one of them null ?
        #    if (!type2)
        #    {
        #        return false;
        #    }
        #
        #    //Are their types different ?
        #    if (this.type() != type2.type())
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (this.type() == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    //Are their values different ?
        #    if (this.value() != type2.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #hasValue
        #public boolean hasValue()
        #{
        #    boolean ret = AnytypeUtil::hasValue(this.value());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #id
        #public int id()
        #{
        #    int id = AnytypeUtil::Id(this.value());
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #is
        #public boolean is(Types type, int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::is(this.value(), type, potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isArray
        #public boolean isArray()
        #{
        #    return AnytypeUtil::isArray(this.value());
        #}
      ENDSOURCE
      SOURCE #isClass
        #public boolean isClass(int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::isClass(potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isCollection
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isCollection()
        #{
        #    return EnumeratorUtil::isEnumerable(this.value());
        #}
      ENDSOURCE
      SOURCE #isContainer
        #public boolean isContainer()
        #{
        #    return AnytypeUtil::isContainer(this.value());
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public boolean isEmpty()
        #{
        #    if (this.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isEnum
        #public boolean isEnum(enumId enumId = 0)
        #{
        #    return AnytypeUtil::isEnum(this.value(), enumId);
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isEnumerable()
        #{
        #    return EnumeratorUtil::isEnumerable(this.value());
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для значения, для которого можно получить enumerator
        #public boolean isEnumerator()
        #{
        #    return EnumeratorUtil::isEnumerator(this.value());
        #}
      ENDSOURCE
      SOURCE #isImplements
        #public boolean isImplements(int interfaceId = 0)
        #{
        #    return AnytypeUtil::isImplement(this.value(), interfaceId);
        #}
      ENDSOURCE
      SOURCE #isInt
        #public boolean isInt()
        #{
        #    return AnytypeUtil::isInt(this.value());
        #}
      ENDSOURCE
      SOURCE #isInt64
        #public boolean isInt64()
        #{
        #    return AnytypeUtil::isInt(this.value());
        #}
      ENDSOURCE
      SOURCE #isList
        #public boolean isList()
        #{
        #    return AnytypeUtil::isClass(classnum(List));
        #}
      ENDSOURCE
      SOURCE #isMap
        #public boolean isMap()
        #{
        #    return AnytypeUtil::isClass(classnum(Map));
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public boolean isNotEmpty()
        #{
        #    if (this.value())
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isPrimitive
        #public boolean isPrimitive()
        #{
        #    return AnytypeUtil::isPrimitive(this.value());
        #}
      ENDSOURCE
      SOURCE #isRecId
        #public boolean isRecId()
        #{
        #    return AnytypeUtil::isRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #isRecord
        #public boolean isRecord(int potentialAncestorId = 0)
        #{
        #    return AnytypeUtil::isRecord(this.value(), potentialAncestorId);
        #}
      ENDSOURCE
      SOURCE #isRecVersion
        #public boolean isRecVersion()
        #{
        #    return AnytypeUtil::isRecId(this.value());
        #}
      ENDSOURCE
      SOURCE #isSet
        #public boolean isSet()
        #{
        #    return AnytypeUtil::isClass(classnum(Set));
        #}
      ENDSOURCE
      SOURCE #isString
        #public boolean isString()
        #{
        #    return AnytypeUtil::isString(this.value());
        #}
      ENDSOURCE
      SOURCE #isValue
        #public boolean isValue(anytype isValue)
        #{
        #    boolean ret = AnytypeUtil::isValue(this.value(), isValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #void new(Anytype _value = null)
        #{
        #    value = _value;
        #}
      ENDSOURCE
      SOURCE #toBuf
        #// преобразовать value в соответствующий буфер, насколько это возможно
        #public Common toBuf()
        #{
        #    return AnytypeUtil::toBuf(this.value());
        #}
      ENDSOURCE
      SOURCE #toNullValue
        #public anytype toNullValue()
        #{
        #    return nullValueBaseType(this.type());
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString(str sep = ',')
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    str ret = AnytypeUtil::toString(this.value(), sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #final public Types type()
        #{
        #    Types type = typeof(value);
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #value
        #// только чтение! см. комментарий к classDeclaration
        #final public AnyType value()
        #{
        #    return value;
        #}
      ENDSOURCE
      SOURCE #checkAllNotEmpty
        #// принимает данные в контейнере, который состоит из контейнеров - значение и метка
        #// выдает ошибки для всех пустых значений
        #// если хотя бы одно значение пустое, то возвращает false
        #// если все значения не пустые, то возвращает true
        #//
        #// пример использования:
        #//     Any::checkAllNotEmpty([[purchId, 'Закупка'], [emplId, 'Ответственный']]);
        #//
        #public static boolean checkAllNotEmpty(container pairs, str txt = 'Значение не должно быть пустым. Укажите значение для %1.')
        #{
        #    boolean     ret = true;
        #
        #    container   pair;
        #    str         label;
        #
        #    int         i;
        #    int         len = conlen(pairs);
        #    ;
        #
        #    for (i=1; i<=len; ++i)
        #    {
        #        pair  = ConUtil::peekAsContainer(pairs, i);
        #        label = conpeek(pair, 2);
        #
        #        if( !conpeek(pair, 1) )
        #        {
        #            ret = CheckFailed(strfmt(txt, label));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #conpeek
        #public static Any conpeek(container con, int idx)
        #{
        #    anytype value   = conpeek(con, idx);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про контейнеры
        #    Any     ret     = Any::construct(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static Any construct(Anytype value)
        #{
        #    return new Any(value);
        #}
      ENDSOURCE
      SOURCE #field
        #public static Any field(Common record, fieldId fieldid)
        #{
        #    anytype value   = record.(fieldid);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    Any     ret     = Any::construct(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEqual
        #public static boolean isEqual(Any type1, Any type2)
        #{
        #    //Are both null ?
        #    if (!type1 && !type2)
        #    {
        #        return true;
        #    }
        #
        #    //Is one of them null ?
        #    if (!type1 || !type2)
        #    {
        #        return false;
        #    }
        #
        #    //Are their types different ?
        #    if (type1.type() != type2.type())
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (type1.type() == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    //Are their values different ?
        #    if (type1.value() != type2.value())
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: AnyTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #AnyTest
    PROPERTIES
      Name                #AnyTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class AnyTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testConpeek
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConpeek()
        #{
        #    container con = [1, '', 31\01\2019, ['inside'], 2019-01-31T13:00:00];
        #    Any any;
        #    ;
        #
        #    any = Any::conpeek(con, 1);
        #    this.assertEquals(conpeek(con,1), any.value());
        #
        #    any = Any::conpeek(con, 2);
        #    this.assertEquals(conpeek(con, 2), any.value());
        #
        #    any = Any::conpeek(con, 3);
        #    this.assertEquals(conpeek(con, 3), any.value());
        #
        #    any = Any::conpeek(con, 4);
        #    this.assertEquals(conpeek(con, 4), any.value());
        #
        #    any = Any::conpeek(con, 5);
        #    this.assertEquals(conpeek(con, 5), any.value());
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConstruct()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Any any;
        #    ;
        #
        #    any = Any::construct(i);
        #    this.assertEquals(i, any.value());
        #
        #    any = Any::construct(s);
        #    this.assertEquals(s, any.value());
        #
        #    any = Any::construct(v);
        #    this.assertEquals(v, any.value());
        #}
      ENDSOURCE
      SOURCE #testEqualsTo
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testEqualsTo()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Date d = systemdateget();
        #    utcdatetime dt = DateTimeUtil::utcNow();
        #    container c = [1, '', d];
        #
        #    Any any1 = Any::construct(i);
        #    Any any2;
        #    ;
        #
        #    any2 = Any::construct(i);
        #    this.assertTrue(any1.equalsTo(any2));
        #    this.assertTrue(any2.equalsTo(any1));
        #
        #    this.assertFalse(any1.equalsTo(null));
        #    this.assertFalse(any2.equalsTo(null));
        #
        #    any2 = Any::construct(s);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(v);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(d);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(dt);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #
        #    any2 = Any::construct(c);
        #    this.assertFalse(any1.equalsTo(any2));
        #    this.assertFalse(any2.equalsTo(any1));
        #}
      ENDSOURCE
      SOURCE #testField
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testField()
        #{
        #    UserInfo userInfo;
        #    Any any;
        #    ;
        #
        #    select firstOnly userInfo;
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, RecId));
        #    this.assertEquals(userInfo.RecId, any.value());
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, dataAreaId));
        #    this.assertEquals(userInfo.dataAreaId, any.value());
        #
        #    any = Any::field(userInfo, fieldnum(Userinfo, createdDateTime));
        #    this.assertEquals(userInfo.createdDateTime, any.value());
        #}
      ENDSOURCE
      SOURCE #testIsEqual
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsEqual()
        #{
        #    //TO DO проверить все типы
        #    int i = 1;
        #    str s = 'test';
        #    Voucher v = 'voucher';
        #    Date d = systemdateget();
        #    utcdatetime dt = DateTimeUtil::utcNow();
        #    container c = [1, '', d];
        #
        #    Any any1 = Any::construct(i);
        #    Any any2;
        #    ;
        #
        #    any2 = Any::construct(i);
        #    this.assertTrue(Any::isEqual(any1, any2));
        #    this.assertTrue(Any::isEqual(any2, any1));
        #
        #    this.assertTrue(Any::isEqual(null, null));
        #    this.assertFalse(Any::isEqual(any1, null));
        #    this.assertFalse(Any::isEqual(null, any2));
        #
        #    any2 = Any::construct(s);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(v);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(d);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(dt);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #
        #    any2 = Any::construct(c);
        #    this.assertFalse(Any::isEqual(any1, any2));
        #    this.assertFalse(Any::isEqual(any2, any1));
        #}
      ENDSOURCE
      SOURCE #testToString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString()
        #{
        #    //TO DO проверить все типы
        #    Any any;
        #    ;
        #
        #    any = Any::construct(1);
        #    this.assertEquals('1', any.toString());
        #
        #    any = Any::construct('test');
        #    this.assertEquals('test', any.toString());
        #
        #    any = Any::construct(31\12\2019);
        #    this.assertEquals(strfmt('%1',31\12\2019), any.toString());
        #
        #    any = Any::construct(2019-12-31T13:01:00);
        #    this.assertEquals(strfmt('%1',2019-12-31T13:01:00), any.toString());
        #
        #    any = Any::construct([1, '', [31\12\2019]]);
        #    this.assertEquals('1,,31.12.2019', any.toString());
        #
        #    any = Any::construct(appl);
        #    this.assertEquals('Class xApplication', any.toString());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: AnytypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #AnytypeUtil
    PROPERTIES
      Name                #AnytypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс AnytypeUtil обслуживает значения типа anytype
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #class AnytypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #addOrNothing
        #// возвращает value1+value2, если типы совместимы
        #// возвращает не определенный Anytype, если типы несовместимы
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или Types::Anytype
        #//
        #// @see addOrValue1, addOrValue2
        #public static anytype addOrNothing(anytype value1, anytype value2)
        #{
        #    anytype ret;
        #    Types type = typeof(value1);
        #
        #    switch( type )
        #    {
        #        /*
        #        // практика показывает, что добавление строк в этом методе
        #        // скорее сбивает программиста с толку, нежели делает полезное
        #        // поэтому в этом методе строки не суммируем
        #
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            if( AnytypeUtil::isString(value2) )
        #            {
        #                ret = value1 + value2;
        #            }
        #            break;
        #        */
        #
        #        case Types::Integer:
        #        case Types::Int64:
        #        case Types::Real:
        #        case Types::Date:
        #        case Types::Time:
        #            if( AnytypeUtil::isNumeric(value2) )
        #            {
        #                ret = value1 + value2;
        #            }
        #            break;
        #
        #        case Types::Container:
        #            if( AnytypeUtil::isPrimitive(value2) )
        #            {
        #                ret = value1 + value2;                      // возможна ошибка ядра, если типы несовместимы
        #            }
        #            break;
        #
        #        case Types::Class:
        #            if( ObjectUtil::isSetWithType(value1, typeof(value2)) )
        #            {
        #                ret = SetUtil::addAll(value1, value2);      // может пропустить value2, если типы несовместимы
        #            }
        #            else if( ObjectUtil::isListWithType(value1, typeof(value2)) )
        #            {
        #                ret = ListUtil::addAll(value1, value2);     // может пропустить value2, если типы несовместимы
        #            }
        #            else if( ObjectUtil::isArrayWithType(value1, typeof(value2)) )
        #            {
        #                ret = ArrayUtil::addAll(value1, value2);    // может пропустить value2, если типы несовместимы
        #            }
        #            break;
        #
        #        default:
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOrValue1
        #// возвращает value1+value2, если типы совместимы
        #// возвращает value1, если типы несовместимы (игнорирует value2)
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или тип первого аргумента
        #//
        #// @see addOrValue2, addOrNothing
        #public static anytype addOrValue1(anytype value1, anytype value2)
        #{
        #    anytype ret = AnytypeUtil::addOrNothing(value1, value2);
        #
        #    if( typeof(ret) == Types::AnyType )
        #    {
        #        ret = value1;   // игнорирует value2
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOrValue2
        #// возвращает value1+value2, если типы совместимы
        #// возвращает value2, если типы несовместимы (value2 заменяет собой value1)
        #//
        #// оператор + это арифметический плюс или конкатенация (для строк, контейнеров и других коллекций)
        #// поэтому тип возвращаемого значения - это тип суммы или тип второго аргумента
        #//
        #// @see addOrValue1, addOrNothing
        #public static anytype addOrValue2(anytype value1, anytype value2)
        #{
        #    anytype ret = AnytypeUtil::addOrNothing(value1, value2);
        #
        #    if( typeof(ret) == Types::AnyType )
        #    {
        #        ret = value2;   // value2 заменяет собой value1
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #as
        #public static anytype as(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    if( AnytypeUtil::is(value, type, potentialAncestorId) )
        #    {
        #        return value;
        #    }
        #
        #    return nullValueBaseType(type);
        #}
      ENDSOURCE
      SOURCE #asArray
        #public static Array asArray(anytype value)
        #{
        #    if( AnytypeUtil::isArray(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asArrayWithType
        #public static Array asArrayWithType(anytype value, Types elementType)
        #{
        #    if( AnytypeUtil::isArrayWithType(value, elementType) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asClass
        #public static Object asClass(anytype value, ClassId potentialAncestorId = 0)
        #{
        #    Object ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        if( potentialAncestorId )
        #        {
        #            ret = ObjectUtil::as(value, potentialAncestorId);
        #        }
        #        else
        #        {
        #            ret = value;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asCollection
        #public static anytype asCollection(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #asContainer
        #public static container asContainer(anytype value)
        #{
        #    container ret;
        #
        #    if( typeof(value) == Types::Container )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asDate
        #public static Date asDate(anytype value)
        #{
        #    Date ret;
        #
        #    if( typeof(value) == Types::Date )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asDateTime
        #public static UtcDateTime asDateTime(anytype value)
        #{
        #    utcdatetime ret;
        #
        #    if( typeof(value) == Types::UtcDateTime )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEnum
        #public static anytype asEnum(anytype value, enumId enumId = 0)
        #{
        #    return AnytypeUtil::as(value, Types::Enum, enumId);
        #}
      ENDSOURCE
      SOURCE #asEnumDefault
        #public static anytype asEnumDefault(anytype value, anytype defaultEnumValue)
        #{
        #    int enumId = AnytypeUtil::enumId(defaultEnumValue);
        #
        #    if( enumId && AnytypeUtil::is(value, Types::Enum, enumId) )
        #    {
        #        return value;
        #    }
        #
        #    return defaultEnumValue;
        #}
        #
        #
      ENDSOURCE
      SOURCE #asEnumerable
        #public static anytype asEnumerable(anytype value)
        #{
        #    anytype ret = EnumeratorUtil::asEnumerable(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEnumerator
        #public static anytype asEnumerator(anytype value)
        #{
        #    anytype ret = EnumeratorUtil::asEnumerator(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEnumOrDefault
        #public static anytype asEnumOrDefault(anytype value, anytype defaultEnumValue)
        #{
        #    int enumId = AnytypeUtil::enumId(defaultEnumValue);
        #
        #    if( enumId && AnytypeUtil::is(value, Types::Enum, enumId) )
        #    {
        #        return value;
        #    }
        #
        #    return defaultEnumValue;
        #}
        #
        #
      ENDSOURCE
      SOURCE #asGUID
        #public static GUID asGUID(anytype value)
        #{
        #    if( typeof(value) == Types::Guid )
        #    {
        #        return value;
        #    }
        #
        #    return nullValueBaseType(Types::Guid);
        #}
      ENDSOURCE
      SOURCE #asInt
        #public static int asInt(anytype value)
        #{
        #    int ret;
        #
        #    if( typeof(value) == Types::Integer )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asInt64
        #public static int64 asInt64(anytype value)
        #{
        #    int64 ret;
        #
        #    if( typeof(value) == Types::Int64 )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asList
        #public static List asList(anytype value)
        #{
        #    List ret;
        #
        #    if( AnytypeUtil::isList(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asListWithType
        #public static List asListWithType(anytype value, Types elementType)
        #{
        #    List ret;
        #
        #    if( AnytypeUtil::isListWithType(value, elementType) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asMap
        #public static Map asMap(anytype value)
        #{
        #    Map ret;
        #
        #    if( AnytypeUtil::isMap(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asMapWithType
        #public static Map asMapWithType(anytype value, Types keyType, Types valueType)
        #{
        #    Map ret;
        #
        #    if( AnytypeUtil::isMapWithType(value, keyType, valueType) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asObject
        #public static Object asObject(anytype value)
        #{
        #    return AnytypeUtil::asClass(value);
        #}
      ENDSOURCE
      SOURCE #asReal
        #public static Real asReal(anytype value)
        #{
        #    real ret;
        #
        #    if( typeof(value) == Types::Real )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asRecId
        #public static RecId asRecId(anytype value)
        #{
        #    RecId ret;
        #
        #    if( typeof(value) == Types::Int64 )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asRecord
        #public static Common asRecord(anytype value, TableId tableId = 0)
        #{
        #    Common ret = AnytypeUtil::as(value, Types::Record, tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asRecVersion
        #public static RecVersion asRecVersion(anytype value)
        #{
        #    RecVersion ret;
        #
        #    if( typeof(value) == Types::Integer )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #assertEmpty
        #public static anytype assertEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        throw error(Error::wrongUseOfFunction(funcName()));
        #    }
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #assertNotEmpty
        #public static anytype assertNotEmpty(anytype value)
        #{
        #    if (value)
        #    {
        #        return value;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcName()));
        #}
      ENDSOURCE
      SOURCE #assertType
        #public static anytype assertType(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    if (AnytypeUtil::is(value, type, potentialAncestorId))
        #    {
        #        return value;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcName()));
        #}
      ENDSOURCE
      SOURCE #asSet
        #public static Set asSet(anytype value)
        #{
        #    Set ret;
        #
        #    if( AnytypeUtil::isSet(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asSetWithType
        #public static Set asSetWithType(anytype value, Types elementType)
        #{
        #    Set ret;
        #
        #    if( AnytypeUtil::isSetWithType(value, elementType) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asStack
        #public static Stack asStack(anytype value)
        #{
        #    Stack ret;
        #
        #    if( AnytypeUtil::isStack(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asString
        #public static str asString(anytype value)
        #{
        #    str ret;
        #
        #    if( AnytypeUtil::isString(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asStruct
        #public static Struct asStruct(anytype value)
        #{
        #    Struct ret;
        #
        #    if( AnytypeUtil::isStruct(value) )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asTime
        #public static timeOfDay asTime(anytype value)
        #{
        #    timeOfDay ret;
        #
        #    if( typeof(value) == Types::Integer )
        #    {
        #        ret = value;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asValue
        #public static anytype asValue(anytype value, anytype asValue)
        #{
        #    Types   asType = typeof(asValue);
        #    Int     asId   = AnytypeUtil::id(asValue);
        #    anytype ret    = AnytypeUtil::as(value, asType, asId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classId
        #public static int classId(anytype value)
        #{
        #    int id = 0;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        id = classidget(value);
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #enumId
        #public static int enumId(anytype enumIdOrNameOrValue)
        #{
        #    Types type = typeof(enumIdOrNameOrValue);
        #    int enumId = 0;
        #
        #    switch( type )
        #    {
        #        case Types::Enum:
        #            enumId = DictEnum::value2id(enumIdOrNameOrValue);
        #            break;
        #
        #        case Types::Integer:
        #            enumId = enumIdOrNameOrValue;
        #            break;
        #
        #        case Types::Int64:
        #            enumId = int642int(enumIdOrNameOrValue, true);
        #            break;
        #
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            enumId = enumName2Id(enumIdOrNameOrValue);
        #            break;
        #    }
        #
        #    return enumId;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// возвращает объект, который реализует интерфейс EEnumerator
        #public static EEnumerator getEEnumerator(anytype collectionOrValue)
        #{
        #    EEnumerator e = EnumeratorUtil::getEEnumerator(collectionOrValue);
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает объект, у которого можно вызвать метод moveNext
        #public static Enumerator getEnumerator(anytype collectionOrValue)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #hasValue
        #public static boolean hasValue(anytype probe)
        #{
        #    boolean ret = TypeUtil::isSpecified(typeof(probe));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #id
        #public static int id(anytype value)
        #{
        #    int     id = 0;
        #    Types   type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Enum:
        #            id = DictEnum::value2id(value);
        #            break;
        #
        #        case Types::Record:
        #            id = AnytypeUtil::asRecord(value).TableId;
        #            break;
        #
        #        case Types::Class:
        #            id = classidget(value);
        #            break;
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(anytype value, Types type, int potentialAncestorId = 0)
        #{
        #    Types t = typeof(value);
        #
        #    if( potentialAncestorId )
        #    {
        #        switch( t )
        #        {
        #            case Types::Class:
        #                return (type == t) && ObjectUtil::is(value, potentialAncestorId);
        #
        #            case Types::Record:
        #                return (type == t) && SysDictTable::is(value, potentialAncestorId);
        #
        #            case Types::Integer:
        #                switch( type )
        #                {
        #                    case Types::Class:
        #                        return ClassUtil::is(value, potentialAncestorId);
        #
        #                    case Types::Record:
        #                        return TableUtil::is(value, potentialAncestorId);
        #
        #                    case Types::UserType:
        #                        return DictTypeUtil::is(value, potentialAncestorId);
        #
        #                    case Types::Enum:
        #                        return (potentialAncestorId == value && new DictEnum(value));
        #                }
        #                break;
        #
        #            case Types::Enum:
        #                return (type == t) && potentialAncestorId == DictEnum::value2id(value);
        #        }
        #    }
        #
        #    if( TypeUtil::is(t, type) )
        #    {
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isArray
        #public static boolean isArray(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isArray(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isArrayWithType
        #public static boolean isArrayWithType(anytype value, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isArrayWithType(value, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isClass
        #public static boolean isClass(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isCollection
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isCollection(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #isContainer
        #public static boolean isContainer(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Container;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public static boolean isEmpty(anytype value)
        #{
        #    boolean ret = true;
        #
        #    if (value)
        #    {
        #        ret = AnytypeUtil::isCollection(value) && CollectionUtil::isEmpty(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnum
        #public static boolean isEnum(anytype value, enumId enumId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(value, Types::Enum, enumId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerable(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerator(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerator(value);
        #}
      ENDSOURCE
      SOURCE #isEqual
        #// не создаем новых переменных в стеке
        #public static boolean isEqual(anytype value1, anytype value2)
        #{
        #    //Are their types different ?
        #    if (typeof(value1) != typeof(value2))
        #    {
        #        return false;
        #    }
        #
        #    //Are both null ot empty?
        #    if (!value1 && !value2)
        #    {
        #        return true;
        #    }
        #
        #    //Is one of them null ot empty?
        #    if (!value1 || !value2)
        #    {
        #        return false;
        #    }
        #
        #    //They are the same type. Is this type void ?
        #    if (typeof(value1) == Types::void)
        #    {
        #        return true;
        #    }
        #
        #    if (typeof(value1) == Types::Class)
        #    {
        #        return ObjectUtil::isEqual(value1, value2);
        #    }
        #
        #    //Are their values different ?
        #    if (value1 != value2)
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #public static boolean isImplement(anytype value, int interfaceId = 0)
        #{
        #    boolean ret;
        #
        #    if( interfaceId && typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isImplement(value, interfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInt
        #public static boolean isInt(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Integer;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInt64
        #public static boolean isInt64(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Int64;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isList
        #public static boolean isList(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isClass(value, classnum(List));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isListWithType
        #public static boolean isListWithType(anytype value, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isListWithType(value, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMap
        #public static boolean isMap(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ClassUtil::isMap(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMapWithType
        #public static boolean isMapWithType(anytype value, Types keyType, Types valueType)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isMapWithType(value, keyType, valueType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
        #public static boolean isNotEmpty(anytype value)
        #{
        #    boolean ret = AnytypeUtil::isEmpty(value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEqual
        #// не создаем новых переменных в стеке
        #public static boolean isNotEqual(anytype value1, anytype value2)
        #{
        #    boolean ret = !AnytypeUtil::isEqual(value1, value2);
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isNotNull
        #public static boolean isNotNull(anytype value)
        #{
        #    boolean ret = true;
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Class:
        #            ret = value != null;
        #            break;
        #
        #        case typeof(null):
        #            ret = false;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNull
        #public static boolean isNull(anytype value)
        #{
        #    boolean ret;
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Class:
        #            ret = !value;
        #            break;
        #
        #        case typeof(null):
        #            ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNullOrEmptyStr
        #public static boolean isNullOrEmptyStr(anytype value)
        #{
        #    boolean ret;
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #        case Types::Class:
        #            ret = !value;
        #            break;
        #
        #        case typeof(null):
        #            ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(anytype value)
        #{
        #    Types type = typeof(value);
        #    boolean ret = TypeUtil::isNumeric(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isObject
        #public static boolean isObject(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isObjectOnClient
        #// для null всегда будет false
        #public static boolean isObjectOnClient(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);
        #
        #    if( ret )
        #    {
        #        ret = ObjectUtil::isObjectOnClient(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isObjectOnServer
        #public static boolean isObjectOnServer(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);
        #
        #    if( ret )
        #    {
        #        ret = ObjectUtil::isObjectOnServer(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPrimitive
        #public static boolean isPrimitive(anytype value)
        #{
        #    Types type = typeof(value);
        #    boolean ret = TypeUtil::isPrimitive(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isQueryValue
        #// возвращает true, если значение (кроме пустой строки) будет преобразовано в непустое queryValue
        #// возвращает false, если значение является пустой строкой или не будет обработано методом SysQuery::value()
        #public static boolean isQueryValue(anytype value)
        #{
        #    return SysQuery::isQueryValue(value);
        #}
      ENDSOURCE
      SOURCE #isRecId
        #public static boolean isRecId(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Int64;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isRecord
        #public static boolean isRecord(anytype value, int potentialAncestorId = 0)
        #{
        #    boolean ret = AnytypeUtil::is(value, Types::Record, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isRecVersion
        #public static boolean isRecVersion(anytype value)
        #{
        #    boolean ret = typeof(value) == Types::Integer;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSet
        #public static boolean isSet(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ClassUtil::isSet(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSetWithType
        #public static boolean isSetWithType(anytype value, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isSetWithType(value, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStack
        #public static boolean isStack(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ClassUtil::isStack(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(anytype value)
        #{
        #    Types type = typeof(value);
        #    boolean ret = TypeUtil::isString(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStruct
        #public static boolean isStruct(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ClassUtil::isStruct(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(anytype value)
        #{
        #    boolean ret = TypeUtil::isUndefined(typeof(value));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isValue
        #public static boolean isValue(anytype value, anytype isValue)
        #{
        #    Types   isType = typeof(isValue);
        #    Int     isId   = AnytypeUtil::id(isValue);
        #    boolean ret    = AnytypeUtil::is(value, isType, isId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nullValue
        #public static anytype nullValue(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    return nullValueBaseType(type);
        #}
      ENDSOURCE
      SOURCE #tableId
        #public static int tableId(anytype value)
        #{
        #    int id = 0;
        #
        #    if( typeof(value) == Types::Record )
        #    {
        #        id = AnytypeUtil::asRecord(value).TableId;
        #    }
        #
        #    return id;
        #}
      ENDSOURCE
      SOURCE #toBuf
        #// преобразовать value в соответствующий буфер, насколько это возможно
        #public static Common toBuf(anytype value)
        #{
        #    Common buf;
        #
        #    switch(typeof(value))
        #    {
        #        case Types::Record:
        #            buf = value;
        #            break;
        #
        #        case Types::Integer:
        #            buf = TableUtil::makeRecord(value);
        #            break;
        #
        #        case Types::Int64:
        #            buf = TableUtil::makeRecord(int642int(value, true));
        #            break;
        #
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            if( value )
        #            {
        #                buf = TableUtil::makeRecord(tablename2id(value));
        #            }
        #            break;
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #toNullValue
        #public static anytype toNullValue(anytype value)
        #{
        #    return nullValueBaseType(value);
        #}
      ENDSOURCE
      SOURCE #toString
        #public static str toString(anytype value, str sep = ',')
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    Types type = typeof(value);
        #    str   ret;
        #    Object obj;
        #
        #    switch (type)
        #    {
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #            ret = value;
        #            break;
        #
        #        case Types::Container:
        #            ret = ConUtil::toStr(value, sep);
        #            break;
        #
        #        case Types::Enum:
        #            ret = enum2str(value);
        #            break;
        #
        #        case Types::AnyType:
        #            ret = '';
        #            break;
        #
        #        case Types::Record:
        #            ret = RecordUtil::getValuesInfo(value);
        #            break;
        #
        #        case Types::Class:
        #            if( value )
        #            {
        #                obj = value;
        #                ret = obj.toString();
        #            }
        #            else
        #            {
        #                ret = 'null';
        #            }
        #            break;
        #
        #        case Types::BLOB:
        #        case Types::void:
        #            ret = strfmt('%1', type); // не бросаем исключение! throw error(Error::unsupportedEnum(funcname(), type));
        #            break;
        #
        #        default:
        #            ret = strfmt('%1', value);
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #undefined
        #public static anytype undefined()
        #{
        #    anytype undefined;
        #
        #    return undefined;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictTypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictTypeUtil
    PROPERTIES
      Name                #DictTypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class DictTypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(DictType dt, ExtendedTypeId potentialAncestorId)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeUtil::is(dt.id(), potentialAncestorId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeUtil::isInteger(dt.id());
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isLengthEnough
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnough(DictType dt, int len)
        #{
        #    boolean ret;
        #
        #    int sLen;
        #    int dtStringLen;
        #
        #    if( dt )
        #    {
        #        dtStringLen = dt.stringLen();
        #        ret = (dtStringLen <= Len);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnoughOrWarning
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnoughOrWarning(DictType dt, int len)
        #{
        #    boolean ret = DictTypeUtil::isLengthEnough(dt, len);
        #
        #    if( dt && !ret )
        #    {
        #        // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #        Warning(strfmt('Строка с длиной %1 не помещается в тип %2. Обратитесь к разработчикам.', len, DictTypeUtil::name(dt)));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isNumeric(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isString(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(DictType dt)
        #{
        #    boolean ret;
        #
        #    if( dt )
        #    {
        #        ret = TypeUtil::isUndefined(dt.baseType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #public static str name(DictType dt)
        #{
        #    str ret;
        #
        #    if( dt )
        #    {
        #        ret = ExtendedTypeId2name(dt.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ExtendedTypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ExtendedTypeUtil
    PROPERTIES
      Name                #ExtendedTypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ExtendedTypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #dictType
        #public static DictType dictType(ExtendedTypeId id)
        #{
        #    DictType dt;
        #
        #    if( id )
        #    {
        #        dt = new DictType(id);
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от Global::isType():
        #// 1. итерация, а не рекурсия.
        #// 2. минимальное число создаваемых в памяти объектов
        #public static boolean is(ExtendedTypeId id, ExtendedTypeId potentialAncestorId)
        #{
        #    DictType dictType;
        #    ;
        #
        #    while( id && potentialAncestorId )
        #    {
        #        if( id == potentialAncestorId )
        #        {
        #            return true;
        #        }
        #
        #        dictType = new DictType(id);
        #
        #        if( dictType )
        #        {
        #            id = dictType.extend();
        #        }
        #        else
        #        {
        #            id = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isInteger(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnough
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnough(ExtendedTypeId id, int len)
        #{
        #    DictType    dt  = new DictType(id);
        #    boolean     ret = DictTypeUtil::isLengthEnough(dt, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isLengthEnoughOrWarning
        #// строка помещается в указанный тип?
        #public static boolean isLengthEnoughOrWarning(ExtendedTypeId id, int len)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isLengthEnough(dt, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isNumeric(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isString(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(ExtendedTypeId id)
        #{
        #    DictType dt = new DictType(id);
        #    boolean ret = DictTypeUtil::isUndefined(dt);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #public static str name(ExtendedTypeId id)
        #{
        #    str ret = ExtendedTypeId2name(id);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sysDictType
        #public static SysDictType sysDictType(ExtendedTypeId id)
        #{
        #    SysDictType dt;
        #
        #    if( id )
        #    {
        #        dt = new SysDictType(id);
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TypeUtil
    PROPERTIES
      Name                #TypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #integerTypes
        #public static container integerTypes()
        #{
        #    return [Types::Integer, Types::Int64, Types::Date, Types::Time];
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Types type, Types expectedType)
        #{
        #    boolean ret = (type == expectedType || expectedType == Types::AnyType); // TypeUtil::isEqualOrAnytype(type, expectedType)
        #
        #    if( !ret )
        #    {
        #        ret = TypeUtil::isString(type) && TypeUtil::isString(expectedType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEqualOrAnytype
        #public static boolean isEqualOrAnytype(Types type, Types expectedType)
        #{
        #    boolean ret = (type == expectedType || expectedType == Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInteger
        #public static boolean isInteger(Types type)
        #{
        #    boolean ret = confind(TypeUtil::integerTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNumeric
        #public static boolean isNumeric(Types type)
        #{
        #    boolean ret = confind(TypeUtil::numericTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPrimitive
        #public static boolean isPrimitive(Types type)
        #{
        #    boolean ret;
        #
        #    switch( type )
        #    {
        #        case Types::String:
        #        case Types::Integer:
        #        case Types::Real:
        #        case Types::Date:
        #        case Types::Enum:
        #        case Types::UtcDateTime:
        #        case Types::RString:
        #        case Types::VarString:
        #        case Types::UserType:
        #        case Types::Guid:
        #        case Types::Int64:
        #        case Types::Time:
        #        case Types::Container:
        #            ret = true;
        #
        #        /*
        #        case Types::Record:
        #        case Types::AnyType:
        #        case Types::BLOB:
        #        case Types::Class:
        #        case Types::void:
        #            return false;
        #        */
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(Types type)
        #{
        #    boolean ret = (type != Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isString
        #public static boolean isString(Types type)
        #{
        #    boolean ret = confind(TypeUtil::stringTypes(), type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isUndefined
        #public static boolean isUndefined(Types type)
        #{
        #    boolean ret = (type == Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #numericTypes
        #public static container numericTypes()
        #{
        #    return [Types::Real, Types::Integer, Types::Int64];
        #}
      ENDSOURCE
      SOURCE #stringTypes
        #public static container stringTypes()
        #{
        #    return [Types::String, Types::RString, Types::VarString];
        #}
      ENDSOURCE
      SOURCE #undefined
        #public static Types undefined()
        #{
        #    return Types::AnyType;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ClrTypeUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ClrTypeUtil
    PROPERTIES
      Name                #ClrTypeUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ClrTypeUtil
        #{
        #}
      ENDSOURCE
      SOURCE #asInstance
        #public static System.Object asInstance(System.Object obj, System.Object baseObj)
        #{
        #    if( ClrTypeUtil::isInstance(obj, baseObj) )
        #    {
        #        return obj;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asInstanceOrBase
        #public static System.Object asInstanceOrBase(System.Object obj, System.Object baseObj)
        #{
        #    if( ClrTypeUtil::isInstance(obj, baseObj) )
        #    {
        #        return obj;
        #    }
        #
        #    return baseObj;
        #}
        #
      ENDSOURCE
      SOURCE #isInstance
        #public static boolean isInstance(System.Object obj, System.Object baseObj)
        #{
        #    anytype perm = new InteropPermission(Interopkind::ClrInterop).assert();
        #
        #    System.Type baseType = baseObj ? baseObj.GetType() : null;
        #    boolean     ret      = baseType && obj ? baseType.IsInstanceOfType(obj) : false;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name
        #public static str name(System.Object obj)
        #{
        #    anytype perm = new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    System.Type type = obj ? obj.GetType() : null;
        #    str typeName = type ? type.get_Name() : '';
        #
        #    return typeName;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrUtil
    PROPERTIES
      Name                #StrUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StrUtil
        #{
        #}
      ENDSOURCE
      SOURCE #after
        #// возвращает подстроку, которая находится после первого вхожения подстроки
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      StringUtil::after('ABC-DEF-GH','DEF-') == 'GH'
        #//      StringUtil::after('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str after(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+strlen(txt), len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterChar
        #// возвращает подстроку, которая находится после первого вхожения любого из указанных символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'DEF-GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterLast
        #// возвращает подстроку, которая находится после последнего вхожения подстроки
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','DEF') == 'GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterLast(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+strlen(txt), len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #afterLastChar
        #// возвращает подстроку, которая находится после последнего вхожения одного из символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'GH'
        #//      strBefore('ABC-DEF-GH',',')  == 'ABC-DEF-GH'
        #//
        #static str afterLastChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = substr(s, pos+1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #before
        #// возвращает подстроку, которая находится до первого вхожения подстроки
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','DEF') == 'ABC-'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str before(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeChar
        #// возвращает подстроку, которая находится до первого вхожения одного из символов characters
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'ABC'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, 1, len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeLast
        #// возвращает подстроку, которая находится до последнего вхожения подстроки
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-DEFGH','-=') == 'ABC-DEF-'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeLast(str s, str txt)
        #{
        #    int len = strlen(s);
        #    int pos = strscan(s, txt, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #        ret = StrUtil::strLeft(s, pos-1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #beforeLastChar
        #// возвращает подстроку, которая находится до последнего вхожения одного из символов characters
        #// возвращает пустую строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      strBefore('ABC-DEF-GH','-=') == 'ABC'
        #//      strBefore('ABC-DEF-GH',',')  == ''
        #//
        #static str beforeLastChar(str s, str characters)
        #{
        #    int len = strlen(s);
        #    int pos = strfind(s, characters, len, -len);
        #    str ret = s;
        #
        #    if(pos)
        #    {
        #        ret = StrUtil::strLeft(s, pos-1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #char
        #public static str char(int n)
        #{
        #    str ret = num2char(n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #char2num
        #public static int char2num(str text, int position)
        #{
        #    int ret = char2num(text, position);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #// удалить первые n символов, если n > 0
        #// удалить последние n символов, если n < 0
        #// оставить исходную строку, если n == 0
        #public static str drop(str s, int n)
        #{
        #    if(n == 0)
        #        return s;
        #
        #    if(n < 0)
        #        return substr(s, 1, strlen(s)+n);
        #
        #    return substr(s, n+1, strlen(s)-n);
        #}
      ENDSOURCE
      SOURCE #end
        #// возвращает подстроку заданной длины справа
        #//
        #// по идее, различие между strRight и end должно проявляться на текстах с разным направлением письма
        #static str end(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #find
        #public static int find(
        #    str text,
        #    str charsToFind,
        #    int position = 1,
        #    int number   = strlen(text))
        #{
        #    int ret = strfind(text, charsToFind, position, number);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #static str first(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #formatClarification
        #// добавляет к строке разъяснение в скобках, если разъяснение есть
        #public static str formatClarification(
        #    str     s,
        #    str     clarification,
        #    str     clarificationFormat     = "%1 (%2)")
        #{
        #    if( clarification )
        #    {
        #        s = strfmt(clarification, s, clarificationFormat);
        #    }
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #hexDump
        #public static str hexDump(str s)
        #{
        #    int         i;
        #    str         hex;
        #    int         len     = strlen(s);
        #    TextBuffer  ret     = new TextBuffer();
        #;
        #    for( i=1; i<=len; ++i )
        #    {
        #        if( ret.size() )
        #            ret.appendText(' ');
        #
        #        hex = Int2Hex(char2num(s, i));
        #
        #        if( strlen(hex) mod 2 )
        #        {
        #            ret.appendText('0');
        #        }
        #
        #        ret.appendText(hex);
        #    }
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #isBlank
        #//TODO
        #public static boolean isBlank(str s)
        #{
        #    str ret;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #isEmptyOrBlank
        #//TODO
        #public static boolean isEmptyOrBlank(str s)
        #{
        #    str ret;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #last
        #static str last(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static str newFrom(anytype valueOrCollection, str sep = ',')
        #{
        #    str ret = TextBufferUtil::append(null, valueOrCollection, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #public static str newFromArray(Array arr, str sep = ',')
        #{
        #    ArrayEnumerator ae;
        #    str ret;
        #
        #    if( arr )
        #    {
        #        if( arr.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('Array хранит enum как целые. Используйте Array(Types::Container) и arr.value(i, [Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в массиве. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        ae = ArrayEnumerator::construct(arr);
        #        ret = TextBufferUtil::appendEnumerator(null, ae, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static str newFromContainer(container con, str sep = ',')
        #{
        #    str ret = TextBufferUtil::appendContainer(null, con, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static str newFromList(List list, str sep = ',')
        #{
        #    ListEnumerator le;
        #    str ret;
        #
        #    if( list )
        #    {
        #        if( list.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('List хранит enum как целые. Используйте List(Types::Container) и list.add([Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в списке. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        le = list.getEnumerator();
        #        ret = TextBufferUtil::appendEnumerator(null, le, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromObject
        #public static str newFromObject(Object obj)
        #{
        #    str ret;
        #
        #    if( obj )
        #    {
        #        ret = obj.toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static str newFromSet(Set set, str sep = ',')
        #{
        #    SetEnumerator se;
        #    str ret;
        #
        #    if( set )
        #    {
        #        if( set.typeId() == Types::Enum )
        #        {
        #            warning(strfmt('Set хранит enum как целые. Используйте Set(Types::Container) и set.add([Enum::value]), '+
        #                    'чтобы сохранить полную информацию об enum в множестве. Метод %1 корректно отобразит enum, '+
        #                    'которые хранятся в контейнерах.', funcname()));
        #        }
        #
        #        se = set.getEnumerator();
        #        ret = TextBufferUtil::appendEnumerator(null, se, sep).getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padEnd
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #//
        #// по идее, различие между padRight и padEnd должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #static str padEnd(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = s + strrep(char, l);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padLeft
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padLeft(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = strrep(char, l) + s;
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padRight
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padRight(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = s + strrep(char, l);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padStart
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #//
        #// по идее, различие между padLeft и padStart должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #static str padStart(str s, int len, char char = ' ')
        #{
        #    str ret;
        #    int l = len - strlen(s);
        #
        #    if(l<=0)
        #        return s;
        #
        #    ret = strrep(char, l) + s;
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #scan
        #public static int scan(
        #    str text,
        #    str substrToFind,
        #    int position = 1,
        #    int number   = strlen(text))
        #{
        #    int ret = strscan(text, substrToFind, position, number);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #split
        #// делит строку на подстроки, разделенные строкой delimiterStr
        #// возвращает контейнер подстрок. Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      strSplitCon('ABC:=DEF:=GH',':=')   == ['ABC','DEF','GH']
        #//      strSplitCon('ABC:=DEF:=GH',':=',2) == ['ABC','DEF:=GH']
        #//      strSplitCon('ABC:=DEF:=GH',':=',1) == ['ABC:=DEF:=GH']
        #//
        #// @see StrSplitEnumerator
        #//
        #static container split(str s, str delimiterStr, int maxSubstrings = 0)
        #{
        #    container ret;
        #    int delimiterLen;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiterStr == '' )
        #        return [s];
        #
        #    delimiterLen = strlen(delimiterStr);
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        pos = strscan(s, delimiterStr, posFrom, len);
        #        if( pos == 0 )
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+delimiterLen;
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #splitChar
        #// делит строку на подстроки, разделенные хотя бы одним символом из delimiters (по-умолчанию это пробел, табуляция и перевод строки - whitespaces)
        #// возвращает контейнер подстрок.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #// Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #//
        #// пример:
        #//      strSplitChar('ABC DEF GH')        == ['ABC','DEF','GH']
        #//      strSplitChar('ABC-DEF-GH','-=')   == ['ABC','DEF','GH']
        #//      strSplitChar('ABC-DEF-GH','-=',2) == ['ABC','DEF-GH']
        #//      strSplitChar('ABC-DEF-GH','-=',1) == ['ABC-DEF-GH']
        #//
        #// @see StrSplitEnumerator
        #//
        #static container splitChar(str s, str delimiters = ' \t\n', int maxSubstrings = 0)
        #{
        #    container ret;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiters == '' )
        #        return [s];
        #
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        pos = strfind(s, delimiters, posFrom, len);
        #        if( pos == 0 )
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+1;
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #splitCon
        #// делит строку на подстроки, разделенные хотя бы одной строкой из контейнера delimiterCon (по умолчанию пробел, табуляция и переводы строк - whitespaces)
        #// результат не зависит от порядка разделителей в контейнере.
        #// возвращает контейнер подстрок. Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// возвращает контейнер, содержащий исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      strSplitCon('ABC=DEF:=GH',[':=','='])   == ['ABC','DEF','GH']
        #//      strSplitCon('ABC=DEF:=GH',[':=','='],2) == ['ABC','DEF:=GH']
        #//      strSplitCon('ABC=DEF:=GH',[':=','='],1) == ['ABC=DEF:=GH']
        #//
        #// @see StrSplitEnumerator
        #//
        #static container splitCon(str s, container delimiterCon = [' ','\t','\n','\r\n','\n\r'], int maxSubstrings = 0)
        #{
        #    container ret;
        #    int d;
        #    str delimiter;
        #    str delimiterStr;
        #    int delimiterPos;
        #    int delimiterLen;
        #    int len;
        #    int posFrom = 1;
        #    int pos;
        #
        #    if( delimiterCon == connull() )
        #        return [s];
        #
        #    len = strlen(s);
        #    do
        #    {
        #        maxSubstrings--;
        #        if( maxSubstrings == 0 )
        #            break;
        #
        #        delimiter = conpeek(delimiterCon, 1);       // проверка выше гарантирует, что хотя бы один разделитель у нас есть
        #        pos = strscan(s, delimiter, posFrom, len);  // позиция первого разделителя
        #        for(d = 2; d <= conlen(delimiterCon); d++)  // позиции разделителей после первого
        #        {
        #            delimiterStr = conpeek(delimiterCon, d);
        #            delimiterPos = strscan(s, delimiterStr, posFrom, len);
        #            if( delimiterPos == 0 )
        #                continue;
        #
        #            if( pos && pos < delimiterPos )
        #                continue;
        #
        #            if( pos == delimiterPos && strlen(delimiter) >= strlen(delimiterStr) )
        #                continue;
        #
        #            // берем разделитель с минимальной позицией
        #            // если позиция совпадает, то берем разделитель с максимальной длиной
        #            delimiter = delimiterStr;
        #            pos = delimiterPos;
        #        }
        #        if( pos == 0 )  // разделители не найдены
        #            break;
        #
        #        ret += substr(s, posFrom, pos-posFrom);
        #        posFrom = pos+strlen(delimiter);
        #    }
        #    while( maxSubstrings );
        #
        #    ret += substr(s, posFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #start
        #// возвращает подстроку заданной длины слева
        #//
        #// по идее, различие между strLeft и start должно проявляться на текстах с разным направлением письма
        #// но в аксапте никаких различий нет
        #//
        #static str start(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #strLeft
        #// возвращает подстроку заданной длины слева
        #//
        #// в X++ есть ключевое слово left. Поэтому обявить метод с именем left нельзя
        #static str strLeft(str s, int len)
        #{
        #    str ret;
        #
        #    if( len <= 0 )
        #        return '';
        #
        #    ret = substr(s, 1, len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #strRight
        #// возвращает подстроку заданной длины справа
        #static str strRight(str s, int len)
        #{
        #    str ret;
        #
        #    if( len<=0 )
        #        return '';
        #
        #    ret = substr(s, strlen(s), -len);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #// возвращает подстроку заданной длины с указанного символа
        #// len может быть отрицательным числом.
        #static str take(str s, int len, int startFrom = 1)
        #{
        #    str ret = substr(s, startFrom, len);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trim
        #// убирает указанные символы в начале и в конце строки
        #// по умолчанию, убирает пробелы, табуляцию и переводы строк
        #static str trim(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #    int len = strlen(s);
        #    int fromPos = strnfind(s, ws, 1, len);
        #    int toPos = strnfind(s, ws, len, -len);
        #
        #    if( fromPos && fromPos <= toPos )
        #    {
        #        ret = substr(s, fromPos, toPos - fromPos + 1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimEnd
        #//TODO
        #public static str trimEnd(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static str trimIndent(str s)
        #{
        #    return TextUtil::trimIndent(s);
        #}
      ENDSOURCE
      SOURCE #trimStart
        #//TODO
        #public static str trimStart(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrUtilTest
    PROPERTIES
      Name                #StrUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class StrUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testDrop_0
        #void testDrop_0()
        #{
        #    this.assertEquals('abcdefgh', StrUtil::drop('abcdefgh', 0));
        #}
      ENDSOURCE
      SOURCE #testDrop_Minus
        #void testDrop_Minus()
        #{
        #    this.assertEquals('abcde', StrUtil::drop('abcdefgh', -3));
        #}
      ENDSOURCE
      SOURCE #testDrop_Plus
        #void testDrop_Plus()
        #{
        #    this.assertEquals('defgh', StrUtil::drop('abcdefgh', 3));
        #}
      ENDSOURCE
      SOURCE #testHexDump
        #void testHexDump()
        #{
        #    this.assertEquals('20 0A', StrUtil::hexDump(' \n'));
        #}
      ENDSOURCE
      SOURCE #testHexDump_Unicode
        #void testHexDump_Unicode()
        #{
        #    this.assertEquals('042E 042F', StrUtil::hexDump('ЮЯ'));
        #}
      ENDSOURCE
      SOURCE #testPadLeft
        #void testPadLeft()
        #{
        #    this.assertEquals('  ABC', StrUtil::padLeft('ABC',5));
        #    this.assertEquals('==ABC', StrUtil::padLeft('ABC',5,'='));
        #    this.assertEquals('==ABC', StrUtil::padLeft('ABC',5,'=Z'));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',3,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',2,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',0,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',-1,'='));
        #    this.assertEquals('ABC',   StrUtil::padLeft('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testPadRight
        #void testPadRight()
        #{
        #    this.assertEquals('ABC  ', StrUtil::padRight('ABC',5));
        #    this.assertEquals('ABC==', StrUtil::padRight('ABC',5,'='));
        #    this.assertEquals('ABC==', StrUtil::padRight('ABC',5,'=Z'));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',3,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',2,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',0,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',-1,'='));
        #    this.assertEquals('ABC',   StrUtil::padRight('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testSplit
        #void testSplit()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':='));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',0));
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH',':=',1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::split('ABC:=DEF:=GH',':=',2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::split('ABC:=DEF:=GH',':=',4));
        #
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH',''));
        #    this.assertEquals(['ABC:=DEF:=GH'],         StrUtil::split('ABC:=DEF:=GH','',4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::split(':=ABC:=DEF:=GH:=',':='));
        #
        #    this.assertEquals([''], StrUtil::split('',':='));
        #    this.assertEquals([''], StrUtil::split('',''));
        #}
      ENDSOURCE
      SOURCE #testSplitChar
        #void testSplitChar()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-='));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',0));
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH','-=',1));
        #    this.assertEquals(['ABC','DEF-GH'],         StrUtil::splitChar('ABC-DEF-GH','-=',2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitChar('ABC-DEF-GH','-=',4));
        #
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH',''));
        #    this.assertEquals(['ABC-DEF-GH'],           StrUtil::splitChar('ABC-DEF-GH','',4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitChar('-ABC-DEF-GH-','-='));
        #
        #}
      ENDSOURCE
      SOURCE #testSplitCon
        #void testSplitCon()
        #{
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','=']));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],0));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',[':=','='],1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::splitCon('ABC=DEF:=GH',[':=','='],2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',[':=','='],4));
        #
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':=']));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],0));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',['=',':='],1));
        #    this.assertEquals(['ABC','DEF:=GH'],        StrUtil::splitCon('ABC=DEF:=GH',['=',':='],2));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],3));
        #    this.assertEquals(['ABC','DEF','GH'],       StrUtil::splitCon('ABC=DEF:=GH',['=',':='],4));
        #
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',connull()));
        #    this.assertEquals(['ABC=DEF:=GH'],          StrUtil::splitCon('ABC=DEF:=GH',connull(),4));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC=DEF:=GH=',[':=','=']));
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC=DEF:=GH=',['=',':=']));
        #
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC:DEF:=GH:',[':=',':']));
        #    this.assertEquals(['','ABC','DEF','GH',''], StrUtil::splitCon(':=ABC:DEF:=GH:',[':',':=']));
        #}
      ENDSOURCE
      SOURCE #testStrAfter
        #void testStrAfter()
        #{
        #    this.assertEquals('DEF-GH',    StrUtil::after('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',        StrUtil::after('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',          StrUtil::after('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::after('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::after('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterChar
        #void testStrAfterChar()
        #{
        #    this.assertEquals('DEF-GH',    StrUtil::afterChar('ABC-DEF-GH','-='));
        #    this.assertEquals('DEF-GH',    StrUtil::afterChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::afterChar('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterChar('ABC-DEF-GH','A-='));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterLast
        #void testStrAfterLast()
        #{
        #    this.assertEquals('GH',        StrUtil::afterLast('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',        StrUtil::afterLast('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',          StrUtil::afterLast('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrAfterLastChar
        #void testStrAfterLastChar()
        #{
        #    this.assertEquals('GH',        StrUtil::afterLastChar('ABC-DEF-GH','-='));
        #    this.assertEquals('GH',        StrUtil::afterLastChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::afterLastChar('ABC-DEF-GH','H-='));
        #    this.assertEquals('BC-DEF-GH', StrUtil::afterLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::afterLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBefore
        #void testStrBefore()
        #{
        #    this.assertEquals('ABC',       StrUtil::before('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC',       StrUtil::before('ABC-DEF-GH','-DEF'));
        #    this.assertEquals('',          StrUtil::before('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G', StrUtil::before('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::before('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeChar
        #void testStrBeforeChar()
        #{
        #    this.assertEquals('ABC',       StrUtil::beforeChar('ABC-DEF-GH','-='));
        #    this.assertEquals('ABC',       StrUtil::beforeChar('ABC-DEF-GH','E-='));
        #    this.assertEquals('',          StrUtil::beforeChar('ABC-DEF-GH','A-='));
        #    this.assertEquals('ABC-DEF-G', StrUtil::beforeChar('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeLast
        #void testStrBeforeLast()
        #{
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLast('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC'       ,StrUtil::beforeLast('ABC-DEF-GH','-DEF'));
        #    this.assertEquals(''          ,StrUtil::beforeLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G' ,StrUtil::beforeLast('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrBeforeLastChar
        #void testStrBeforeLastChar()
        #{
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLastChar('ABC-DEF-GH','-='));
        #    this.assertEquals('ABC-DEF'   ,StrUtil::beforeLastChar('ABC-DEF-GH','E-='));
        #    this.assertEquals(''          ,StrUtil::beforeLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G' ,StrUtil::beforeLastChar('ABC-DEF-GH','H-='));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::beforeLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testStrLeft
        #void testStrLeft()
        #{
        #    this.assertEquals('ABC',        StrUtil::strLeft('ABC-DEF-GH',3));
        #    this.assertEquals('',           StrUtil::strLeft('ABC-DEF-GH',0));
        #    this.assertEquals('',           StrUtil::strLeft('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH', StrUtil::strLeft('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testStrLFix
        #//TODO ???
        #void testStrLFix()
        #{
        #    this.assertEquals('ABC  ',strLFix('ABC',5));
        #    this.assertEquals('ABC==',strLFix('ABC',5,'='));
        #    this.assertEquals('ABC==',strLFix('ABC',5,'=Z'));
        #    this.assertEquals('ABC',strLFix('ABC',3,'='));
        #    this.assertEquals('AB',strLFix('ABC',2,'='));
        #    this.assertEquals('',strLFix('ABC',0,'='));
        #    this.assertEquals('A',strLFix('ABC',-1,'='));
        #    this.assertEquals('A',strLFix('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testStrRFix
        #// TODO ???
        #void testStrRFix()
        #{
        #    this.assertEquals('  ABC',strRFix('ABC',5));
        #    this.assertEquals('==ABC',strRFix('ABC',5,'='));
        #    this.assertEquals('==ABC',strRFix('ABC',5,'=Z'));
        #    this.assertEquals('ABC',strRFix('ABC',3,'='));
        #    this.assertEquals('AB',strRFix('ABC',2,'='));
        #    this.assertEquals('',strRFix('ABC',0,'='));
        #    this.assertEquals('A',strRFix('ABC',-1,'='));
        #    this.assertEquals('A',strRFix('ABC',-5,'='));
        #}
      ENDSOURCE
      SOURCE #testStrRight
        #void testStrRight()
        #{
        #    this.assertEquals('DEF-GH'    ,StrUtil::strRight('ABC-DEF-GH',6));
        #    this.assertEquals(''          ,StrUtil::strRight('ABC-DEF-GH',0));
        #    this.assertEquals(''          ,StrUtil::strRight('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH',StrUtil::strRight('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testTrim
        #void testTrim()
        #{
        #    this.assertEquals('ABC', StrUtil::trim('ABC  '));
        #    this.assertEquals('ABC', StrUtil::trim('  ABC'));
        #    this.assertEquals('ABC', StrUtil::trim('ABC  \r\n  '));
        #    this.assertEquals('ABC', StrUtil::trim('  \r\n  ABC'));
        #    this.assertEquals('ABC', StrUtil::trim('  \r\n  ABC  \r\n  '));
        #    this.assertEquals('ABC', StrUtil::trim(@'ABC
        #    '));
        #    this.assertEquals('ABC', StrUtil::trim(@'
        #    ABC'));
        #    this.assertEquals('ABC', StrUtil::trim(@'
        #    ABC
        #    '));
        #    this.assertEquals('A',   StrUtil::trim('  A  '));
        #
        #    this.assertEquals('ABC', StrUtil::trim('==ABC==','='));
        #    this.assertEquals('A',   StrUtil::trim('==A==','='));
        #
        #
        #    this.assertEquals('',    StrUtil::trim('  '));
        #    this.assertEquals('',    StrUtil::trim('  \r\n  '));
        #    this.assertEquals('',    StrUtil::trim(@'
        #    '));
        #
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextBufferUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextBufferUtil
    PROPERTIES
      Name                #TextBufferUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TextBufferUtil
        #{
        #}
      ENDSOURCE
      SOURCE #append
        #public static TextBuffer append(TextBuffer textOrNull, anytype valueOrCollection, str sep = ',')
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    TextBuffer text = TextBufferUtil::appendEnumerator(null, e, sep);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendCallStack
        #// отображаем как в отладчике
        #public static TextBuffer appendCallStack(TextBuffer text, int skip = 1, container callStack = xSession::xppCallStack())
        #{
        #    int len   = conLen(callStack);
        #    int start = max(2, skip*2+2);
        #    int i;
        #
        #    if( !text )
        #    {
        #        text = new TextBuffer();
        #    }
        #
        #    for( i=start; i<=len; i+=2 )
        #    {
        #        text.appendText(strfmt('\n%1 - line %2', conPeek(callStack, i-1), conPeek(callStack, i)));
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendCollectionItem
        #public static TextBuffer appendCollectionItem(TextBuffer text, str s, str sep=',')
        #{
        #    text = TextBufferUtil::appendIfNotEmpty(text, sep);
        #    text = TextBufferUtil::appendStr(text, s);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendContainer
        #public static TextBuffer appendContainer(TextBuffer textOrNull, container con, str sep = ',')
        #{
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #    TextBuffer text = TextBufferUtil::appendEnumerator(textOrNull, ce, sep);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendContainerAsCollectionItem
        #public static TextBuffer appendContainerAsCollectionItem(TextBuffer textOrNull, container con, str sep = ',', str itemSeparator = '\n')
        #{
        #    ;
        #
        #    textOrNull = TextBufferUtil::appendIfNotEmpty(textOrNull, itemSeparator);
        #    textOrNull = TextBufferUtil::appendContainer(textOrNull, con, sep);
        #
        #    return textOrNull;
        #}
      ENDSOURCE
      SOURCE #appendEnumerator
        #public static TextBuffer appendEnumerator(TextBuffer textOrNull, Enumerator e, str sep = ',')
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #    boolean tail;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( tail && sep )
        #        {
        #            text.appendText(sep);
        #        }
        #
        #        text.appendText(AnytypeUtil::toString(e.current()));
        #
        #        tail = true;
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendFromSelect
        #// добавляет множество значений поля из буфера, который был заполнен командой select
        #public static TextBuffer appendFromSelect(TextBuffer textOrNull, Common selectedRecord, FieldId fieldId, str sep = ',')
        #{
        #    RecordEnumerator e = RecordEnumerator::construct(selectedRecord);
        #    TextBuffer text = TextBufferUtil::appendEnumerator(textOrNull, e, sep);
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendIfNotEmpty
        #public static TextBuffer appendIfNotEmpty(TextBuffer text, str s)
        #{
        #    if( s && text && text.size() )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendIfNotNull
        #// append if eXists - добавить текст только если TextBuffer уже создан и существует
        #public static TextBuffer appendIfNotNull(TextBuffer text, str s)
        #{
        #    if( s && text )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendInfolog
        #public static TextBuffer appendInfolog(TextBuffer textOrNull, InfologData info = infolog.export(), str newLine = '\n')
        #{
        #    TextBuffer              text = TextBufferUtil::nonNull(textOrNull);
        #    boolean                 firstLine = true;
        #    SysInfologEnumerator    sysInfologEnumerator;
        #    SysInfologMessageStruct messageStruct;
        #    SysInfoLogStr           message;
        #
        #    if (info)
        #    {
        #        sysInfologEnumerator = SysInfologEnumerator::newData(info);
        #        while (sysInfologEnumerator.moveNext())
        #        {
        #            if (!firstLine && newLine)
        #            {
        #                text.appendText(newline);
        #            }
        #
        #            messageStruct = SysInfologMessageStruct::construct(sysInfologEnumerator.currentMessage());
        #            message = messageStruct.message();
        #            if (message)
        #            {
        #                text.appendText(message);
        #                firstLine = false;
        #            }
        #        }
        #    }
        #
        #    return text;
        #}
        #
      ENDSOURCE
      SOURCE #appendInfologWithPrefixes
        #public static TextBuffer appendInfologWithPrefixes(TextBuffer textOrNull, InfologData info = infolog.export(), str newLine = '\n')
        #{
        #    TextBuffer              text = TextBufferUtil::nonNull(textOrNull);
        #    boolean                 firstLine = true;
        #    SysInfologEnumerator    sysInfologEnumerator;
        #    SysInfoLogStr           message;
        #
        #    if (info)
        #    {
        #        sysInfologEnumerator = SysInfologEnumerator::newData(info);
        #        while (sysInfologEnumerator.moveNext())
        #        {
        #            if (!firstLine && newLine)
        #            {
        #                text.appendText(newline);
        #            }
        #
        #            message = sysInfologEnumerator.currentMessage();
        #            if (message)
        #            {
        #                text.appendText(message);
        #                firstLine = false;
        #            }
        #        }
        #    }
        #
        #    return text;
        #}
        #
      ENDSOURCE
      SOURCE #appendStr
        #public static TextBuffer appendStr(TextBuffer textOrNull, str s)
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #
        #    if( s )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #calcIndent
        #// рассчитывает бощий отступ, который может быть применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// при расчете игнорирует пустые и пробельные строки (строки, содержащие только пробелы)
        #public static int calcIndent(TextBuffer text)
        #{
        #    int     ident;
        #    int     lineIndent;
        #    int     startPos    = 1;
        #
        #    if( !text )
        #        return 0;
        #
        #    if( !text.size() )
        #        return 0;
        #
        #    ident = maxint();
        #
        #    ///////////////////
        #    if( text.find('< +') )
        #    {
        #        lineIndent = text.matchLen();
        #        startPos = text.matchPos() + text.matchLen();
        #    }
        #
        #    while( text.find('\n *', startPos) )
        #    {
        #        // вторая половина условия срабатывает толкьо для непробельных строк
        #        if( lineIndent < ident && startPos != text.matchPos() )
        #        {
        #            ident = lineIndent;
        #        }
        #
        #        lineIndent = text.matchLen() - 1;
        #        startPos = text.matchPos() + text.matchLen();
        #    }
        #
        #    if( lineIndent < ident && startPos <= text.size() )
        #    {
        #        ident = lineIndent;
        #    }
        #    else if( ident == maxint() )
        #    {
        #        ident = lineIndent;
        #    }
        #
        #    return ident;
        #}
      ENDSOURCE
      SOURCE #changeIndent
        #// добавляет или удаляет отступ слева у каждой строки в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #// возвращает измененный TextBuffer, не создает копию если TextBuffer уже создан
        #// возвращаемый объект никогда не равен null
        #//
        #// text - исходный текст, в котором метод изменяет отступы
        #// identOffset - положительное значение увеличивает отступ, отрицательное значение уменьшает отступ, нулевое значение не меняет текст
        #//
        #public static TextBuffer changeIndent(TextBuffer textOrNull, int indentOffset)
        #{
        #    TextBuffer text = TextBufferUtil::nonNull(textOrNull);
        #
        #    if( text.size() == 0 )
        #        return text;
        #
        #    while( indentOffset < 0 )
        #    {
        #        text.replace('< ', '');
        #        text.replace('\n ', '\n');
        #        indentOffset++;
        #    }
        #
        #    while( indentOffset > 0 )
        #    {
        #        text.insert(' ', 1);
        #        text.replace('\n', '\n ');
        #        indentOffset--;
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #getText
        #public static str getText(TextBuffer text)
        #{
        #    str ret;
        #
        #    if( text )
        #    {
        #        ret = text.getText();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static TextBuffer newFrom(TextBuffer textOrNull)
        #{
        #    TextBuffer text = new TextBuffer();
        #
        #    if( textOrNull && textOrNull.size() )
        #    {
        #        text.setText(textOrNull.getText());
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static TextBuffer newFromStr(str s)
        #{
        #    TextBuffer text = new TextBuffer();
        #
        #    if( s )
        #    {
        #        text.appendText(s);
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static TextBuffer nonNull(TextBuffer text)
        #{
        #    if( !text )
        #    {
        #        text = new TextBuffer();
        #    }
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет общий для всех строк отступ в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #//
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static TextBuffer trimIndent(TextBuffer text)
        #{
        #    TextBuffer  ret     = new TextBuffer();
        #    int         startPos;
        #    int         endPos;
        #    int         len;
        #    int         indent;
        #;
        #    if( text == null )
        #        return ret;
        #
        #    if( text.size() == 0 )
        #        return ret;
        #
        #    // удаляем первую пустую или пробельную строку
        #    if( text.find('< *\n') )
        #        startPos = text.matchPos() + text.matchLen();
        #    else
        #        startPos = 1;
        #
        #    // удаляем последнюю пустую или пробельную строку
        #    if( text.find('\n *>') )
        #        endPos = text.matchPos() - 1;
        #    else
        #        endPos = text.size();
        #
        #    len = endPos - startPos + 1;
        #
        #    if( len <= 0 )
        #        return ret;
        #
        #    if( len == text.size() )
        #        ret = text;
        #    else
        #        ret.setText(text.subStr(startPos, len));
        #
        #    indent = TextBufferUtil::calcIndent(ret);
        #
        #    if( indent == 0 )
        #        return ret;
        #
        #    ret = TextBufferUtil::changeIndent(ret, -indent);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextBufferUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextBufferUtilTest
    PROPERTIES
      Name                #TextBufferUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysString
        #//
        #class TextBufferUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testCalcIndent
        #void testCalcIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #                ABC
        #                    123
        #                456
        #    ');
        #
        #    this.assertEquals(16, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1
        #void testCalcIndent_1()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC');
        #
        #    this.assertEquals(2, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1_Blank
        #void testCalcIndent_1_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ');
        #
        #    this.assertEquals(2, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1_NoIndent
        #void testCalcIndent_1_NoIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'ABC  ');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_2_Blank
        #void testCalcIndent_2_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_3_Blank
        #void testCalcIndent_3_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_4_Blank
        #void testCalcIndent_4_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #
        #');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_BlankLine
        #void testCalcIndent_BlankLine()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #                ABC
        #
        #                    123
        #                456
        #
        #    ');
        #
        #    this.assertEquals(16, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Disorder
        #void testCalcIndent_Disorder()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #                 ABC
        #                  123
        #               456
        #        ');
        #
        #    this.assertEquals(15, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Empty
        #void testCalcIndent_Empty()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr('');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_First
        #void testCalcIndent_First()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC
        #                123
        #                456
        #        ');
        #
        #    this.assertEquals(2, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_First_NoIndent
        #void testCalcIndent_First_NoIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'0  ABC
        #                123
        #                456
        #        ');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Last
        #void testCalcIndent_Last()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #                ABC
        #                123
        #    456');
        #
        #    this.assertEquals(4, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_NoIndent
        #void testCalcIndent_NoIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #ABC
        #123
        #456
        #        ');
        #
        #    this.assertEquals(0, TextBufferUtil::calcIndent(text));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Null
        #void testCalcIndent_Null()
        #{
        #    this.assertEquals(0, TextBufferUtil::calcIndent(null));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent
        #void testChangeIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ABC
        #        123
        #    456
        #    ');
        #
        #    this.assertEquals('\nABC\n    123\n456\n', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1
        #void testChangeIndent_1()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC');
        #
        #    this.assertEquals('ABC', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1_Blank
        #void testChangeIndent_1_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ');
        #
        #    this.assertEquals('', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1_NoIndent
        #void testChangeIndent_1_NoIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'ABC  ');
        #
        #    this.assertEquals('ABC  ', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_AddIndent
        #void testChangeIndent_AddIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ABC
        #        123
        #    456
        #    ');
        #
        #    this.assertEquals('    \n        ABC\n            123\n        456\n        ', TextBufferUtil::changeIndent(text, 4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_BlankLine
        #void testChangeIndent_BlankLine()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #    ABC
        #
        #        123
        #456
        #
        #    ');
        #
        #    this.assertEquals('\n\nABC\n\n    123\n456\n\n', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_BlankLine_AddIndent
        #void testChangeIndent_BlankLine_AddIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #    ABC
        #
        #        123
        #456
        #
        #    ');
        #
        #    this.assertEquals('    \n    \n        ABC\n    \n            123\n    456\n    \n        ', TextBufferUtil::changeIndent(text, 4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Empty
        #void testChangeIndent_Empty()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr('');
        #
        #    this.assertEquals('', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_First
        #void testChangeIndent_First()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC
        #    123
        #    456
        #');
        #
        #    this.assertEquals('ABC\n123\n456\n', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Last
        #void testChangeIndent_Last()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'ABC
        #    123
        #    456  ');
        #
        #    this.assertEquals('ABC\n123\n456  ', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Null
        #void testChangeIndent_Null()
        #{
        #    this.assertEquals('', TextBufferUtil::changeIndent(null, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_OverIndent
        #void testChangeIndent_OverIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ABC
        #        123
        #456
        #    ');
        #
        #    this.assertEquals('\nABC\n    123\n456\n', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_UnderIndent
        #void testChangeIndent_UnderIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #        ABC
        #            123
        #        456
        #    ');
        #
        #    this.assertEquals('\n    ABC\n        123\n    456\n', TextBufferUtil::changeIndent(text, -4).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_ZeroIndent
        #void testChangeIndent_ZeroIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ABC
        #        123
        #    456
        #    ');
        #
        #    this.assertEquals('\n    ABC\n        123\n    456\n    ', TextBufferUtil::changeIndent(text, 0).getText());
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_ZeroIndent_BlankLine
        #void testChangeIndent_ZeroIndent_BlankLine()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr('  \n    ABC\n    ');
        #
        #    this.assertEquals('  \n    ABC\n    ', TextBufferUtil::changeIndent(text, 0).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent
        #void testTrimIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ABC
        #        123
        #    456
        #    ');
        #
        #    this.assertEquals('ABC\n    123\n456', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1
        #void testTrimIndent_1()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC');
        #
        #    this.assertEquals('ABC', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1_Blank
        #void testTrimIndent_1_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ');
        #
        #    str res = TextBufferUtil::trimIndent(text).getText();
        #
        #    this.assertEquals(0, strlen(res));
        #    this.assertEquals('', res);
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1_NoIndent
        #void testTrimIndent_1_NoIndent()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'ABC  ');
        #
        #    this.assertEquals('ABC  ', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_2_Blank
        #void testTrimIndent_2_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #    ');
        #
        #    str res = TextBufferUtil::trimIndent(text).getText();
        #
        #    this.assertEquals(0, strlen(res));
        #    this.assertEquals('', res);
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_3_Blank
        #void testTrimIndent_3_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #    ');
        #
        #    str res = TextBufferUtil::trimIndent(text).getText();
        #
        #    this.assertEquals(0, strlen(res));
        #    this.assertEquals('', res);
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_4_Blank
        #void testTrimIndent_4_Blank()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #
        #    ');
        #
        #    str res = TextBufferUtil::trimIndent(text).getText();
        #
        #    this.assertEquals(1, strlen(res));
        #    this.assertEquals(10, char2num(res, 1));
        #    this.assertEquals('\n', res);
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_BlankLine
        #void testTrimIndent_BlankLine()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'
        #
        #    ABC
        #
        #        123
        #456
        #
        #    ');
        #
        #    this.assertEquals('\n    ABC\n\n        123\n456\n', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_Empty
        #void testTrimIndent_Empty()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr('');
        #
        #    this.assertEquals('', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_First
        #void testTrimIndent_First()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'  ABC
        #    123
        #    456
        #');
        #
        #    this.assertEquals('ABC\n  123\n  456', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_Last
        #void testTrimIndent_Last()
        #{
        #    TextBuffer text = TextBufferUtil::newFromStr(@'ABC
        #    123
        #    456  ');
        #
        #    this.assertEquals('ABC\n    123\n    456  ', TextBufferUtil::trimIndent(text).getText());
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_Null
        #void testTrimIndent_Null()
        #{
        #    this.assertEquals('', TextBufferUtil::trimIndent(null).getText());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextUtil
    PROPERTIES
      Name                #TextUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс оперирует с текстом - многострочной строкой (multiline string)
        #// если текст содержит только одну строку, то класс работает также как и строковые функции
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class TextUtil
        #{
        #}
      ENDSOURCE
      SOURCE #after
        #// возвращает текст с подстроками, которые находится после первого вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','-') == 'DEF-GH\nLMN-OP'
        #//      TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str after(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*?%1', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterChar
        #// возвращает текст с подстроками, которые находятся после первого вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','-') == 'DEF-GH\nLMN-OP'
        #//      TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*?[%1]', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterLast
        #// возвращает текст с подстроками, которые находятся после последнего вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','-') == 'GH\nOP'
        #//      TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterLast(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)^.*%1', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #afterLastChar
        #// возвращает текст с подстроками, которые находятся после последнего вхожения любого из указанных символов characters
        #// возвращает исходную строку, если ни одного вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','-=') == 'GH\nOP'
        #//      TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP',',')  == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str afterLastChar(str s, str characters)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( characters == '' )
        #        return s;
        #
        #    pattern = strfmt(@'(?m)^.*[%1]', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #appendEnd
        #// добавляет строку в конец каждой подстроки текста
        #//
        #// пример:
        #//      TextUtil::appendEnd('ABC-DEF-GH\nIJK-LMN-OP',';') == 'ABC-DEF-GH;\nIJK-LMN-OP;'
        #//      TextUtil::appendEnd('ABC-DEF-GH',            ';') == 'ABC-DEF-GH;'
        #//      TextUtil::appendEnd('',                      ';') == ';'
        #//
        #public static str appendEnd(str text, str start)
        #{
        #    if( text == '' )
        #        return start;
        #
        #    if( start == '' )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, @'(?m)$', start);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #appendStart
        #// добавляет строку в начало каждой подстроки текста
        #//
        #// пример:
        #//      TextUtil::appendStart('ABC-DEF-GH\nIJK-LMN-OP','* ') == '* ABC-DEF-GH\n* IJK-LMN-OP'
        #//      TextUtil::appendStart('ABC-DEF-GH',            '* ') == '* ABC-DEF-GH'
        #//      TextUtil::appendStart('',                      '* ') == '* '
        #//
        #public static str appendStart(str text, str end)
        #{
        #    if( text == '' )
        #        return end;
        #
        #    if( end == '' )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, @'(?m)^', end);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #before
        #// возвращает текст с подстроками, которые находятся после первого вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','-') == 'ABC\nIJK'
        #//      TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str before(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)%1.*?$', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeChar
        #// возвращает текст с подстроками, которые находятся после первого вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','=-') == 'ABC\nIJK'
        #//      TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)[%1].*?$', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeLast
        #// возвращает текст с подстроками, которые находятся после последнего вхожения подстроки
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','-') == 'ABC-DEF\nIJK-LMN'
        #//      TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP',',') == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeLast(str text, str search)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( search == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)%1(?!.*%1).*$', search);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #beforeLastChar
        #// возвращает текст с подстроками, которые находятся после последнего вхожения любого из указанных символов characters
        #// возвращает исходный текст, если вхождения не найдено
        #//
        #// пример:
        #//      TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','=-') == 'ABC-DEF\nIJK-LMN'
        #//      TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP',',')  == 'ABC-DEF-GH\nIJK-LMN-OP'
        #//
        #static str beforeLastChar(str text, str characters)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( characters == '' )
        #        return text;
        #
        #    pattern = strfmt(@'(?m)[%1](?!.*[%1]).*$', characters);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #calcIndent
        #// рассчитывает отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как один непробельный значащий символ
        #public static int calcIndent(str text)
        #{
        #    int indent = maxint();
        #    int i;
        #
        #    System.Text.RegularExpressions.Match            rMatch;
        #    System.Text.RegularExpressions.GroupCollection  rGroupCollection;
        #    System.Text.RegularExpressions.Group            rGroup;
        #
        #    if( text == '' )
        #        return 0;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    rMatch = System.Text.RegularExpressions.Regex::Match(text, @'^(\r?\n)*(?<indent> *).*((\r?\n)+( *|\k<indent>.*))*$');
        #    if( rMatch && rMatch.get_Success() )
        #    {
        #        rGroupCollection = rMatch.get_Groups();
        #        rGroup = rGroupCollection.get_Item('indent');
        #        i = rGroup.get_Length();
        #        indent = min(indent, i);
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    if( indent == maxint() )
        #        return 0;
        #
        #    return indent;
        #}
      ENDSOURCE
      SOURCE #callStack
        #// отображаем как в отладчике
        #public static str callStack(int skip = 2, container callStack = xSession::xppCallStack())
        #{
        #    str ret = TextBufferUtil::appendCallStack(null, skip, callStack).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #changeIndent
        #// добавляет или удаляет отступ слева у каждой строки в многострочном тексте
        #// пробелы справа каждой строки оставляет как есть
        #// табуляцию рассматривает как непробельный значащий символ
        #//
        #// text - исходный текст, в котором метод изменяет отступы
        #// identOffset - положительное значение увеличивает отступ, отрицательное значение уменьшает отступ, нулевое значение не меняет текст
        #//
        #public static str changeIndent(str text, int indentOffset)
        #{
        #    str pattern;
        #    str replacement;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( indentOffset == 0 )
        #        return text;
        #
        #    if( indentOffset < 0 )
        #    {
        #        pattern = strfmt('(?m)^ {1,%1}', -indentOffset);
        #        replacement = '';
        #    }
        #    else
        #    {
        #        pattern = '(?m)^';
        #        replacement = strrep(' ', indentOffset);
        #    }
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, replacement);
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #drop
        #// в каждой строке многострочного текста:
        #// = удаляет первые n символов, если n > 0
        #// = удаляет последние n символов, если n < 0
        #// возвращает исходный текст, если n == 0
        #public static str drop(str text, int n)
        #{
        #    if( n > 0 )
        #        return TextUtil::dropStart(text, n);
        #
        #    return TextUtil::dropEnd(text, -n);
        #}
      ENDSOURCE
      SOURCE #dropEnd
        #// в каждой строке многострочного текста:
        #// = удаляет последние n символов, если n < 0
        #// возвращает исходный текст, если n => 0
        #public static str dropEnd(str text, int n)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( n <= 0 )
        #        return text;
        #
        #    pattern = strfmt('(?m).{1,%1}$', n);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #dropStart
        #// в каждой строке многострочного текста:
        #// удаляет первые n символов, если n > 0
        #// возвращает исходный текст, если n <= 0
        #public static str dropStart(str text, int n)
        #{
        #    str pattern;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( n <= 0 )
        #        return text;
        #
        #    pattern = strfmt('(?m)^.{1,%1}', n);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    text = System.Text.RegularExpressions.Regex::Replace(text, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return text;
        #}
      ENDSOURCE
      SOURCE #fromInfolog
        #public static str fromInfolog(int fromLine, int toLine = infolog.line())
        #{
        #    InfologData infologData = infolog.copy(fromLine, toLine);
        #    str ret = TextBufferUtil::appendInfolog(null, infologData).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #infolog
        #public static str infolog(InfologData info = infolog.export(), str newLine = '\n')
        #{
        #    str ret = TextBufferUtil::appendInfolog(null, info, newLine).getText();
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #line
        #// возвращает n-ую строку из многострочного текста
        #public static str line(str s, int n)
        #{
        #    str ret = strline(s, n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lines
        #public static System.String[] lines(str text)
        #{
        #    System.String[] ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    ret = System.Text.RegularExpressions.Regex::Split(text, '\n');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #padLeft
        #// добавляет указанный символ слева до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #public static str padLeft(str text, int length, char char = ' ')
        #{
        #    TextBuffer                              ret = new TextBuffer();
        #    str                                     s;
        #    int                                     n;
        #    System.Char                             c;
        #    System.String                           ss;
        #    System.Text.RegularExpressions.Match    rMatch;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( char == '' )
        #        return text;
        #
        #    if( length <= 0 )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    c = System.Char::Parse(char);
        #
        #    rMatch = System.Text.RegularExpressions.Regex::Match(text, @'(?m)^.*$');
        #    while( rMatch && rMatch.get_Success() )
        #    {
        #        ss = rMatch.get_Value();
        #        s = ss.PadLeft(length, c);
        #
        #        if( n )
        #            ret.appendText('\n');
        #
        #        ret.appendText(s);
        #
        #        rMatch = rMatch.NextMatch();
        #        ++n;
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #padRight
        #// добавляет указанный символ справа до нужной длины
        #// если строка уже длиннее, то ничего не делает. Поэтому результат может быть длиннее указанной длины.
        #static str padRight(str text, int length, char char = ' ')
        #{
        #    TextBuffer  ret = new TextBuffer();
        #    str         s;
        #
        #    System.Char                     c;
        #    System.String                   ss;
        #    System.String[]                 ssa;
        #    System.Collections.IEnumerator  se;
        #
        #    if( text == '' )
        #        return text;
        #
        #    if( char == '' )
        #        return text;
        #
        #    if( length <= 0 )
        #        return text;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    ssa = TextUtil::lines(text);
        #    se  = ssa.GetEnumerator();
        #    while( se.MoveNext() )
        #    {
        #        if( ret.size() )
        #        {
        #            ret.appendText('\n');
        #        }
        #        else
        #        {
        #            c = System.Char::Parse(char);
        #        }
        #
        #        ss = se.get_Current();
        #        s  = ss.PadRight(length, c);
        #
        #        ret.appendText(s);
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret.getText();
        #}
      ENDSOURCE
      SOURCE #strLeft
        #// возвращает текст, в котором каждая строка содержит не более заданной длины справа
        #static str strLeft(str s, int len)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( len > 0 )
        #        pattern = strfmt(@'(?m)(?<=.{%1}).+', len);
        #    else
        #        pattern = strfmt(@'(?m).+', len);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #strRight
        #// возвращает текст, в котором каждая строка содержит не более заданной длины слева
        #static str strRight(str s, int len)
        #{
        #    str pattern;
        #
        #    if( s == '' )
        #        return s;
        #
        #    if( len > 0 )
        #        pattern = strfmt(@'(?m).+(?=.{%1})', len);
        #    else
        #        pattern = strfmt(@'(?m).+', len);
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    s = System.Text.RegularExpressions.Regex::Replace(s, pattern, '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #toArray
        #// TODO
        #public static container toArray(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #// TODO
        #public static container toList(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toMap
        #// TODO
        #public static container toMap(str s, int startLineNum = 1)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toSet
        #// TODO
        #public static container toSet(str s)
        #{
        #    container ret = StrUtil::splitChar(s, '\n');
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trim
        #// убирает указанные символы в начале и в конце всех строк в многострочном тексте
        #// по умолчанию, убирает пробелы, табуляцию и переводы строк
        #static str trim(str s, str ws = ' \t')
        #{
        #    str ret;
        #    int len = strlen(s);
        #    int fromPos = strnfind(s, ws, 1, len);
        #    int toPos = strnfind(s, ws, len, -len);
        #
        #    if( fromPos && fromPos <= toPos )
        #    {
        #        ret = substr(s, fromPos, toPos - fromPos + 1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimBlankLines
        #static str trimBlankLines(str s, str ws = ' \t\r\n')
        #{
        #    str ret;
        #    //TODO
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimEnd
        #//TODO
        #public static str trimEnd(str s, str ws = ' \t')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #// удаляет отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static str trimIndent(str s)
        #{
        #    int indent;
        #
        #    if( s == '' )
        #        return s;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    // удаляем первую и последнюю пустые или пробельные строки
        #    s = System.Text.RegularExpressions.Regex::Replace(s, '^ *\n|\n *$', '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    indent = TextUtil::calcIndent(s);
        #
        #    s = TextUtil::changeIndent(s, -indent);
        #
        #    return s;
        #}
      ENDSOURCE
      SOURCE #trimStart
        #//TODO
        #public static str trimStart(str s, str ws = ' \t')
        #{
        #    str ret;
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TextUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TextUtilTest
    PROPERTIES
      Name                #TextUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class TextUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAfter
        #void testAfter()
        #{
        #    this.assertEquals('DEF-GH\nLMN-OP',         TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','-'));
        #    this.assertEquals('GH\nIJK-LMN-OP',         TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','DEF-'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('BC-DEF-GH\nIJK-LMN-OP',  TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::after('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('DEF-GH',     TextUtil::after('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',         TextUtil::after('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',           TextUtil::after('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH',  TextUtil::after('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::after('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testAfterChar
        #void testAfterChar()
        #{
        #    this.assertEquals('DEF-GH\nLMN-OP',         TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','=-'));
        #    this.assertEquals('DEF-GH\nLMN-OP',         TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','E=-'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('BC-DEF-GH\nLMN-OP',      TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP','A=-'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::afterChar('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('DEF-GH',    TextUtil::afterChar('ABC-DEF-GH','-='));
        #    this.assertEquals('DEF-GH',    TextUtil::afterChar('ABC-DEF-GH','E=-'));
        #    this.assertEquals('',          TextUtil::afterChar('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH', TextUtil::afterChar('ABC-DEF-GH','A=-'));
        #    this.assertEquals('ABC-DEF-GH',TextUtil::afterChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testAfterLast
        #void testAfterLast()
        #{
        #    this.assertEquals('GH\nOP',                 TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','-'));
        #    this.assertEquals('GH\nIJK-LMN-OP',         TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','DEF-'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('BC-DEF-GH\nIJK-LMN-OP',  TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::afterLast('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('GH',         TextUtil::afterLast('ABC-DEF-GH','-'));
        #    this.assertEquals('GH',         TextUtil::afterLast('ABC-DEF-GH','DEF-'));
        #    this.assertEquals('',           TextUtil::afterLast('ABC-DEF-GH','H'));
        #    this.assertEquals('BC-DEF-GH',  TextUtil::afterLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::afterLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testAfterLastChar
        #void testAfterLastChar()
        #{
        #    this.assertEquals('GH\nOP',                 TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','-='));
        #    this.assertEquals('GH\nOP',                 TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','E=-'));
        #    this.assertEquals('\nOP',                   TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','H=-'));
        #    this.assertEquals('BC-DEF-GH\nIJK-LMN-OP',  TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::afterLastChar('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('GH',        TextUtil::afterLastChar('ABC-DEF-GH','-='));
        #    this.assertEquals('GH',        TextUtil::afterLastChar('ABC-DEF-GH','E=-'));
        #    this.assertEquals('',          TextUtil::afterLastChar('ABC-DEF-GH','H=-'));
        #    this.assertEquals('BC-DEF-GH', TextUtil::afterLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH',TextUtil::afterLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testBefore
        #void testBefore()
        #{
        #    this.assertEquals('ABC\nIJK',               TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','-'));
        #    this.assertEquals('ABC\nIJK-LMN-OP',        TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','-DEF'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-G\nIJK-LMN-OP',  TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::before('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC',        TextUtil::before('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC',        TextUtil::before('ABC-DEF-GH','-DEF'));
        #    this.assertEquals('',           TextUtil::before('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G',  TextUtil::before('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::before('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testBeforeChar
        #void testBeforeChar()
        #{
        #    this.assertEquals('ABC\nIJK',               TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','=-'));
        #    this.assertEquals('ABC\nIJK',               TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','E=-'));
        #    this.assertEquals('\nIJK',                  TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','A=-'));
        #    this.assertEquals('ABC-DEF-G\nIJK-LMN-OP',  TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::beforeChar('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC',        TextUtil::beforeChar('ABC-DEF-GH','=-'));
        #    this.assertEquals('ABC',        TextUtil::beforeChar('ABC-DEF-GH','E=-'));
        #    this.assertEquals('',           TextUtil::beforeChar('ABC-DEF-GH','A-'));
        #    this.assertEquals('ABC-DEF-G',  TextUtil::beforeChar('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::beforeChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testBeforeLast
        #void testBeforeLast()
        #{
        #    this.assertEquals('ABC-DEF\nIJK-LMN',       TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','-'));
        #    this.assertEquals('ABC\nIJK-LMN-OP',        TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','-DEF'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-G\nIJK-LMN-OP',  TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP','H'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::beforeLast('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC-DEF',    TextUtil::beforeLast('ABC-DEF-GH','-'));
        #    this.assertEquals('ABC',        TextUtil::beforeLast('ABC-DEF-GH','-DEF'));
        #    this.assertEquals('',           TextUtil::beforeLast('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-G',  TextUtil::beforeLast('ABC-DEF-GH','H'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::beforeLast('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testBeforeLastChar
        #void testBeforeLastChar()
        #{
        #    this.assertEquals('ABC-DEF\nIJK-LMN',       TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','=-'));
        #    this.assertEquals('ABC-DEF\nIJK-LMN',       TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','E=-'));
        #    this.assertEquals('ABC-DEF-G\nIJK-LMN',     TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','H=-'));
        #    this.assertEquals('\nIJK-LMN-OP',           TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP','A'));
        #    this.assertEquals('ABC-DEF-GH\nIJK-LMN-OP', TextUtil::beforeLastChar('ABC-DEF-GH\nIJK-LMN-OP',','));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC-DEF',    TextUtil::beforeLastChar('ABC-DEF-GH','=-'));
        #    this.assertEquals('ABC-DEF',    TextUtil::beforeLastChar('ABC-DEF-GH','E=-'));
        #    this.assertEquals('ABC-DEF-G',  TextUtil::beforeLastChar('ABC-DEF-GH','H=-'));
        #    this.assertEquals('',           TextUtil::beforeLastChar('ABC-DEF-GH','A'));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::beforeLastChar('ABC-DEF-GH',','));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent
        #void testCalcIndent()
        #{
        #    str s = @'
        #                ABC
        #                    123
        #                456
        #    ';
        #
        #    this.assertEquals(16, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1
        #void testCalcIndent_1()
        #{
        #    str s = @'  ABC';
        #
        #    this.assertEquals(2, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1_Blank
        #void testCalcIndent_1_Blank()
        #{
        #    str s = @'  ';
        #
        #    this.assertEquals(2, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_1_NoIndent
        #void testCalcIndent_1_NoIndent()
        #{
        #    str s = @'ABC  ';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_2_Blank
        #void testCalcIndent_2_Blank()
        #{
        #    str s = @'
        #';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_3_Blank
        #void testCalcIndent_3_Blank()
        #{
        #    str s = @'
        #
        #';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_4_Blank
        #void testCalcIndent_4_Blank()
        #{
        #    str s = @'
        #
        #
        #';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Blank
        #void testCalcIndent_Blank()
        #{
        #    str s = @'
        #                ABC
        #
        #                    123
        #                456
        #    ';
        #
        #    this.assertEquals(16, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Disorder
        #void testCalcIndent_Disorder()
        #{
        #    str s = @'
        #                 ABC
        #                  123
        #               456
        #        ';
        #
        #    this.assertEquals(15, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Empty
        #void testCalcIndent_Empty()
        #{
        #    str s = '';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_First
        #void testCalcIndent_First()
        #{
        #    str s = @'  ABC
        #                123
        #                456
        #        ';
        #
        #    this.assertEquals(2, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_First_NoIndent
        #void testCalcIndent_First_NoIndent()
        #{
        #    str s = @'0  ABC
        #                123
        #                456
        #        ';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_Last
        #void testCalcIndent_Last()
        #{
        #    str s = @'
        #                ABC
        #                123
        #    456';
        #
        #    this.assertEquals(4, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testCalcIndent_NoIndent
        #void testCalcIndent_NoIndent()
        #{
        #    str s = @'
        #ABC
        #123
        #456
        #        ';
        #
        #    this.assertEquals(0, TextUtil::calcIndent(s));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent
        #void testChangeIndent()
        #{
        #    str s = @'
        #    ABC
        #        123
        #    456
        #    ';
        #
        #    this.assertEquals('\nABC\n    123\n456\n', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1
        #void testChangeIndent_1()
        #{
        #    str s = @'  ABC';
        #
        #    this.assertEquals('ABC', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1_Blank
        #void testChangeIndent_1_Blank()
        #{
        #    str s = @'  ';
        #
        #    this.assertEquals('', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_1_NoIndent
        #void testChangeIndent_1_NoIndent()
        #{
        #    str s = @'ABC  ';
        #
        #    this.assertEquals('ABC  ', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Blank
        #void testChangeIndent_Blank()
        #{
        #    str s = @'
        #    ABC
        #
        #        123
        #456
        #    ';
        #
        #    this.assertEquals('\nABC\n\n    123\n456\n', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Empty
        #void testChangeIndent_Empty()
        #{
        #    str s = '';
        #
        #    this.assertEquals('', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_First
        #void testChangeIndent_First()
        #{
        #    str s = @'  ABC
        #    123
        #    456
        #';
        #
        #    this.assertEquals('ABC\n123\n456\n', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_Last
        #void testChangeIndent_Last()
        #{
        #    str s = @'ABC
        #    123
        #    456  ';
        #
        #    this.assertEquals('ABC\n123\n456  ', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_OverIndent
        #void testChangeIndent_OverIndent()
        #{
        #    str s = @'
        #    ABC
        #        123
        #456
        #    ';
        #
        #    this.assertEquals('\nABC\n    123\n456\n', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testChangeIndent_UnderIndent
        #void testChangeIndent_UnderIndent()
        #{
        #    str s = @'
        #        ABC
        #            123
        #        456
        #    ';
        #
        #    this.assertEquals('\n    ABC\n        123\n    456\n', TextUtil::changeIndent(s, -4));
        #}
      ENDSOURCE
      SOURCE #testDrop_0
        #void testDrop_0()
        #{
        #    this.assertEquals('abcd\nefgh', TextUtil::drop('abcd\nefgh', 0));
        #}
      ENDSOURCE
      SOURCE #testDrop_BlankLine
        #void testDrop_BlankLine()
        #{
        #    this.assertEquals('\nd\n\nh\n', TextUtil::drop('\nabcd\n\nefgh\n', 3));
        #}
      ENDSOURCE
      SOURCE #testDrop_Empty
        #void testDrop_Empty()
        #{
        #    this.assertEquals('', TextUtil::drop('', 3));
        #}
      ENDSOURCE
      SOURCE #testDrop_Neg
        #void testDrop_Neg()
        #{
        #    this.assertEquals('a\ne', TextUtil::drop('abcd\nefgh', -3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('abcde', TextUtil::drop('abcdefgh', -3));
        #}
      ENDSOURCE
      SOURCE #testDrop_Pos
        #void testDrop_Pos()
        #{
        #    this.assertEquals('d\nh', TextUtil::drop('abcd\nefgh', 3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('defgh', TextUtil::drop('abcdefgh', 3));
        #}
      ENDSOURCE
      SOURCE #testDropEnd_0
        #void testDropEnd_0()
        #{
        #    this.assertEquals('abcd\nefgh', TextUtil::dropEnd('abcd\nefgh', 0));
        #}
      ENDSOURCE
      SOURCE #testDropEnd_BlankLine
        #void testDropEnd_BlankLine()
        #{
        #    this.assertEquals('\na\n\ne\n', TextUtil::dropEnd('\nabcd\n\nefgh\n', 3));
        #}
      ENDSOURCE
      SOURCE #testDropEnd_Empty
        #void testDropEnd_Empty()
        #{
        #    this.assertEquals('', TextUtil::dropEnd('', 3));
        #}
      ENDSOURCE
      SOURCE #testDropEnd_Neg
        #void testDropEnd_Neg()
        #{
        #    this.assertEquals('abcd\nefgh', TextUtil::dropEnd('abcd\nefgh', -3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('abcdefgh', TextUtil::dropEnd('abcdefgh', -3));
        #}
      ENDSOURCE
      SOURCE #testDropEnd_Pos
        #void testDropEnd_Pos()
        #{
        #    this.assertEquals('a\ne', TextUtil::dropEnd('abcd\nefgh', 3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('abcde', TextUtil::dropEnd('abcdefgh', 3));
        #}
      ENDSOURCE
      SOURCE #testDropStart_0
        #void testDropStart_0()
        #{
        #    this.assertEquals('abcd\nefgh', TextUtil::dropStart('abcd\nefgh', 0));
        #}
      ENDSOURCE
      SOURCE #testDropStart_BlankLine
        #void testDropStart_BlankLine()
        #{
        #    this.assertEquals('\nd\n\nh\n', TextUtil::dropStart('\nabcd\n\nefgh\n', 3));
        #}
      ENDSOURCE
      SOURCE #testDropStart_Empty
        #void testDropStart_Empty()
        #{
        #    this.assertEquals('', TextUtil::dropStart('', 3));
        #}
      ENDSOURCE
      SOURCE #testDropStart_Neg
        #void testDropStart_Neg()
        #{
        #    this.assertEquals('abcd\nefgh', TextUtil::dropStart('abcd\nefgh', -3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('abcdefgh', TextUtil::dropStart('abcdefgh', -3));
        #}
      ENDSOURCE
      SOURCE #testDropStart_Pos
        #void testDropStart_Pos()
        #{
        #    this.assertEquals('d\nh', TextUtil::dropStart('abcd\nefgh', 3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('defgh', TextUtil::dropStart('abcdefgh', 3));
        #}
      ENDSOURCE
      SOURCE #testPadLeft
        #void testPadLeft()
        #{
        #    this.assertEquals('ABCD\nEFGH',         TextUtil::padLeft('ABCD\nEFGH',3));
        #    this.assertEquals(' ABCD\n EFGH',       TextUtil::padLeft('ABCD\nEFGH',5));
        #    this.assertEquals(' ABC\n DEF\n  GH',   TextUtil::padLeft('ABC\nDEF\nGH',4));
        #    this.assertEquals(' ABC\n    \n  GH',   TextUtil::padLeft('ABC\n\nGH',4));
        #    this.assertEquals('ABC\nDEF\nGH',       TextUtil::padLeft('ABC\nDEF\nGH',0));
        #    this.assertEquals('ABC\nDEF\nGH',       TextUtil::padLeft('ABC\nDEF\nGH',-3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC',   TextUtil::padLeft('ABC',3));
        #    this.assertEquals('  ABC', TextUtil::padLeft('ABC',5));
        #    this.assertEquals('ABC',   TextUtil::padLeft('ABC',0));
        #    this.assertEquals('ABC',   TextUtil::padLeft('ABC',-3));
        #}
      ENDSOURCE
      SOURCE #testPadRight
        #void testPadRight()
        #{
        #    this.assertEquals('ABCD\nEFGH',         TextUtil::padRight('ABCD\nEFGH',3));
        #    this.assertEquals('ABCD \nEFGH ',       TextUtil::padRight('ABCD\nEFGH',5));
        #    this.assertEquals('ABC \nDEF \nGH  ',   TextUtil::padRight('ABC\nDEF\nGH',4));
        #    this.assertEquals('ABC \n    \nGH  ',   TextUtil::padRight('ABC\n\nGH',4));
        #    this.assertEquals('ABC\nDEF\nGH',       TextUtil::padRight('ABC\nDEF\nGH',0));
        #    this.assertEquals('ABC\nDEF\nGH',       TextUtil::padRight('ABC\nDEF\nGH',-3));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC',   TextUtil::padRight('ABC',3));
        #    this.assertEquals('ABC  ', TextUtil::padRight('ABC',5));
        #    this.assertEquals('ABC',   TextUtil::padRight('ABC',0));
        #    this.assertEquals('ABC',   TextUtil::padRight('ABC',-3));
        #}
      ENDSOURCE
      SOURCE #testStrLeft
        #void testStrLeft()
        #{
        #    this.assertEquals('ABC\nEFG',        TextUtil::strLeft('ABCD\nEFGH',3));
        #    this.assertEquals('\n\n',            TextUtil::strLeft('ABC\nDEF\nGH',0));
        #    this.assertEquals('\n\n',            TextUtil::strLeft('ABC\nDEF\nGH',-3));
        #    this.assertEquals('ABC\nDEF\nGH',    TextUtil::strLeft('ABC\nDEF\nGH',30));
        #
        #    this.info('line');
        #
        #    this.assertEquals('ABC',        TextUtil::strLeft('ABC-DEF-GH',3));
        #    this.assertEquals('',           TextUtil::strLeft('ABC-DEF-GH',0));
        #    this.assertEquals('',           TextUtil::strLeft('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::strLeft('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testStrRight
        #void testStrRight()
        #{
        #    this.assertEquals('BCD\nFGH',        TextUtil::strRight('ABCD\nEFGH',3));
        #    this.assertEquals('\n\n',            TextUtil::strRight('ABC\nDEF\nGH',0));
        #    this.assertEquals('\n\n',            TextUtil::strRight('ABC\nDEF\nGH',-3));
        #    this.assertEquals('ABC\nDEF\nGH',    TextUtil::strRight('ABC\nDEF\nGH',30));
        #
        #    this.info('line');
        #
        #    this.assertEquals('-GH',        TextUtil::strRight('ABC-DEF-GH',3));
        #    this.assertEquals('',           TextUtil::strRight('ABC-DEF-GH',0));
        #    this.assertEquals('',           TextUtil::strRight('ABC-DEF-GH',-3));
        #    this.assertEquals('ABC-DEF-GH', TextUtil::strRight('ABC-DEF-GH',30));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent
        #void testTrimIndent()
        #{
        #    str s = @'
        #    ABC
        #        123
        #    456
        #    ';
        #
        #    this.assertEquals('ABC\n    123\n456', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1
        #void testTrimIndent_1()
        #{
        #    str s = @'  ABC';
        #
        #    this.assertEquals('ABC', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1_Blank
        #void testTrimIndent_1_Blank()
        #{
        #    str s = @'  ';
        #
        #    this.assertEquals('', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_1_NoIndent
        #void testTrimIndent_1_NoIndent()
        #{
        #    str s = @'ABC  ';
        #
        #    this.assertEquals('ABC  ', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_BlankLine
        #void testTrimIndent_BlankLine()
        #{
        #    str s = @'
        #    ABC
        #
        #        123
        #456
        #    ';
        #
        #    this.assertEquals('    ABC\n\n        123\n456', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_Empty
        #void testTrimIndent_Empty()
        #{
        #    str s = '';
        #
        #    this.assertEquals('', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_First
        #void testTrimIndent_First()
        #{
        #    str s = @'  ABC
        #    123
        #    456
        #';
        #
        #    this.assertEquals('ABC\n  123\n  456', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #testTrimIndent_Last
        #void testTrimIndent_Last()
        #{
        #    str s = @'ABC
        #    123
        #    456  ';
        #
        #    this.assertEquals('ABC\n    123\n    456  ', TextUtil::trimIndent(s));
        #}
      ENDSOURCE
      SOURCE #trimIndent
        #//
        #// mazzy, https://github.com/mazzy-ax/SysString
        #//
        #// удаляет отступ, который применим для каждой строки в многострочном тексте
        #// табуляцию рассматривает как непробельный значащий символ
        #// работает как trimIndent в Kotlin, https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html
        #// см. также https://openjdk.java.net/jeps/355
        #public static str trimIndent(str s)
        #{
        #    int indent;
        #;
        #    if( s == '' )
        #        return s;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    // удаляем первую и последнюю пустые или пробельные строки
        #    s = System.Text.RegularExpressions.Regex::Replace(s, '^ *\n|\n *$', '');
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    indent = TextUtil::calcIndent(s);
        #
        #    s = TextUtil::changeIndent(s, -indent);
        #
        #    return s;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: CollectionUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #CollectionUtil
    PROPERTIES
      Name                #CollectionUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #//
        #// TODO work in progress
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class CollectionUtil
        #{
        #}
      ENDSOURCE
      SOURCE #as
        #public static anytype as(anytype value)
        #{
        #    return EnumeratorUtil::asEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// возвращает объект, который реализует интерфейс EEnumerator
        #// возвращает null, если параметр не является ни коллекцией, ни энумератором
        #//
        #// используйте EnumeratorUtil::getEnumerator() чтобы получить энумератор для любого объекта
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static EEnumerator getEEnumerator(anytype collection)
        #{
        #    switch( typeof(collection) )
        #    {
        #        case Types::Container:
        #            return ConEnumerator::construct(collection);
        #
        #        case Types::Record:
        #            return RecordEnumerator::construct(collection);
        #
        #        case Types::Class:
        #            return ObjectUtil::getEEnumerator(collection);
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает объект, у которого можно вызвать метод moveNext или Null
        #// возвращает null, если параметр не является ни коллекцией, ни энумератором
        #//
        #// используйте EnumeratorUtil::getEnumerator() чтобы получить энумератор для любого объекта
        #public static Enumerator getEnumerator(anytype collection)
        #{
        #    switch( typeof(collection) )
        #    {
        #        case Types::Container:
        #            return ConEnumerator::construct(collection);
        #
        #        case Types::Record:
        #            return RecordEnumerator::construct(collection);
        #
        #        case Types::Class:
        #            return ObjectUtil::getEnumerator(collection);
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #in
        #public static boolean in(anytype value, anytype collection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( value == e.current() )
        #        {
        #            return true;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #is
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean is(anytype value)
        #{
        #    return EnumeratorUtil::isEnumerable(value);
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(anytype collection)
        #{
        #    boolean     ret = true;
        #    Enumerator  e   = CollectionUtil::getEnumerator(collection);
        #
        #    if( e && e.moveNext() )
        #    {
        #        ret = false;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #item
        #// первый элемент имеет индекс 1
        #public static anytype item(anytype collection, int idx)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #    int        i;
        #    anytype    ret;
        #
        #    while( idx > 0 && e && e.moveNext() )
        #    {
        #        i++;
        #        if( i == idx )
        #        {
        #            ret = e.current();
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #notIn
        #public static boolean notIn(anytype value, anytype valueOrCollection)
        #{
        #    boolean in = CollectionUtil::in(value, valueOrCollection);
        #
        #    return !in;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArrayUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArrayUtil
    PROPERTIES
      Name                #ArrayUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ArrayUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static Array add(Array arr, anytype value)
        #{
        #    int len;
        #
        #    if( !arr )
        #    {
        #        arr = ArrayUtil::newBy(value);
        #    }
        #
        #    if( arr.typeId() == typeof(value) ) // значения с другим типом не будет добавлено
        #    {
        #        len = arr.lastIndex();
        #        arr.value(len+1, value);
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #addAll
        #public static Array addAll(Array arr, anytype valueOrCollection, int maxElements = 0)
        #{
        #    int elements;
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements < maxElements) )
        #    {
        #        arr = ArrayUtil::add(arr, e.current());
        #
        #        elements++;
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #addFieldValue
        #// добавляет значение поля из буфера
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #public static Array addFieldValue(Array arr, Common buf, FieldId fieldId)
        #{
        #    anytype value = RecordFieldUtil::getValue(buf, fieldId);
        #    Array ret = ArrayUtil::add(arr, value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQuery
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Array addFromQuery(Array toArrayOrNull, Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    Array ret = ArrayUtil::addFromQueryRun(toArrayOrNull, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQueryRun
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Array addFromQueryRun(Array toArrayOrNull, QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Array ret = toArrayOrNull;
        #    int elements;
        #    common rec;
        #    ;
        #
        #    while( qr && qr.next() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        rec = qr.get(tableId);
        #        ret = ArrayUtil::addFieldValue(ret, rec, fieldId);
        #
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromSelect
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Array addFromSelect(Array arr, Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #    ;
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        arr = ArrayUtil::addFieldValue(arr, selectedRecord, fieldId);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонируе массив, не клонирует элементы массива
        #// @see deepClone()
        #public static Array clone(Array arr)
        #{
        #    Array ret = ArrayUtil::addAll(ret, arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #contains
        #public static boolean contains(Array arr, anytype value)
        #{
        #    boolean ret = ArrayUtil::in(value, arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAll
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если массив содержит все значения из collection
        #public static boolean containsAll(Array arr, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( ret && e && e.moveNext() )
        #    {
        #        ret = ret && ArrayUtil::contains(arr, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAny
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если массив содержит любое значение из collection
        #public static boolean containsAny(Array arr, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ArrayUtil::contains(arr, e.current());
        #
        #        if( ret )
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsType
        #public static boolean containsType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    boolean ret;
        #    int len;
        #    int i;
        #
        #    if( arr && arr.typeId() == type )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( AnytypeUtil::is(arr.value(i), type, potentialAncestorId) )
        #            {
        #                ret = true;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #count
        #public static int count(Array arr, anytype value)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1; i<=len ; i++ )
        #        {
        #            if( arr.value(i) == value )
        #            {
        #                ret++;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countAny
        #public static int countAny(Array arr, anytype valueOrCollection)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( CollectionUtil::in(arr.value(i), valueOrCollection) )
        #            {
        #                ret++;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countEmpty
        #public static int countEmpty(Array arr)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( !arr.value(i) )
        #            {
        #                ret++;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countNotEmpty
        #public static int countNotEmpty(Array arr)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( arr.value(i) )
        #            {
        #                ret++;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countType
        #public static int countType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr && arr.typeId() == type )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( AnytypeUtil::is(arr.value(i), type, potentialAncestorId) )
        #            {
        #                ret++;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #create
        #// возвращает Array или null, если не смог распаковать
        #// метод возвратит Array с тем типом, который указан в контейнере
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Array create(anytype packedArray)
        #{
        #    Array ret = ArrayUtil::createAs(packedArray, Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAs
        #// возвращает Array или null, если не смог распаковать
        #// возвращаемый Array будет содержать элементы указанного типа, если во втором параметре указан тип, иначе будет возвращен null.
        #// проверка типа выполняться не будет, если во втором параметре указан Types::AnyType.
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Array createAs(anytype packedArray, Types asType)
        #{
        #    Array ret;
        #
        #    if( ArrayUtil::isPackedOk(packedArray, asType) )
        #    {
        #        ret = Array::create(packedArray);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAsArray
        #// возвращает Array или null, если не смог распаковать
        #// возвращаемый Array будет иметь такой же тип, что и во втором параметре
        #// вернет null, если второй параметр null
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Array createAsArray(anytype packedArray, Array asArray)
        #{
        #    Array ret;
        #
        #    if( asArray )
        #    {
        #        ret = ArrayUtil::createAs(packedArray, asArray.typeId());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонируе и массив, и элементы массива
        #//
        #// @see clone()
        #public static Array deepClone(Array arr)
        #{
        #    Array ret;
        #    container packedArray;
        #
        #    if( arr )
        #    {
        #        packedArray = arr.pack();
        #        ret = Array::create(packedArray);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #delete
        #public static Array delete(Array arr, int start, int number = 1)
        #{
        #    Array ret;
        #    int len;
        #    int end;
        #    int i;
        #
        #    if( arr )
        #    {
        #        if( number <= 0 )
        #        {
        #            ret = ArrayUtil::clone(arr);
        #        }
        #        else
        #        {
        #            len = arr.lastIndex();
        #
        #            start += (start < 0 ? len + 1 : 0);
        #            end = start + number - 1;
        #
        #            start = max(1, start);
        #            end = min(len, end);
        #
        #            // два цикла минимизируют число итераций
        #
        #            for( i=1 ; i<start ; i++ )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #
        #            for( i=end+1 ; i<=len ; i++ )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #distinct
        #// возвращает новый массив, в котором присутствуют только уникальные объекты (дубли удалены)
        #public static Array distinct(Array arr)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( !ArrayUtil::in(arr.value(i), ret) )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #public static Array drop(Array arr, int n = 1)
        #{
        #    Array ret = ArrayUtil::slice(arr, 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #dropEnd
        #public static Array dropEnd(Array arr, int n = 1)
        #{
        #    Array ret = ArrayUtil::slice(arr, 1, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(Array arr)
        #{
        #    int ret;
        #
        #    if( arr )
        #    {
        #        ret = arr.lastIndex();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static Array ensureType(Array arr, Types valueType)
        #{
        #    if( ArrayUtil::isType(arr, valueType) )
        #    {
        #        return arr;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #find
        #public static int find(Array arr, anytype value, int occurrence = 1)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i = 1; occurrence > 0 && i <= len; i++ )
        #        {
        #            if( AnytypeUtil::isEqual(value, arr.value(i)) )
        #            {
        #                occurrence--;
        #                if( occurrence <= 0 )
        #                {
        #                    ret = i;
        #                    break;
        #                }
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findAny
        #public static int findAny(Array arr, anytype valueOrCollection)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = arr.lastIndex();
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( CollectionUtil::in(arr.value(i), valueOrCollection) )
        #            {
        #                ret = i;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #// возвращает первый элемент массива. скорее всего, это не массив.
        #// поэтому если вызывающий алгоритм знает, что положено в массив, то вызывающий алгоритм может не парится с проверками
        #//
        #// @see head - синоним
        #// @see last
        #public static anytype first(Array arr)
        #{
        #    anytype ret;
        #
        #    if( arr )
        #    {
        #        ret = arr.value(1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ArrayEnumerator getEnumerator(Array arr)
        #{
        #    ArrayEnumerator ret = ArrayEnumerator::construct(arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorAndSkip
        #public static ArrayEnumerator getEnumeratorAndSkip(Array arr, int skipIterations)
        #{
        #    ArrayEnumerator ret = ArrayEnumerator::construct(arr);
        #
        #    if( ret && !EnumeratorUtil::skip(ret, skipIterations) )
        #    {
        #        ret = null;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorIfType
        #public static ArrayEnumerator getEnumeratorIfType(Array arr, Types valueType)
        #{
        #    ArrayEnumerator ret;
        #
        #    if( ArrayUtil::isType(arr, valueType) )
        #    {
        #        ret = ArrayEnumerator::construct(arr);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #// метод возвращает true, если value содержится в массиве
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #//
        #// Например:
        #//
        #// if( predicat1 ||
        #//     ArrayUtil::in( predicat2, [
        #//         Status::s1,
        #//         Status::s4,
        #//         Status::s7
        #//     ])
        #//
        #public static boolean in(anytype value, Array arr)
        #{
        #    int ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i = 1; i <= len; i++ )
        #        {
        #            if( arr.value(i) == value )
        #            {
        #                ret = i;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(Array arr)
        #{
        #    boolean ret = true;
        #
        #    if( arr )
        #    {
        #        ret = (arr.lastIndex() <= 0);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(Array arr)
        #{
        #    boolean ret = false;
        #
        #    if( arr )
        #    {
        #        ret = (arr.lastIndex() > 0);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmptyWithType
        #public static boolean isNotEmptyWithType(Array arr, Types valueType)
        #{
        #    boolean ret = !ArrayUtil::isEmpty(arr) && arr.typeId() == valueType;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedNotEmpty
        #// возвращает true, если контейнер можно распаковать как Array и Array скорее всего будет содержать элементы
        #//
        #// "скорее всего" потому что типы элементов контейнера могут отличаться от типа, который объявлен в во втором элементе контейнера.
        #// если типы различаются, то элемент не будет добавлен к коллекцию.
        #// В нормальных случаях такого не бывает. А на точную проверку будет затрачено больше времени, чем создание самой коллекции
        #//
        #// внутреннее устройство Set: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedNotEmpty(anytype packedSet, Types expectedType = Types::AnyType)
        #{
        #    boolean ret = conlen(packedSet) > 3 && SetUtil::isPackedOk(packedSet,expectedType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedOk
        #// возвращает true, если контейнер можно распаковать как Array
        #// удобно использовать в методах unpack
        #// метод не бросает исключения - метод проверит что сможет и вернет false, если что-то не так
        #//
        #// внутреннее устройство Array: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedOk(anytype packedArray, Types expectedType = Types::AnyType)
        #{
        #    boolean ret;
        #
        #    anytype version;
        #    anytype type;
        #    anytype elements;
        #
        #    if( packedArray &&
        #        typeof(packedArray) == Types::Container &&
        #        conlen(packedArray) >= 3 )
        #    {
        #        [version, type, elements] = packedArray;
        #
        #        if( typeof(version)  == Types::Integer && version == 1 &&
        #            typeof(type)     == Types::Integer && TypeUtil::is(type, expectedType) &&
        #            typeof(elements) == Types::Integer )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public static boolean isType(Array arr, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( arr )
        #    {
        #        ret = TypeUtil::is(arr.typeId(), elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #item
        #// первый элемент имеет индекс 1
        #public static anytype item(Array arr, int idx)
        #{
        #    anytype ret;
        #
        #    if( arr && idx > 0 && arr.exists(idx) )
        #    {
        #        ret = arr.value(idx);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAs
        #public static anytype itemAs(Array arr, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype value = ArrayUtil::item(arr, idx);
        #    anytype ret = AnytypeUtil::as(value, type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAsValue
        #public static anytype itemAsValue(Array arr, int idx, anytype asValue)
        #{
        #    anytype value = ArrayUtil::item(arr, idx);
        #    anytype ret = AnytypeUtil::asValue(value, asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #last
        #// возвращает последний элемент массива. скорее всего, это не массив.
        #// поэтому если вызывающий алгоритм знает, что положено в массив, то вызывающий алгоритм может не парится с проверками
        #//
        #// @see first
        #// @see head
        #public static anytype last(Array arr)
        #{
        #    int lastPos = ArrayUtil::elements(arr);
        #    anytype ret = ArrayUtil::item(arr, lastPos);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #merge
        #// возвращает новый массив, который содержит все элементы первого массива, затем все элементы второго массива
        #public static Array merge(Array arr1, Array arr2)
        #{
        #    Array ret;
        #    ;
        #
        #    ret = ArrayUtil::clone(arr1);
        #    ret = ArrayUtil::add(ret, arr2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать Array для хранения значений, тип которых совпадает с типом переменной value
        #public static Array newBy(anytype value)
        #{
        #    Types type = typeof(value);
        #    Array ret = new Array(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static Array newFrom(anytype collection, int maxElements = 0)
        #{
        #    Array arr = ArrayUtil::addAll(null, collection, maxElements);
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Array newFromArray(Array arr, int maxElements = 0)
        #{
        #    Array ret;
        #    container packedArray;
        #
        #    if( arr )
        #    {
        #        if( maxElements || arr.typeId() == Types::Class )
        #        {
        #            ret = ArrayUtil::addAll(null, arr, maxElements);
        #        }
        #        else
        #        {
        #            packedArray = arr.pack();
        #            ret = Array::create(packedArray);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static Array newFromContainer(container con, int maxElements = 0)
        #{
        #    Array ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len && (maxElements == 0 || i <= maxElements); ++i )
        #    {
        #        ret = ArrayUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Array newFromList(List list, int maxElements = 0)
        #{
        #    Array ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        ret = ArrayUtil::addAll(null, list, maxElements);
        #
        #        // packedArray = arr.pack();   // не работает, в массиве содержится len - 1
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQuery
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Array newFromQuery(Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Array ret = ArrayUtil::addFromQuery(null, q, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQueryRun
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Array newFromQueryRun(QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Array ret = ArrayUtil::addFromQueryRun(null, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает массив значений поля из буфера, который был заполнен командой select
        #public static Array newFromSelect(Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    Array ret;
        #    int elements;
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        ret = ArrayUtil::addFieldValue(ret, selectedRecord, fieldId);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Array newFromSet(Set set, int maxElements = 0)
        #{
        #    Array ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        ret = ArrayUtil::addAll(null, set, maxElements);
        #
        #        // packedArray = arr.pack();   // не работает, в массиве содержится len - 1
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static Array newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    Array ret = ArrayUtil::addAll(ret, e);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Array nonNull(Array arr, Types type = Types::AnyType)
        #{
        #    if( !arr )
        #    {
        #        arr = new Array(type);
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #notIn
        #// метод возвращает true, если value не содержится в контейнере
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #//
        #// Например:
        #//
        #// if( predicat1 ||
        #//     ConUtil::CopyOfin( predicat2, [
        #//         Status::s1,
        #//         Status::s4,
        #//         Status::s7
        #//     ])
        #//
        #public static boolean notIn(anytype value, Array arr)
        #{
        #    boolean ret = !ArrayUtil::in(value, arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #pack
        #public static container pack(Array arr)
        #{
        #    container ret;
        #
        #    if( arr )
        #    {
        #        ret = arr.pack();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #remove
        #// удаляет значение из контейнера
        #//
        #// @param occurrence указывает какое вхождение значения нужно удалить
        #//
        #// @see removeAll
        #public static Array remove(Array arr, anytype value, int occurrence = 1)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( arr.value(i) == value )
        #            {
        #                occurrence--;
        #
        #                if( occurrence == 0 )
        #                {
        #                    continue;
        #                }
        #            }
        #
        #            ret = ArrayUtil::add(ret, arr.value(i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeAll
        #// возвращает новый массив, в котором отсутствуют значения из коллекции
        #public static Array removeAll(Array arr, anytype valueOrCollection)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( !CollectionUtil::in(arr.value(i), valueOrCollection) )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый массив, в котором удалены все пустые элементы
        #public static Array removeEmpty(Array arr)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i=1; i<=len; i++ )
        #        {
        #            if( arr.value(i) )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeType
        #public static Array removeType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        if( arr.typeId() != type )
        #        {
        #            ret = ArrayUtil::clone(arr);
        #        }
        #        else
        #        {
        #            len = ArrayUtil::elements(arr);
        #
        #            for( i=1 ; i<=len ; i++ )
        #            {
        #                if( !AnytypeUtil::is(arr.value(i), type, potentialAncestorId) )
        #                {
        #                    ret = ArrayUtil::add(ret, arr.value(i));
        #                }
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainAll
        #// возвращает новый контейнер, в котором остались элементы, которые содержатся в коллекции 2
        #public static Array retainAll(Array arr, anytype valueOrCollection)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( CollectionUtil::in(arr.value(i), valueOrCollection) )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainType
        #// возвращает новый контейнер, в котором остались элементы указанного типа
        #public static Array retainType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr && arr.typeId() == type )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i=1 ; i<=len ; i++ )
        #        {
        #            if( AnytypeUtil::is(arr.value(i), type, potentialAncestorId) )
        #            {
        #                ret = ArrayUtil::add(ret, arr.value(i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reverse
        #public static Array reverse(Array arr)
        #{
        #    Array ret;
        #    int len;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len = ArrayUtil::elements(arr);
        #
        #        for( i = len; i > 0; i-- )
        #        {
        #            ret = ArrayUtil::add(ret, arr.value(i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #slice
        #public static Array slice(Array arr, int fromPos = 1, int toPos = -1, int step = 1)
        #{
        #    Array ret;
        #
        #    int len;
        #    int end;
        #    int i;
        #
        #    if( arr )
        #    {
        #        len     = ArrayUtil::elements(arr);
        #
        #        fromPos += (fromPos < 0 ? len + 1 : 0);
        #        toPos   += (toPos < 0 ? len + 1 : 0);
        #
        #        i       = max(1, fromPos);
        #        end     = min(len, toPos);
        #
        #        // clone для array не быстрее метода add в цилке
        #        // поэтому не тратим время на вычиление специальных условий, чтобы сделать clone
        #
        #        while( i <= end && step > 0 )
        #        {
        #            ret = ArrayUtil::add(ret, arr.value(i));
        #            i += step;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #public static Array take(Array arr, int n = 1, int startFrom = 1)
        #{
        #    Array ret = ArrayUtil::slice(arr, startFrom, startFrom + n - 1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #takeEnd
        #public static container takeEnd(container con, int n = 1)
        #{
        #    container ret = ConUtil::slice(con, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(Array arr)
        #{
        #    container ret = ConUtil::newFromArray(arr);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #public static List toList(Array arr)
        #{
        #    List list = ListUtil::newFromArray(arr);
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #toSet
        #public static Set toSet(Array arr)
        #{
        #    Set set = SetUtil::newFromArray(arr);
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(Array arr, str sep = ',')
        #{
        #    str ret = StrUtil::newFromArray(arr, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(Array arr)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( arr )
        #    {
        #        ret = arr.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #value
        #// первый элемент имеет индекс 1
        #public static anytype value(Array arr, int idx, anytype value = 0)
        #{
        #    anytype ret;
        #
        #    if( arr && arr.exists(idx) )
        #    {
        #        if( prmisdefault(value) )
        #        {
        #            ret = arr.value(idx);
        #        }
        #        else
        #        {
        #            ret = arr.value(idx, value);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArrayUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArrayUtilTest
    PROPERTIES
      Name                #ArrayUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class ArrayUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testElements
        #void testElements()
        #{
        #    Array arr;
        #
        #    this.info('null');
        #
        #    arr = null;
        #    this.assertEquals(0, ArrayUtil::elements(arr));
        #
        #    this.info('int');
        #
        #    arr = new Array(Types::Integer);
        #    arr.value(1, 1);
        #    arr.value(2, 2);
        #    arr.value(3, 3);
        #
        #    this.assertEquals(3, ArrayUtil::elements(arr));
        #
        #    this.info('str');
        #
        #    arr = new Array(Types::String);
        #    arr.value(1, 'a');
        #    arr.value(2, 'b');
        #    arr.value(3, 'c');
        #    arr.value(4, 'd');
        #
        #    this.assertEquals(4, ArrayUtil::elements(arr));
        #
        #    this.info('class');
        #
        #    arr = new Array(Types::Class);
        #    arr.value(1, Any::construct(1));
        #    arr.value(2, Any::construct(2));
        #    arr.value(3, Any::construct(3));
        #
        #    this.assertEquals(3, ArrayUtil::elements(arr));
        #}
      ENDSOURCE
      SOURCE #testFind
        #void testFind()
        #{
        #    Array arr = ArrayUtil::newFromContainer(['a','b','c','d','e','f','b','i','j']);
        #
        #    this.assertEquals(2, ArrayUtil::find(arr, 'b'));
        #    this.assertEquals(2, ArrayUtil::find(arr, 'b', 1));
        #    this.assertEquals(7, ArrayUtil::find(arr, 'b', 2));
        #
        #    this.info('not found');
        #
        #    this.assertEquals(0, ArrayUtil::find(arr, 'z'));
        #    this.assertEquals(0, ArrayUtil::find(arr, 1));
        #    this.assertEquals(0, ArrayUtil::find(arr, null));
        #
        #    this.info('null');
        #
        #    this.assertEquals(0, ArrayUtil::find(null, 'a'));
        #}
      ENDSOURCE
      SOURCE #testItem
        #void testItem()
        #{
        #    Array arr = ArrayUtil::newFromContainer(['a','b','c','d','e','f','g','i','j']);
        #    anytype undefined;
        #
        #    this.info('correct idx');
        #
        #    this.assertEquals('b', ArrayUtil::item(arr, 2));
        #    this.assertEquals('c', ArrayUtil::item(arr, 3));
        #    this.assertEquals('j', ArrayUtil::item(arr, 9));
        #
        #    this.info('out of bounds');
        #
        #    this.assertEquals(undefined, ArrayUtil::item(arr, 0));
        #    this.assertEquals(undefined, ArrayUtil::item(arr, 10));
        #    this.assertEquals(undefined, ArrayUtil::item(arr, 22));
        #    this.assertEquals(undefined, ArrayUtil::item(arr, -1));
        #    this.assertEquals(undefined, ArrayUtil::item(arr, -4));
        #}
      ENDSOURCE
      SOURCE #testNewFromArray
        #void testNewFromArray()
        #{
        #    Array arr;
        #    Array fromArray;
        #
        #    this.info('null');
        #
        #    fromArray = null;
        #    arr = ArrayUtil::newFromArray(fromArray);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    fromArray = new Array(Types::Integer);
        #    fromArray.value(1,1);
        #    fromArray.value(2,2);
        #    fromArray.value(3,3);
        #    fromArray.value(4,2);
        #
        #    arr = ArrayUtil::newFromArray(fromArray);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Integer, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3, 2)', arr.toString());
        #
        #    this.info('str');
        #
        #    fromArray = new Array(Types::String);
        #    fromArray.value(1,'a');
        #    fromArray.value(2,'b');
        #    fromArray.value(3,'c');
        #    fromArray.value(4,'b');
        #
        #    arr = ArrayUtil::newFromArray(fromArray);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::String, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c", "b")', arr.toString());
        #
        #    this.info('class');
        #
        #    fromArray = new Array(Types::Class);
        #    fromArray.value(1,Any::construct('a'));
        #    fromArray.value(2,Any::construct('b'));
        #    fromArray.value(3,Any::construct('c'));
        #    fromArray.value(4,Any::construct('b'));
        #
        #    arr = ArrayUtil::newFromArray(fromArray);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Class, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #}
      ENDSOURCE
      SOURCE #testNewFromContainer
        #void testNewFromContainer()
        #{
        #    Array arr;
        #    container con;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    arr = ArrayUtil::newFromContainer(con);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    con = [1,2,3,2];
        #    arr = ArrayUtil::newFromContainer(con);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3, 2)', arr.toString());
        #
        #    this.info('str');
        #
        #    con = ['a','b','c','b'];
        #    arr = ArrayUtil::newFromContainer(con);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::String, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c", "b")', arr.toString());
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    arr = ArrayUtil::newFromContainer(con);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(1, arr.lastIndex());
        #    this.assertEquals('(1)', arr.toString());
        #}
      ENDSOURCE
      SOURCE #testNewFromList
        #void testNewFromList()
        #{
        #    Array arr;
        #    List fromList;
        #
        #    this.info('null');
        #
        #    fromList = null;
        #    arr = ArrayUtil::newFromList(fromList);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    fromList = new List(Types::Integer);
        #    fromList.addEnd(1);
        #    fromList.addEnd(2);
        #    fromList.addEnd(3);
        #    fromList.addEnd(2);
        #
        #    arr = ArrayUtil::newFromList(fromList);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Integer, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3, 2)', arr.toString());
        #
        #    this.info('str');
        #
        #    fromList = new List(Types::String);
        #    fromList.addEnd('a');
        #    fromList.addEnd('b');
        #    fromList.addEnd('c');
        #    fromList.addEnd('b');
        #
        #    arr = ArrayUtil::newFromList(fromList);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::String, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c", "b")', arr.toString());
        #
        #    this.info('class');
        #
        #    fromList = new List(Types::Class);
        #    fromList.addEnd(Any::construct('a'));
        #    fromList.addEnd(Any::construct('b'));
        #    fromList.addEnd(Any::construct('c'));
        #    fromList.addEnd(Any::construct('b'));
        #
        #    arr = ArrayUtil::newFromList(fromList);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Class, arr.typeId());
        #    this.assertEquals(4, arr.lastIndex());
        #}
      ENDSOURCE
      SOURCE #testNewFromSet
        #void testNewFromSet()
        #{
        #    Array arr;
        #    Set fromSet;
        #
        #    this.info('null');
        #
        #    fromSet = null;
        #    arr = ArrayUtil::newFromSet(fromSet);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    fromSet = new Set(Types::Integer);
        #    fromSet.add(1);
        #    fromSet.add(2);
        #    fromSet.add(3);
        #
        #    arr = ArrayUtil::newfromSet(fromSet);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Integer, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3)', arr.toString());
        #
        #    this.info('str');
        #
        #    fromSet = new Set(Types::String);
        #    fromSet.add('a');
        #    fromSet.add('b');
        #    fromSet.add('c');
        #
        #    arr = ArrayUtil::newfromSet(fromSet);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::String, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c")', arr.toString());
        #
        #    this.info('class');
        #
        #    fromSet = new Set(Types::Class);
        #    fromSet.add(Any::construct('a'));
        #    fromSet.add(Any::construct('b'));
        #    fromSet.add(Any::construct('c'));
        #
        #    arr = ArrayUtil::newfromSet(fromSet);
        #    this.assertNotNull(arr);
        #    this.assertEquals(Types::Class, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #}
      ENDSOURCE
      SOURCE #testSlice
        #void testSlice()
        #{
        #    Array arr = ArrayUtil::newFromContainer([1,2,3,4,5,6,7,8,9]);
        #
        #    this.info('from');
        #
        #    this.assertEquals('(2, 3, 4, 5, 6, 7, 8, 9)', ArrayUtil::slice(arr, 2).toString());
        #    this.assertEquals('(3, 4, 5, 6, 7, 8, 9)',    ArrayUtil::slice(arr, 3).toString());
        #    this.assertEquals('(6, 7, 8, 9)',             ArrayUtil::slice(arr, -4).toString());
        #
        #    this.info('from, to');
        #
        #    this.assertEquals('(3, 4, 5, 6, 7, 8, 9)',    ArrayUtil::slice(arr, 3, 99).toString());
        #    this.assertEquals('(3, 4, 5, 6, 7, 8, 9)',    ArrayUtil::slice(arr, 3, -1).toString());
        #    this.assertEquals('(3, 4, 5, 6, 7, 8)',       ArrayUtil::slice(arr, 3, -2).toString());
        #    this.assertNull(                              ArrayUtil::slice(arr, 3, 0));
        #
        #    this.info('from, to, step');
        #
        #    this.assertEquals('(3, 5, 7, 9)',             ArrayUtil::slice(arr, 3, 9, 2).toString());
        #    this.assertEquals('(2, 5, 8)',                ArrayUtil::slice(arr, 2, 9, 3).toString());
        #    this.assertNull(                              ArrayUtil::slice(arr, 2, 9, 0));
        #    this.assertNull(                              ArrayUtil::slice(arr, 2, 9, -1));
        #}
      ENDSOURCE
      SOURCE #testToCon
        #void testToCon()
        #{
        #    Array arr;
        #    container con;
        #
        #    this.info('null');
        #
        #    arr = null;
        #    con = ArrayUtil::toCon(arr);
        #    this.assertEquals(connull(), con);
        #
        #    this.info('int');
        #
        #    arr = new Array(Types::Integer);
        #    arr.value(1, 1);
        #    arr.value(2, 2);
        #    arr.value(3, 3);
        #
        #    con = ArrayUtil::toCon(arr);
        #    this.assertEquals([1, 2, 3], con);
        #
        #    this.info('str');
        #
        #    arr = new Array(Types::String);
        #    arr.value(1, 'a');
        #    arr.value(2, 'b');
        #    arr.value(3, 'c');
        #
        #    con = ArrayUtil::toCon(arr);
        #    this.assertEquals(["a", "b", "c"], con);
        #
        #    this.info('class');
        #
        #    arr = new Array(Types::Class);
        #    arr.value(1, Any::construct(1));
        #    arr.value(2, Any::construct(2));
        #    arr.value(3, Any::construct(3));
        #
        #    con = ArrayUtil::toCon(arr);
        #    this.assertEquals(connull(), con);
        #}
      ENDSOURCE
      SOURCE #testToList
        #void testToList()
        #{
        #    Array arr;
        #    List list;
        #
        #    this.info('null');
        #
        #    arr = null;
        #    list = ArrayUtil::toList(arr);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    arr = new Array(Types::Integer);
        #    arr.value(1, 1);
        #    arr.value(2, 2);
        #    arr.value(3, 3);
        #
        #    list = ArrayUtil::toList(arr);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::Integer, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<1, 2, 3>', list.toString());
        #
        #    this.info('str');
        #
        #    arr = new Array(Types::String);
        #    arr.value(1, 'a');
        #    arr.value(2, 'b');
        #    arr.value(3, 'c');
        #
        #    list = ArrayUtil::toList(arr);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::String, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<"a", "b", "c">', list.toString());
        #
        #    this.info('class');
        #
        #    arr = new Array(Types::Class);
        #    arr.value(1, Any::construct('a'));
        #    arr.value(2, Any::construct('b'));
        #    arr.value(3, Any::construct('c'));
        #
        #    list = ArrayUtil::toList(arr);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::Class, list.typeId());
        #    this.assertEquals(3, list.elements());
        #}
      ENDSOURCE
      SOURCE #testToSet
        #void testToSet()
        #{
        #    Array arr;
        #    Set set;
        #
        #    this.info('null');
        #
        #    arr = null;
        #    set = ArrayUtil::toSet(arr);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    arr = new Array(Types::Integer);
        #    arr.value(1, 1);
        #    arr.value(2, 2);
        #    arr.value(3, 3);
        #
        #    set = ArrayUtil::toSet(arr);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    arr = new Array(Types::String);
        #    arr.value(1, 'a');
        #    arr.value(2, 'b');
        #    arr.value(3, 'c');
        #
        #    set = ArrayUtil::toSet(arr);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    arr = new Array(Types::Class);
        #    arr.value(1, Any::construct('a'));
        #    arr.value(2, Any::construct('b'));
        #    arr.value(3, Any::construct('c'));
        #
        #    set = ArrayUtil::toSet(arr);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Class, set.typeId());
        #    this.assertEquals(3, set.elements());
        #}
      ENDSOURCE
      SOURCE #testToStr
        #void testToStr()
        #{
        #    Array arr;
        #    str s;
        #
        #    this.info('null');
        #
        #    arr = null;
        #    s = ArrayUtil::toStr(arr);
        #    this.assertEquals('', s);
        #
        #    this.info('int');
        #
        #    arr = new Array(Types::Integer);
        #    arr.value(1, 1);
        #    arr.value(2, 2);
        #    arr.value(3, 3);
        #
        #    s = ArrayUtil::toStr(arr);
        #    this.assertEquals('1,2,3', s);
        #
        #    this.info('str');
        #
        #    arr = new Array(Types::String);
        #    arr.value(1, 'a');
        #    arr.value(2, 'b');
        #    arr.value(3, 'c');
        #
        #    s = ArrayUtil::toStr(arr);
        #    this.assertEquals('a,b,c', s);
        #
        #    this.info('class');
        #
        #    arr = new Array(Types::Class);
        #    arr.value(1, Any::construct('a'));
        #    arr.value(2, Any::construct('b'));
        #    arr.value(3, Any::construct('c'));
        #
        #    s = ArrayUtil::toStr(arr, ': ');
        #    this.assertEquals('a: b: c', s);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ConUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ConUtil
    PROPERTIES
      Name                #ConUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ConUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static container add(container con, anytype value)
        #{
        #    if( AnytypeUtil::isPrimitive(value) )
        #    {
        #        con += value;
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addAll
        #public static container addAll(container con, anytype collectionOrValue, int maxElements = 0)
        #{
        #    int elements;
        #    Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        con = ConUtil::add(con, e.current());
        #
        #        elements++;
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addFieldValue
        #// добавляет значение поля из буфера
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #public static container addFieldValue(container con, Common buf, FieldId fieldId)
        #{
        #    anytype value = RecordFieldUtil::getValue(buf, fieldId);
        #    ;
        #
        #    con = ConUtil::add(con, value); // добавляем значение поля как значение. Не раскрываем контейнер из поля.
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addFromQuery
        #// добавляет значения поля из буфера, который был заполнен командой Query
        #//
        #public static container addFromQuery(container con, Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    ;
        #
        #    con = ConUtil::addFromQueryRun(con, qr, tableId, fieldId, maxElements);
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addFromQueryRun
        #// добавляет значение поля из буфера, который был заполнен QueryRun
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #//
        #public static container addFromQueryRun(container con, QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #    common rec;
        #    ;
        #
        #    while( qr && qr.next() && (maxElements == 0 || elements < maxElements) )
        #    {
        #        rec = qr.get(tableId);
        #        con = ConUtil::addFieldValue(con, rec, fieldId);
        #
        #        elements++;
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addFromSelect
        #// добавляет значения поля из буфера, который был заполнен командой select
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #//
        #public static container addFromSelect(container con, Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #
        #    while( selectedRecord && (maxElements == 0 || elements < maxElements) )
        #    {
        #        con = ConUtil::addFieldValue(con, selectedRecord, fieldId);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #addVector
        #// трактует текущий контейнер и добавляемую коллекцию как компоненты векторов
        #// возвращает новый контейнер, компоненты которого являются суммами соответствующих компонент иcходного и добавляемого векторов
        #// причем сумма numeric
        #public static container addVector(container con, anytype collectionOrValue, int maxElements = 0)
        #{
        #    EEnumerator e   = EnumeratorUtil::getEEnumerator(collectionOrValue);
        #    int         elements;
        #    Any         any;
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        any = Any::conpeek(con, e.currentIdx());
        #
        #        con = ConUtil::poke(con, e.currentIdx(), any.addOrValue2(e.current()));
        #
        #        elements++;
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #contains
        #public static boolean contains(container con, anytype value)
        #{
        #    boolean ret = (confind(con, value) != 0);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAll
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если контейнер содержит все значения из collection
        #public static boolean containsAll(container con, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( ret && e && e.moveNext() )
        #    {
        #        ret = ret && (confind(con, e.current()) != 0);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAny
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если контейнер содержит любое значение из collection
        #public static boolean containsAny(container con, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = (confind(con, e.current()) != 0);
        #
        #        if( ret )
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsType
        #public static boolean containsType(container con, Types type, int potentialAncestorId = 0)
        #{
        #    boolean ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( AnytypeUtil::is(conpeek(con,i), type, potentialAncestorId) )
        #        {
        #            ret = true;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #conView
        #public static FormRun conView(container con, str caption = '', boolean lookup = false)
        #{
        #    return conView(con, caption, lookup);
        #}
      ENDSOURCE
      SOURCE #count
        #public static int count(container con, anytype value)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( conpeek(con,i) == value )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countAny
        #public static int countAny(container con, anytype valueOrCollection)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( CollectionUtil::in(conpeek(con,i), valueOrCollection) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countEmpty
        #public static int countEmpty(container con)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( !conpeek(con,i) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countNotEmpty
        #public static int countNotEmpty(container con)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( conpeek(con,i) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countType
        #public static int countType(container con, Types type, int potentialAncestorId = 0)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( AnytypeUtil::is(conpeek(con,i), type, potentialAncestorId) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #delete
        #public static container delete(container con, int startFrom, int number = 1)
        #{
        #    container ret = condel(con, startFrom, number);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #distinct
        #// возвращает новый контейнер, в котором присутствуют только уникальные объекты (дубли удалены)
        #public static container distinct(container con)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        if( !confind(ret, conpeek(con, i)) )
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #public static container drop(container con, int n = 1)
        #{
        #    container ret = ConUtil::slice(con, 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #dropEnd
        #public static container dropEnd(container con, int n = 1)
        #{
        #    container ret = ConUtil::slice(con, 1, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #// Создан для "похожести" с ListUtil, SetUtil, ArrayUtil
        #// @see len
        #public static int elements(container con)
        #{
        #    int ret = conlen(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #find
        #public static int find(container con, anytype value, int occurrence = 1)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i = 1; occurrence > 0 && i <= len; i++ )
        #    {
        #        if( AnytypeUtil::isEqual(value, conpeek(con, i)) )
        #        {
        #            occurrence--;
        #            if( occurrence <= 0 )
        #            {
        #                ret = i;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findAny
        #public static int findAny(container con, anytype valueOrCollection)
        #{
        #    int ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( CollectionUtil::in(conpeek(con, i), valueOrCollection) )
        #        {
        #            ret = i;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #// возвращает элемент контейнера. скорее всего, это не контейнер.
        #// поэтому если вызывающий алгоритм знает, что положено в контейнер, то вызывающий алгоритм может не парится с проверками
        #//
        #// @see head - синоним
        #// @see last
        #public static anytype first(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #flat
        #// возвращает новый контейнер, в котором все элементы расположены на первом уровне, а внутри нет вложенных контейнеров
        #public static container flat(container con)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        if( typeof(conpeek(con, i)) == Types::Container )
        #        {
        #            ret += ConUtil::flat(conpeek(con, i));
        #        }
        #        else
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ConEnumerator getEnumerator(container con)
        #{
        #    ConEnumerator ret;
        #
        #    if( con )
        #    {
        #        ret = ConEnumerator::construct(con);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorAndSkip
        #public static ConEnumerator getEnumeratorAndSkip(container con, int skipIterations)
        #{
        #    ConEnumerator ret = ConUtil::getEnumerator(con);
        #
        #    if( ret && !EnumeratorUtil::skip(ret, skipIterations) )
        #    {
        #        ret = null;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #head
        #// возвращает элемент контейнера. скорее всего, это не контейнер.
        #// поэтому если вызывающий алгоритм знает, что положено в контейнер, то вызывающий алгоритм может не парится с проверками
        #//
        #// @see first - синоним
        #public static anytype head(container con)
        #{
        #    anytype ret = ConUtil::first(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #// метод возвращает true, если value содержится в контейнере
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #//
        #// Например:
        #//
        #// if( predicat1 ||
        #//     ConUtil::in( predicat2, [
        #//         Status::s1,
        #//         Status::s4,
        #//         Status::s7
        #//     ])
        #//
        #public static boolean in(anytype value, container con)
        #{
        #    boolean ret = (confind(con, value) != 0);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #public static container insert(container con, anytype element, int start = 1)
        #{
        #    container ret = conins(con, start, element);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(container con)
        #{
        #    boolean ret = true;
        #
        #    if( con )
        #    {
        #        ret = false;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(container con)
        #{
        #    boolean ret = false;
        #
        #    if( con )
        #    {
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #item
        #// первый элемент имеет индекс 1
        #// работает быстро. создан для "похожести" с ListUtil, SetUtil, ArrayUtil, CollectionUtil
        #//
        #// однако для conpeek имеет особенность:
        #// если индекс <= 0 или >= conlen, то conpeek возвращает [int]0, а не AnytypeUtil::undefined()
        #//
        #// метод item не переопределяет это поведение ради производительности
        #//
        #public static anytype item(container con, int idx)
        #{
        #    anytype ret = conpeek(con, idx);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAs
        #public static anytype itemAs(container con, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype value = conpeek(con, idx);
        #    anytype ret = AnytypeUtil::as(value, type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAsValue
        #public static anytype itemAsValue(container con, int idx, anytype asValue)
        #{
        #    anytype ret = AnytypeUtil::asValue(conpeek(con, idx), asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #last
        #// возвращает элемент контейнера. скорее всего, это не контейнер.
        #// поэтому если вызывающий алгоритм знает, что положено в контейнер, то вызывающий алгоритм может не парится с проверками
        #//
        #// @see first
        #// @see head
        #public static anytype last(container con)
        #{
        #    int lastPos = conlen(con);
        #    anytype ret = conpeek(con, lastPos);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #match
        #// проверяет есть ли вхожение паттерна в какую-нибудь строку внутри контейнера
        #// проверку выполняет рекурсивно
        #public static boolean match(
        #    str         pattern,
        #    container   con)
        #{
        #    int     len     = conlen(con);
        #    int     i;
        #    Any     value;
        #
        #    for( i=1; i<=len; ++i )
        #    {
        #        value = Any::conpeek(con, i);
        #
        #        switch( value.type() )
        #        {
        #            case Types::String:
        #            case Types::RString:
        #            case Types::VarString:
        #                if( match(pattern, value.asString()) )
        #                    return true;
        #                break;
        #
        #            case Types::Container:
        #                if( ConUtil::match(pattern, value.asContainer()) )
        #                    return true;
        #                break;
        #
        #            case Types::Record:
        #                if( RecordUtil::match(pattern, value.asRecord()) )
        #                    return true;
        #                break;
        #
        #            default:
        #                break;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #maxAll
        #public static anytype maxAll(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    Types type = typeof(ret);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2; i<=len; i++ )
        #    {
        #        if( typeof(conpeek(con, i)) == type )
        #        {
        #            ret = max(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #maxAs
        #public static anytype maxAs(container con, Types type)
        #{
        #    anytype ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( typeof(conpeek(con,i)) == type )
        #        {
        #            if( typeof(ret) == AnytypeUtil::undefined() )
        #            {
        #                ret = conpeek(con, i);
        #            }
        #            else
        #            {
        #                ret = max(ret, conpeek(con, i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #maxAsValue
        #// возвращает максимум элементов, тип которых совпадает с типом второго параметра
        #//
        #// метод удобно использовать, передавая как второй параметр переменную,
        #// в которую будете разместите результат
        #//
        #// пример использования:
        #//     container con = [1, 'test', 2, 3.01];
        #//     int maxValue = ConUtil::maxAs(con, maxValue); // метод вернет 2
        #//
        #public static anytype maxAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::maxAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minAll
        #public static anytype minAll(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    Types type = typeof(ret);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2; i<=len; i++ )
        #    {
        #        if( typeof(conpeek(con, i)) == type )
        #        {
        #            ret = min(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minAs
        #public static anytype minAs(container con, Types type)
        #{
        #    anytype ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( typeof(conpeek(con,i)) == type )
        #        {
        #            if( typeof(ret) == Types::AnyType )
        #            {
        #                ret = conpeek(con, i);
        #            }
        #            else
        #            {
        #                ret = min(ret, conpeek(con, i));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #minAsValue
        #// возвращает минимум элементов, тип которых совпадает с типом второго параметра
        #//
        #// метод удобно использовать, передавая как второй параметр переменную,
        #// в которую будете разместите результат
        #//
        #// пример использования:
        #//     container con = [1, 'test', 2, 3.01];
        #//     int minValue = ConUtil::minAs(con, minValue); // метод вернет 1
        #//
        #public static anytype minAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::minAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static container newFrom(anytype valueOrCollection, int maxElements = 0)
        #{
        #    container ret = ConUtil::addAll(ret, valueOrCollection, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #public static container newFromArray(Array arr, int maxElements = 0)
        #{
        #    container ret;
        #    int i;
        #
        #    if( TypeUtil::isPrimitive(ArrayUtil::type(arr)) )
        #    {
        #        for( i=1; arr && i<=arr.lastIndex() && (maxElements == 0 || i <= maxElements); ++i )
        #        {
        #            ret += [arr.value(i)];
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromBlob
        #public static container newFromBlob(container blob)
        #{
        #    return ContainerClass::blob2Container(blob);
        #}
      ENDSOURCE
      SOURCE #newFromBuf
        #public static container newFromBuf(Common buffer)
        #{
        #    // первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        #    container ret = [buffer.TableId, buffer];
        #    ;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static container newFromList(List list, int maxElements = 0)
        #{
        #    container ret;
        #    int elements;
        #    ListEnumerator le;
        #
        #    if( TypeUtil::isPrimitive(ListUtil::type(list)) )
        #    {
        #        le = ListUtil::getEnumerator(list);
        #
        #        while( le && le.moveNext() && (maxElements == 0 || elements < maxElements) )
        #        {
        #            ret += [le.current()];
        #
        #            elements++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromMap
        #public static container newFromMap(Map map, int maxElements = 0)
        #{
        #    container ret;
        #    int elements;
        #    MapEnumerator me;
        #
        #    if( TypeUtil::isPrimitive(MapUtil::keyType(map)) &&
        #        TypeUtil::isPrimitive(MapUtil::valueType(map)) )
        #    {
        #        me = MapUtil::getEnumerator(map);
        #
        #        while( me && me.moveNext() && (maxElements == 0 || elements < maxElements) )
        #        {
        #            ret += [[me.currentKey(), me.currentValue()]];
        #
        #            elements++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQuery
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static container newFromQuery(Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    container ret = ConUtil::addFromQuery(connull(), q, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQueryRun
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static container newFromQueryRun(QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    container ret = ConUtil::addFromQueryRun(connull(), qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает контейнер значений поля из буфера, который был заполнен командой select
        #public static container newFromSelect(Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    container ret = ConUtil::addFromSelect(connull(), selectedRecord, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static container newFromSet(Set set, int maxElements = 0)
        #{
        #    container ret;
        #    int elements;
        #    SetEnumerator se;
        #
        #    if( TypeUtil::isPrimitive(SetUtil::type(set)) )
        #    {
        #        se = SetUtil::getEnumerator(set);
        #
        #        while( se && se.moveNext() && (maxElements == 0 || elements < maxElements) )
        #        {
        #            ret += [se.current()];
        #
        #            elements++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static container newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    container ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ConUtil::add(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromXml
        #public static container newFromXml(XmlNode node)
        #{
        #    return Global::containerFromXMLNode(node);
        #}
      ENDSOURCE
      SOURCE #notIn
        #// метод возвращает true, если value не содержится в контейнере
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #//
        #// Например:
        #//
        #// if( predicat1 ||
        #//     ConUtil::CopyOfin( predicat2, [
        #//         Status::s1,
        #//         Status::s4,
        #//         Status::s7
        #//     ])
        #//
        #public static boolean notIn(anytype value, container con)
        #{
        #    boolean ret = (confind(con, value) == 0);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peek
        #// первый элемент имеет индекс 1
        #//
        #// conpeek имеет особенность:
        #// если индекс <= 0 или >= conlen, то conpeek возвращает [int]0, а не AnytypeUtil::undefined()
        #//
        #public static anytype peek(container con, int idx)
        #{
        #    anytype ret = conpeek(con, idx);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAs
        #// @deprecated, see itemAs
        #public static anytype peekAs(container con, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype ret = ConUtil::itemAs(con, idx, type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsContainer
        #// @deprecated, see itemAs
        #public static container peekAsContainer(container con, int idx)
        #{
        #    container ret = ConUtil::itemAs(con, idx, Types::Container);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsDate
        #// @deprecated, see itemAs
        #public static Date peekAsDate(container con, int idx)
        #{
        #    Date ret = ConUtil::itemAs(con, idx, Types::Date);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsDateTime
        #// @deprecated, see itemAs
        #public static UtcDateTime peekAsDateTime(container con, int idx)
        #{
        #    utcdatetime ret = ConUtil::itemAs(con, idx, Types::UtcDateTime);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsEnum
        #// @deprecated, see itemAs
        #public static anytype peekAsEnum(container con, int idx, enumId enumId = 0)
        #{
        #    anytype ret = ConUtil::itemAs(con, idx, Types::Enum, enumId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsGUID
        #// @deprecated, see itemAs
        #public static GUID peekAsGUID(container con, int idx)
        #{
        #    GUID ret = ConUtil::itemAs(con, idx, Types::Guid);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsInt
        #// @deprecated, see itemAs
        #public static int peekAsInt(container con, int idx)
        #{
        #    int ret = ConUtil::itemAs(con, idx, Types::Integer);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsInt64
        #// @deprecated, see itemAs
        #public static Int64 peekAsInt64(container con, int idx)
        #{
        #    Int64 ret = ConUtil::itemAs(con, idx, Types::Int64);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsReal
        #// @deprecated, see itemAs
        #public static Real peekAsReal(container con, int idx)
        #{
        #    Real ret = ConUtil::itemAs(con, idx, Types::Real);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsRecId
        #// @deprecated, see itemAs
        #public static int64 peekAsRecId(container con, int idx)
        #{
        #    Int64 ret = ConUtil::itemAs(con, idx, Types::Int64);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsRecord
        #// @deprecated, see itemAs
        #public static Common peekAsRecord(container con, int idx, TableId tableId = 0)
        #{
        #    Common ret = ConUtil::itemAs(con, idx, Types::Record, tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #peekAsValue
        #// @deprecated, see itemAsValue
        #public static anytype peekAsValue(container con, int idx, anytype asValue)
        #{
        #    anytype ret = AnytypeUtil::asValue(conpeek(con, idx), asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #poke
        #// выполняет poke, если value содержит примитивное значение, которое можно положить в контейнер
        #// иначе ничего не делает
        #//
        #// штатная функция conpoke
        #// изменяет значение в контейнере, если позиция start указывает внутрь контейнера
        #// добавляет значение в конец контейнера, если позиция start указывает за контрейнер
        #// ничего не делает, если start <= 0
        #//
        #public static container poke(container con, int start, anytype value)
        #{
        #    if( start >= 1 && AnytypeUtil::isPrimitive(value) )
        #    {
        #        con = conpoke(con, start, value);
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #remove
        #// удаляет значение из контейнера
        #//
        #// @param occurrence указывает какое вхождение значения нужно удалить
        #//
        #// @see removeAll
        #public static container remove(container con, anytype value, int occurrence = 1)
        #{
        #    int i = ConUtil::find(con, value, occurrence);
        #
        #    if( i )
        #    {
        #        con = condel(con, i, 1);
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #removeAll
        #// удаляет все значения из контейнера
        #public static container removeAll(container con, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    int i;
        #
        #    while( e && e.moveNext() )
        #    {
        #        do
        #        {
        #            i = confind(con, e.current());
        #
        #            if( i )
        #            {
        #                con = condel(con, i, 1);
        #            }
        #        }
        #        while( i );
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый контейнер, в котором удалены все пустые элементы
        #public static container removeEmpty(container con)
        #{
        #    int len = conlen(con);
        #    int i;
        #    container ret;
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        if( conpeek(con, i) )
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeType
        #public static container removeType(container con, Types type, int potentialAncestorId = 0)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( !AnytypeUtil::is(conpeek(con,i), type, potentialAncestorId) )
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainAll
        #// возвращает новый контейнер, в котором остались элементы, которые содержатся в коллекции 2
        #public static container retainAll(container con, anytype valueOrCollection)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( CollectionUtil::in(conpeek(con, i), valueOrCollection) )
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainType
        #// возвращает новый контейнер, в котором остались элементы указанного типа
        #public static container retainType(container con, Types type, int potentialAncestorId = 0)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( AnytypeUtil::is(conpeek(con, i), type, potentialAncestorId) )
        #        {
        #            ret = ConUtil::add(ret, conpeek(con, i));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reverse
        #public static container reverse(container con)
        #{
        #    container ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=len ; i > 0 ; i-- )
        #    {
        #        ret = ConUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #slice
        #public static container slice(container con, int fromPos = 1, int toPos = -1, int step = 1)
        #{
        #    container ret;
        #
        #    int len     = conlen(con);
        #
        #    int fromIdx = fromPos + (fromPos < 0 ? len + 1 : 0);
        #    int toIdx   = toPos   + (toPos < 0 ? len + 1 : 0);
        #
        #    int i       = max(1, fromIdx);
        #    int end     = min(len, toIdx);
        #    ;
        #
        #    if( i <= 1 && end >= len && step == 1 )
        #    {
        #        ret = con;
        #    }
        #    else if( step > 0 )
        #    {
        #        while( i <= end )
        #        {
        #            ret += conpeek(con, i);
        #            i += step;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAll
        #public static anytype sumAll(container con)
        #{
        #    anytype ret = conpeek(con, 1);
        #    int len = conlen(con);
        #    int i;
        #
        #    for( i=2 ; i<=len ; i++ )
        #    {
        #        ret += conpeek(con, i);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAs
        #public static anytype sumAs(container con, Types type)
        #{
        #    anytype ret;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( typeof(ce.current()) == type )
        #        {
        #            ret += ce.current();
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAsStr
        #public static str sumAsStr(container con)
        #{
        #    str ret;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( AnytypeUtil::isString(ce.current()) )
        #        {
        #            ret += ce.current();
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #sumAsValue
        #public static anytype sumAsValue(container con, anytype valueWithType)
        #{
        #    Types type = typeof(valueWithType);
        #    anytype ret = ConUtil::sumAs(con, type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #tail
        #public static container tail(container con)
        #{
        #    container ret = ConUtil::slice(con, 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #public static container take(container con, int n, int startFrom = 1)
        #{
        #    container ret = ConUtil::slice(con, startFrom, startFrom + n - 1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #takeEnd
        #public static container takeEnd(container con, int n = 1)
        #{
        #    container ret = ConUtil::slice(con, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toArray
        #public static Array toArray(container con)
        #{
        #    Array ret = ArrayUtil::newFromContainer(con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toBlob
        #public static container toBlob(container con)
        #{
        #    ContainerClass containerClass = new ContainerClass(con);
        #
        #    return containerClass.toBlob();
        #}
      ENDSOURCE
      SOURCE #toBuf
        #// первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        #// возможны проблемы, если после создания container таблица изменена в AOT.
        #// метод работает очень быстро.
        #public static Common toBuf(container con)
        #{
        #    TableId tableId = ConUtil::itemAs(con, 1, Types::Integer);
        #    Common ret;
        #
        #    if( tableId )
        #    {
        #        ret = ConUtil::itemAs(con, 2, Types::Record, tableId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #public static List toList(container con, List list = null)
        #{
        #    List ret = ListUtil::addAll(list, con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toSet
        #public static Set toSet(container con, Set set = null)
        #{
        #    Set ret = SetUtil::addAll(set, con);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(container con, str sep = ',')
        #{
        #    str ret = TextBufferUtil::appendContainer(null, con, sep).getText();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toXmlString
        #public static str toXmlString(container con, int indent = 0)
        #{
        #    return Global::XMLString(con, types::Container, indent);
        #}
      ENDSOURCE
      SOURCE #typeofAll
        #// возвращает
        #//   Types::void - если контейнер пуст
        #//   Types::AnyType - если в контейнере содержатся элементы разного типа
        #//   Types::* - если все элементы одного типа
        #public static Types typeofAll(container con)
        #{
        #    Types type = Types::void;
        #    ConEnumerator ce = ConEnumerator::construct(con);
        #
        #    if( ce && ce.moveNext() )
        #    {
        #        type = typeof(ce.current());
        #    }
        #
        #    while( ce && ce.moveNext() )
        #    {
        #        if( type != typeof(ce.current()) )
        #        {
        #            return Types::AnyType;
        #        }
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #zip
        #public static container zip(container con1, container con2, int maxElements = 0)
        #{
        #    container   ret;
        #    int         minLen = min(conlen(con1), conlen(con2));
        #    int         idx;
        #
        #    if( maxElements )
        #    {
        #        minLen = min(minLen, maxElements);
        #    }
        #
        #    for (idx = 1; idx <= minlen; idx++)
        #    {
        #        ret += conpeek(con1, idx) + conpeek(con2, idx);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ConUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ConUtilTest
    PROPERTIES
      Name                #ConUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class ConUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAddVector
        #void testAddVector()
        #{
        #    this.info('normal');
        #    this.assertEquals([1, 0.5, 3.0], ConUtil::addVector([0, 0.5, 1], [1, 0, 2.0]));
        #
        #    this.info('info string');
        #    this.assertEquals([1, 0.5, 'added', 3.0], ConUtil::addVector([0, 0.5, 'init', 1], [1, 0, 'added', 2.0]));
        #
        #    this.info('parm contaner');
        #    this.assertEquals([1, 0.5, 3.0, ['init','added']], ConUtil::addVector([0, 0.5, 1, ['init']], [1, 0, 2.0, 'added']));
        #    this.assertEquals([1, 0.5, 3.0, ['init','added']], ConUtil::addVector([0, 0.5, 1, ['init']], [1, 0, 2.0, ['added']]));
        #
        #    this.info('flag');
        #    this.assertEquals([1, 0.5, 3.0, false], ConUtil::addVector([0, 0.5, 1],       [1, 0, 2.0, false]));
        #    this.assertEquals([1, 0.5, 3.0, true],  ConUtil::addVector([0, 0.5, 1, true], [1, 0, 2.0]));
        #
        #    this.info('enum');
        #    this.assertEquals([1, 0.5, 3.0, StatusIssue::Sold], ConUtil::addVector([0, 0.5, 1, StatusIssue::OnOrder], [1, 0, 2.0, StatusIssue::Sold]));
        #
        #    this.info('empty init');
        #    this.assertEquals([1, 0, 2.0], ConUtil::addVector(connull(), [1, 0, 2.0]));
        #
        #    this.info('empty value');
        #    this.assertEquals([1, 0, 2.0], ConUtil::addVector([1, 0, 2.0], connull()));
        #
        #    this.info('long value');
        #    this.assertEquals([2, 0, 2.0], ConUtil::addVector([1], [1, 0, 2.0]));
        #
        #    this.info('short value');
        #    this.assertEquals([2, 0, 2.0], ConUtil::addVector([1, 0, 2.0], [1]));
        #
        #}
      ENDSOURCE
      SOURCE #testDelete
        #void testDelete()
        #{
        #    container con =  ['a','b','c','d','e','f','g','i','j'];
        #
        #    this.assertEquals(['a','c','d','e','f','g','i','j'], ConUtil::delete(con, 2));
        #    this.assertEquals(['a','e','f','g','i','j'],         ConUtil::delete(con, 2, 3));
        #
        #    this.info('number <= 0');
        #
        #    this.assertEquals(con, ConUtil::delete(con, 2, 0));
        #    this.assertEquals(con, ConUtil::delete(con, 2, -1));
        #
        #    this.info('out of bounds');
        #
        #    this.assertEquals(con, ConUtil::delete(con, 0));
        #    this.assertEquals(con, ConUtil::delete(con, 10));
        #    this.assertEquals(con, ConUtil::delete(con, -1));
        #
        #    this.info('out of bounds, number = 3');
        #
        #    this.assertEquals(con, ConUtil::delete(con, 0, 3));
        #    this.assertEquals(con, ConUtil::delete(con, 10, 3));
        #    this.assertEquals(con, ConUtil::delete(con, -1, 3));
        #}
      ENDSOURCE
      SOURCE #testElements
        #void testElements()
        #{
        #    container con = ['a','b','c','d','e','f','g','i','j'];
        #
        #    this.assertEquals(9, ConUtil::elements(con));
        #}
      ENDSOURCE
      SOURCE #testFind
        #void testFind()
        #{
        #    container con =  ['a','b','c','d','e','f','b','i','j'];
        #
        #    this.assertEquals(2, ConUtil::find(con, 'b'));
        #    this.assertEquals(2, ConUtil::find(con, 'b', 1));
        #    this.assertEquals(7, ConUtil::find(con, 'b', 2));
        #
        #    this.info('not found');
        #
        #    this.assertEquals(0, ConUtil::find(con, 'z'));
        #    this.assertEquals(0, ConUtil::find(con, 1));
        #    this.assertEquals(0, ConUtil::find(con, null));
        #
        #    this.info('null');
        #
        #    this.assertEquals(0, ConUtil::find(connull(), 'a'));
        #}
      ENDSOURCE
      SOURCE #testItem
        #void testItem()
        #{
        #    container con = ['a','b','c','d','e','f','g','i','j'];
        #
        #    this.info('correct idx');
        #
        #    this.assertEquals('b', ConUtil::item(con, 2));
        #    this.assertEquals('c', ConUtil::item(con, 3));
        #    this.assertEquals('j', ConUtil::item(con, 9));
        #
        #    this.info('out of bounds');
        #
        #    this.assertEquals(0, ConUtil::item(con, 0));
        #    this.assertEquals(0, ConUtil::item(con, 10));
        #    this.assertEquals(0, ConUtil::item(con, 22));
        #    this.assertEquals(0, ConUtil::item(con, -1));
        #    this.assertEquals(0, ConUtil::item(con, -4));
        #}
      ENDSOURCE
      SOURCE #testNewFromArray
        #void testNewFromArray()
        #{
        #    container con;
        #    Array fromArray;
        #
        #    this.info('null');
        #
        #    fromArray = null;
        #    con = ConUtil::newFromArray(fromArray);
        #    this.assertEquals(0, conlen(con));
        #
        #    this.info('int');
        #
        #    fromArray = new Array(Types::Integer);
        #    fromArray.value(1,1);
        #    fromArray.value(2,2);
        #    fromArray.value(3,3);
        #
        #    con = ConUtil::newFromArray(fromArray);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(1, conpeek(con,1));
        #    this.assertEquals(2, conpeek(con,2));
        #    this.assertEquals(3, conpeek(con,3));
        #
        #    this.info('str');
        #
        #    fromArray = new Array(Types::String);
        #    fromArray.value(1,'a');
        #    fromArray.value(2,'b');
        #    fromArray.value(3,'c');
        #
        #    con = ConUtil::newFromArray(fromArray);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals('a', conpeek(con,1));
        #    this.assertEquals('b', conpeek(con,2));
        #    this.assertEquals('c', conpeek(con,3));
        #
        #    this.info('container');
        #
        #    fromArray = new Array(Types::Container);
        #    fromArray.value(1, ['a', 1]);
        #    fromArray.value(2, ['b', 'c']);
        #    fromArray.value(3, [4, 'd']);
        #
        #    con = ConUtil::newFromArray(fromArray);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(['a', 1], conpeek(con,1));
        #    this.assertEquals(['b', 'c'], conpeek(con,2));
        #    this.assertEquals([4, 'd'], conpeek(con,3));
        #}
      ENDSOURCE
      SOURCE #testNewFromList
        #void testNewFromList()
        #{
        #    container con;
        #    List fromList;
        #
        #    this.info('null');
        #
        #    fromList = null;
        #    con = ConUtil::newFromList(fromList);
        #    this.assertEquals(0, conlen(con));
        #
        #    this.info('int');
        #
        #    fromList = new List(Types::Integer);
        #    fromList.addEnd(1);
        #    fromList.addEnd(2);
        #    fromList.addEnd(3);
        #
        #    con = ConUtil::newFromList(fromList);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(1, conpeek(con,1));
        #    this.assertEquals(2, conpeek(con,2));
        #    this.assertEquals(3, conpeek(con,3));
        #
        #    this.info('str');
        #
        #    fromList = new List(Types::String);
        #    fromList.addEnd('a');
        #    fromList.addEnd('b');
        #    fromList.addEnd('c');
        #
        #    con = ConUtil::newFromList(fromList);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals('a', conpeek(con,1));
        #    this.assertEquals('b', conpeek(con,2));
        #    this.assertEquals('c', conpeek(con,3));
        #
        #    this.info('container');
        #
        #    fromList = new List(Types::Container);
        #    fromList.addEnd(['a', 1]);
        #    fromList.addEnd(['b', 'c']);
        #    fromList.addEnd([4, 'd']);
        #
        #    con = ConUtil::newFromList(fromList);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(['a', 1], conpeek(con,1));
        #    this.assertEquals(['b', 'c'], conpeek(con,2));
        #    this.assertEquals([4, 'd'], conpeek(con,3));
        #}
      ENDSOURCE
      SOURCE #testNewFromSet
        #void testNewFromSet()
        #{
        #    container con;
        #    Set fromSet;
        #
        #    this.info('null');
        #
        #    fromSet = null;
        #    con = ConUtil::newFromSet(fromSet);
        #    this.assertEquals(0, conlen(con));
        #
        #    this.info('int');
        #
        #    fromSet = new Set(Types::Integer);
        #    fromSet.add(1);
        #    fromSet.add(2);
        #    fromSet.add(3);
        #
        #    con = ConUtil::newFromSet(fromSet);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(1, conpeek(con,1));
        #    this.assertEquals(2, conpeek(con,2));
        #    this.assertEquals(3, conpeek(con,3));
        #
        #    this.info('str');
        #
        #    fromSet = new Set(Types::String);
        #    fromSet.add('a');
        #    fromSet.add('b');
        #    fromSet.add('c');
        #
        #    con = ConUtil::newFromSet(fromSet);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals('a', conpeek(con,1));
        #    this.assertEquals('b', conpeek(con,2));
        #    this.assertEquals('c', conpeek(con,3));
        #
        #    this.info('container');
        #
        #    fromSet = new Set(Types::Container);
        #    fromSet.add(['a', 1]);
        #    fromSet.add(['b', 'c']);
        #    fromSet.add([4, 'd']);
        #
        #    con = ConUtil::newFromSet(fromSet);
        #    this.assertEquals(3, conlen(con));
        #    this.assertEquals(['a', 1], conpeek(con,1));
        #    this.assertEquals(['b', 'c'], conpeek(con,2));
        #    this.assertEquals([4, 'd'], conpeek(con,3));
        #}
      ENDSOURCE
      SOURCE #testPeek
        #void testPeek()
        #{
        #    container con;
        #
        #    this.info('normal');
        #    this.assertEquals([1,'xyz',3], ConUtil::poke([1,2,3], 2, 'xyz'));
        #
        #    this.info('last');
        #    this.assertEquals([1,2,'xyz'], ConUtil::poke([1,2,3], 3, 'xyz'));
        #
        #    this.info('last+1');
        #    this.assertEquals([1,2,3,'xyz'], ConUtil::poke([1,2,3], 4, 'xyz'));
        #
        #    this.info('empty');
        #    this.assertEquals(['xyz'], ConUtil::poke(connull(), 2, 'xyz'));
        #
        #    this.info('out of bounds');
        #    this.assertEquals([1,2,3,'xyz'], ConUtil::poke([1,2,3], 10, 'xyz'));
        #
        #    this.info('zero');
        #    this.assertEquals([1,2,3], ConUtil::poke([1,2,3], 0, 'xyz'));
        #
        #    this.info('mius');
        #    this.assertEquals([1,2,3], ConUtil::poke([1,2,3], -100, 'xyz'));
        #}
      ENDSOURCE
      SOURCE #testPoke
        #void testPoke()
        #{
        #    container con;
        #
        #    this.info('normal');
        #    this.assertEquals([1,'xyz',3], ConUtil::poke([1,2,3], 2, 'xyz'));
        #
        #    this.info('last');
        #    this.assertEquals([1,2,'xyz'], ConUtil::poke([1,2,3], 3, 'xyz'));
        #
        #    this.info('last+1');
        #    this.assertEquals([1,2,3,'xyz'], ConUtil::poke([1,2,3], 4, 'xyz'));
        #
        #    this.info('empty');
        #    this.assertEquals(['xyz'], ConUtil::poke(connull(), 2, 'xyz'));
        #
        #    this.info('out of bounds');
        #    this.assertEquals([1,2,3,'xyz'], ConUtil::poke([1,2,3], 10, 'xyz'));
        #
        #    this.info('zero');
        #    this.assertEquals([1,2,3], ConUtil::poke([1,2,3], 0, 'xyz'));
        #
        #    this.info('mius');
        #    this.assertEquals([1,2,3], ConUtil::poke([1,2,3], -100, 'xyz'));
        #}
      ENDSOURCE
      SOURCE #testSlice
        #void testSlice()
        #{
        #    container con = [1,2,3,4,5,6,7,8,9];
        #
        #    this.info('from');
        #
        #    this.assertEquals([2,3,4,5,6,7,8,9], ConUtil::slice(con, 2));
        #    this.assertEquals([3,4,5,6,7,8,9],   ConUtil::slice(con, 3));
        #    this.assertEquals([6,7,8,9],         ConUtil::slice(con, -4));
        #
        #    this.info('from, to');
        #
        #    this.assertEquals([3,4,5,6,7,8,9],   ConUtil::slice(con, 3, 99));
        #    this.assertEquals([3,4,5,6,7,8,9],   ConUtil::slice(con, 3, -1));
        #    this.assertEquals([3,4,5,6,7,8],     ConUtil::slice(con, 3, -2));
        #    this.assertEquals(connull(),         ConUtil::slice(con, 3, 0));
        #
        #    this.info('from, to, step');
        #
        #    this.assertEquals([3,5,7,9],         ConUtil::slice(con, 3, 9, 2));
        #    this.assertEquals([2,5,8],           ConUtil::slice(con, 2, 9, 3));
        #    this.assertEquals(connull(),         ConUtil::slice(con, 2, 9, 0));
        #    this.assertEquals(connull(),         ConUtil::slice(con, 2, 9, -1));
        #}
      ENDSOURCE
      SOURCE #testToArray
        #void testToArray()
        #{
        #    container con;
        #    Array arr;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    arr = ConUtil::toArray(con);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    con = [1,2,3];
        #    arr = ConUtil::toArray(con);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals(1, arr.value(1));
        #    this.assertEquals(2, arr.value(2));
        #    this.assertEquals(3, arr.value(3));
        #
        #    this.info('str');
        #
        #    con = ['a','b','c'];
        #    arr = ConUtil::toArray(con);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::String, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('a', arr.value(1));
        #    this.assertEquals('b', arr.value(2));
        #    this.assertEquals('c', arr.value(3));
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    arr = ConUtil::toArray(con);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(1, arr.lastIndex());
        #    this.assertEquals(1, arr.value(1));
        #}
      ENDSOURCE
      SOURCE #testToBuf
        #void testToBuf()
        #{
        #    container con;
        #    tmpVoucherSum tmpVoucherSum;
        #    Common common;
        #    Common buf;
        #;
        #    tmpVoucherSum.clear();
        #    tmpVoucherSum.Voucher = 'v1';
        #    tmpVoucherSum.Debit = 100;
        #    tmpVoucherSum.SumCur = 2;
        #
        #    this.info('tmpVoucherSum');
        #
        #    con = ConUtil::newFromBuf(tmpVoucherSum);
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(tmpVoucherSum.TableId, buf.TableId);
        #    this.assertEquals(tmpVoucherSum.toString(), buf.toString());
        #
        #    this.info('connull');
        #
        #    con = connull();
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(common.TableId, buf.TableId);
        #    this.assertEquals(0, buf.RecId);
        #
        #    // потестим некорректный контейнер
        #
        #    this.info('wrong [a]');
        #
        #    con = ['a'];
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(common.TableId, buf.TableId);
        #    this.assertEquals(0, buf.RecId);
        #
        #    this.info('wrong [1, a]');
        #
        #    con = [1, 'a'];
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(common.TableId, buf.TableId);
        #    this.assertEquals(0, buf.RecId);
        #
        #    this.info('wrong [a, tmpVoucherSum]');
        #
        #    con = ['a', tmpVoucherSum];
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(common.TableId, buf.TableId);
        #    this.assertEquals(0, buf.RecId);
        #
        #    this.info('wrong [1, tmpVoucherSum]');
        #
        #    con = [1, tmpVoucherSum];
        #    buf = ConUtil::toBuf(con);
        #    this.assertEquals(common.TableId, buf.TableId);
        #    this.assertEquals(0, buf.RecId);
        #}
      ENDSOURCE
      SOURCE #testToList
        #void testToList()
        #{
        #    container con;
        #    List list;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    list = ConUtil::toList(con);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    con = [1,2,3];
        #    list = ConUtil::toList(con);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::Integer, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<1, 2, 3>', list.toString());
        #
        #    this.info('str');
        #
        #    con = ['a','b','c'];
        #    list = ConUtil::toList(con);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::String, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<"a", "b", "c">', list.toString());
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    list = ConUtil::toList(con);
        #    this.assertEquals(types::Integer, list.typeId());
        #    this.assertEquals(1, list.elements());
        #    this.assertEquals('<1>', list.toString());
        #}
      ENDSOURCE
      SOURCE #testToSet
        #void testToSet()
        #{
        #    container con;
        #    Set set;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    set = ConUtil::toSet(con);
        #    this.assertNull(set);
        #
        #    setprefix('int');
        #
        #    con = [1,2,3];
        #    set = ConUtil::toSet(con);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    con = ['a','b','c'];
        #    set = ConUtil::toSet(con);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    set = ConUtil::toSet(con);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals('{1}', set.toString());
        #}
      ENDSOURCE
      SOURCE #testToStr
        #void testToStr()
        #{
        #    container con;
        #    str s;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    s = ConUtil::toStr(con);
        #    this.assertEquals('', s);
        #
        #    this.info('int');
        #
        #    con = [1,2,3];
        #    s = ConUtil::toStr(con);
        #    this.assertEquals('1,2,3', s);
        #
        #    this.info('mix with separator');
        #
        #    con = [1,'b','c'];
        #    s = ConUtil::toStr(con, ': ');
        #    this.assertEquals('1: b: c', s);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ListUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ListUtil
    PROPERTIES
      Name                #ListUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ListUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static List add(List list, anytype value)
        #{
        #    if( !list )
        #    {
        #        list = ListUtil::newBy(value);
        #    }
        #
        #    if( list.typeId() == typeof(value) ) // значения с другим типом не будет добавлено
        #    {
        #        list.addEnd(value);
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #addAll
        #public static List addAll(List list, anytype valueOrCollection, int maxElements = 0)
        #{
        #    int elements;
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        list = ListUtil::add(list, e.current());
        #
        #        elements++;
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #addFieldValue
        #// добавляет значение поля из буфера
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #public static List addFieldValue(List list, Common buf, FieldId fieldId)
        #{
        #    anytype value = RecordFieldUtil::getValue(buf, fieldId);
        #    List ret = ListUtil::add(list, value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQuery
        #// добавляет значения поля из буфера, который был заполнен Query
        #//
        #public static List addFromQuery(List toListOrNull, Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    List ret = ListUtil::addFromQueryRun(toListOrNull, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQueryRun
        #// добавляет значения поля из буфера, который был заполнен QueryRun
        #//
        #public static List addFromQueryRun(List list, QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #    common rec;
        #    ;
        #
        #    while( qr && qr.next() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        rec = qr.get(tableId);
        #        list = ListUtil::addFieldValue(list, rec, fieldId);
        #
        #        elements++;
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #addFromSelect
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static List addFromSelect(List list, Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #    ;
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        list = ListUtil::addFieldValue(list, selectedRecord, fieldId);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #addNz
        #public static List addNz(List list, anytype value)
        #{
        #    if( value )
        #    {
        #        list = ListUtil::add(list, value);
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #addStart
        #public static List addStart(List list, anytype value)
        #{
        #    if( !list )
        #    {
        #        list = ListUtil::newBy(value);
        #    }
        #
        #    if( list.typeId() == typeof(value) ) // значения с другим типом не будет добавлено
        #    {
        #        list.addStart(value);
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #appendList
        #// по возможности перекидывает ссылки и не перемещает элементы
        #// поэтому могут возникнуть побочные эффекты
        #// используйте с осторожностью
        #public static List appendList(List list, List append)
        #{
        #    List ret;
        #
        #    if( list )
        #    {
        #        ret = list;
        #
        #        if( append )
        #        {
        #            list.appendList(append);
        #        }
        #    }
        #    else
        #    {
        #        ret = append;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонирует list, не клонирует элементы списка
        #//
        #// @see deepClone()
        #public static List clone(List list)
        #{
        #    List ret;
        #
        #    if( list )
        #    {
        #        ret = new List(list.typeId());
        #        ret.appendList(list);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #contains
        #public static boolean contains(List list, anytype value)
        #{
        #    boolean ret = ListUtil::in(value, list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAll
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если контейнер содержит все значения из collection
        #public static boolean containsAll(List list, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( ret && e && e.moveNext() )
        #    {
        #        ret = ret && (ListUtil::find(list, e.current()));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAny
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если контейнер содержит любое значение из collection
        #public static boolean containsAny(List list, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = (ListUtil::find(list, e.current()) != 0);
        #
        #        if( ret )
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsType
        #public static boolean containsType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    boolean ret;
        #    int len = ArrayUtil::elements(arr);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( AnytypeUtil::is(ArrayUtil::item(arr, i), type, potentialAncestorId) )
        #        {
        #            ret = true;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #count
        #public static int count(List list, anytype value)
        #{
        #    int ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() == value )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countAny
        #public static int countAny(List list, anytype valueOrCollection)
        #{
        #    int ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( CollectionUtil::in(e.current(), valueOrCollection) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countEmpty
        #public static int countEmpty(List list)
        #{
        #    int ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( !e.current() )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countNotEmpty
        #public static int countNotEmpty(List list)
        #{
        #    int ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countType
        #public static int countType(Array arr, Types type, int potentialAncestorId = 0)
        #{
        #    int ret;
        #    int len = ArrayUtil::elements(arr);
        #    int i;
        #
        #    for( i=1 ; i<=len ; i++ )
        #    {
        #        if( AnytypeUtil::is(ArrayUtil::item(arr, i), type, potentialAncestorId) )
        #        {
        #            ret++;
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #create
        #// возвращает List или null, если не смог распаковать
        #// метод возвратит List с тем типом, который указан в контейнере
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static List create(anytype packedList)
        #{
        #    List ret = ListUtil::createAs(packedList, Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAs
        #// возвращает List или null, если не смог распаковать
        #// возвращаемый List будет содержать элементы указанного типа, если во втором параметре указан тип, иначе будет возвращен null.
        #// проверка типа выполняться не будет, если во втором параметре указан Types::AnyType.
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static List createAs(anytype packedList, Types asType)
        #{
        #    List ret;
        #
        #    if( ListUtil::isPackedOk(packedList, asType) )
        #    {
        #        ret = List::create(packedList);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAsList
        #// возвращает List или null, если не смог распаковать
        #// возвращаемый List будет иметь такой же тип, что и во втором параметре
        #// вернет null, если второй параметр null
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static List createAsList(anytype packedList, List asList)
        #{
        #    List ret;
        #
        #    if( asList )
        #    {
        #        ret = ListUtil::createAs(packedList, asList.typeId());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонирует и list, и элементы списка
        #//
        #// @see clone()
        #public static List deepClone(List list)
        #{
        #    List ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        packedList = list.pack();
        #        ret = List::create(packedList);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #distinct
        #// возвращает новый список, в котором присутствуют только уникальные объекты (дубли удалены)
        #public static List distinct(List list)
        #{
        #    Set set = SetUtil::newFromList(list);
        #    List ret = ListUtil::newFromSet(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #drop
        #public static List drop(List list, int n = 1)
        #{
        #    List ret = ListUtil::slice(list, 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #dropEnd
        #public static List dropEnd(List list, int n = 1)
        #{
        #    List ret = ListUtil::slice(list, 1, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(List list)
        #{
        #    int ret;
        #
        #    if( list )
        #    {
        #        ret = list.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static List ensureType(List list, Types valueType)
        #{
        #    if( ListUtil::isType(list, valueType) )
        #    {
        #        return list;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #find
        #// находит позицию значения в списке
        #//
        #// @param occurrence указывает какое вхождение значения нужно найти
        #//
        #public static int find(List list, anytype value, int occurrence = 1)
        #{
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #    int ret;
        #    int i;
        #
        #    while( occurrence > 0 && e && e.moveNext() )
        #    {
        #        i++;
        #
        #        if( AnytypeUtil::isEqual(value, e.current()) )
        #        {
        #            occurrence--;
        #            if( occurrence <= 0 )
        #            {
        #                ret = i;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findAny
        #public static int findAny(List list, anytype valueOrCollection)
        #{
        #    int ret;
        #    int i;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    for( i=1; e && e.moveNext(); i++ )
        #    {
        #        if( CollectionUtil::in(e.current(), valueOrCollection) )
        #        {
        #            ret = i;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #first
        #// возвращает элемент списка.
        #//
        #// @see head - синоним
        #// @see last
        #public static anytype first(List list)
        #{
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    anytype ret;
        #
        #    if( e && e.moveNext() )
        #    {
        #        ret = e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// ListUtil возвращает объект с типом ListEEnumerator,
        #// который можно присваивать переменным с типом ListEnumerator
        #// и который можно использовать как и обычные ListEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static ListEEnumerator getEEnumerator(List list)
        #{
        #    ListEEnumerator ret = ListEEnumerator::construct(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorAndSkip
        #// ListUtil возвращает объект с типом ListEEnumerator,
        #// который можно присваивать переменным с типом ListEnumerator
        #// и который можно использовать как и обычные ListEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static ListEEnumerator getEEnumeratorAndSkip(List list, int skipIterations)
        #{
        #    ListEEnumerator ret = ListEEnumerator::constructAndSkip(list, skipIterations);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorIfType
        #// ListUtil возвращает объект с типом ListEEnumerator,
        #// который можно присваивать переменным с типом ListEnumerator
        #// и который можно использовать как и обычные ListEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static ListEEnumerator getEEnumeratorIfType(List list, Types valueType)
        #{
        #    ListEEnumerator ret = ListEEnumerator::constructIfType(list, valueType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static ListEnumerator getEnumerator(List list)
        #{
        #    ListEnumerator ret;
        #
        #    if( list )
        #    {
        #        ret = list.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorAndSkip
        #public static ListEnumerator getEnumeratorAndSkip(List list, int skipIterations)
        #{
        #    ListEnumerator ret = ListUtil::getEnumerator(list);
        #
        #    if( ret && EnumeratorUtil::skip(ret, skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorIfType
        #public static ListEnumerator getEnumeratorIfType(List list, Types valueType)
        #{
        #    ListEnumerator ret;
        #
        #    if( ListUtil::isType(list, valueType) )
        #    {
        #        ret = ListUtil::getEnumerator(list);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #head
        #// возвращает элемент списка
        #//
        #// @see first - синоним
        #public static anytype head(List list)
        #{
        #    anytype ret = ListUtil::first(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #// метод возвращает true, если value содержится в контейнере
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #public static boolean in(anytype value, List list)
        #{
        #    boolean ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() == value )
        #        {
        #            ret = true;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(List list)
        #{
        #    boolean ret = true;
        #
        #    if( list )
        #    {
        #        ret = list.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(List list)
        #{
        #    boolean isEmpty = ListUtil::isEmpty(list);
        #
        #    return !isEmpty;
        #}
      ENDSOURCE
      SOURCE #isNotEmptyWithType
        #public static boolean isNotEmptyWithType(List list, Types valueType)
        #{
        #    boolean ret = !ListUtil::isEmpty(list) && list.typeId() == valueType;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedNotEmpty
        #// возвращает true, если контейнер можно распаковать как List или распакованный List скорее всего будет содержать элементы
        #//
        #// "скорее всего" потому что типы элементов контейнера могут отличаться от типа, который объявлен в во втором элементе контейнера.
        #// если типы различаются, то элемент не будет добавлен к коллекцию.
        #// В нормальных случаях такого не бывает. А на точную проверку будет затрачено больше времени, чем создание самой коллекции
        #//
        #// внутреннее устройство List: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedNotEmpty(anytype packedList, Types expectedType = Types::AnyType)
        #{
        #    boolean ret = conlen(packedList) > 3 && ListUtil::isPackedOk(packedList, expectedType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedOk
        #// возвращает true, если контейнер можно распаковать как List
        #// удобно использовать в методах unpack
        #// метод не бросает исключения - метод проверит что сможет и вернет false, если что-то не так
        #//
        #// внутреннее устройство List: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedOk(anytype packedList, Types expectedType = Types::AnyType)
        #{
        #    boolean ret;
        #
        #    anytype version;
        #    anytype type;
        #    anytype elements;
        #
        #    if( packedList &&
        #        typeof(packedList) == Types::Container &&
        #        conlen(packedList) >= 3 )
        #    {
        #        [version, type, elements] = packedList;
        #
        #        if( typeof(version)  == Types::Integer && version == 1 &&
        #            typeof(type)     == Types::Integer && TypeUtil::is(type, expectedType) &&
        #            typeof(elements) == Types::Integer )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public static boolean isType(List list, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( list )
        #    {
        #        ret = TypeUtil::is(list.typeId(), elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #item
        #// первый элемент имеет индекс 1
        #// медленно: выполняет перебор всех элементов до указанного
        #public static anytype item(List set, int idx)
        #{
        #    ListEnumerator e = ListUtil::getEnumerator(set);
        #    int            i;
        #    anytype        ret;
        #
        #    while( idx > 0 && e && e.moveNext() )
        #    {
        #        i++;
        #        if( i == idx )
        #        {
        #            ret = e.current();
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAs
        #public static anytype itemAs(List list, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype value = ListUtil::item(list, idx);
        #    anytype ret = AnytypeUtil::as(value, type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAsValue
        #public static anytype itemAsValue(List list, int idx, anytype asValue)
        #{
        #    anytype value = ListUtil::item(list, idx);
        #    anytype ret = AnytypeUtil::asValue(value, asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #last
        #// возвращает элемент списка.
        #//
        #// @see first
        #public static anytype last(List list)
        #{
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    anytype ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #merge
        #// возвращает новый список, который содержит все элементы первого списка, затем все элементы второго списка
        #public static List merge(List list1, List list2)
        #{
        #    if( !list2 )
        #    {
        #        return ListUtil::clone(list1);
        #    }
        #
        #    if( !list1 )
        #    {
        #        return ListUtil::clone(list2);
        #    }
        #
        #    if( list1.typeId() != list2.typeId() )
        #    {
        #        return ListUtil::clone(list1);
        #    }
        #
        #    return List::merge(list1, list2);
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать list для хранения значений, тип которых совпадает с типом переменной value
        #public static List newBy(anytype value)
        #{
        #    Types type = typeof(value);
        #    List ret = new List(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static List newFrom(anytype valueOrCollection, int maxElements = 0)
        #{
        #    List ret = ListUtil::addAll(null, valueOrCollection, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static List newFromArray(Array arr, int maxElements = 0)
        #{
        #    List ret;
        #
        #    if( arr )
        #    {
        #        ret = ListUtil::addAll(ret, arr, maxElements);
        #
        #        // packedArray = arr.pack();   // не работает, в массиве содержится len - 1
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static List newFromContainer(container con, int maxElements = 0)
        #{
        #    List ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    if( maxElements )
        #    {
        #        len = min(len, maxElements);
        #    }
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        ret = ListUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #public static List newFromList(List list, int maxElements = 0)
        #{
        #    List ret;
        #
        #    if( maxElements )
        #    {
        #        ret = ListUtil::addAll(null, list, maxElements);
        #    }
        #    else
        #    {
        #        ret = ListUtil::clone(list);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromNz
        #public static List newFromNz(anytype valueOrCollection, int maxElements = 0)
        #{
        #    List ret;
        #
        #    if( valueOrCollection )
        #    {
        #        ret = ListUtil::addAll(null, valueOrCollection, maxElements);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQuery
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static List newFromQuery(Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    List ret = ListUtil::addFromQuery(null, q, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQueryRun
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static List newFromQueryRun(QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    List ret = ListUtil::addFromQueryRun(null, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает список из значений полей буфера, который был заполнен командой select
        #// @see RecordListUtil::newFromSelect
        #public static RecordList newFromSelect(Common selectedRecords, FieldId fieldId, int maxElements = 0)
        #{
        #    List ret = ListUtil::addFromSelect(null, selectedRecords, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static List newFromSet(Set set, int maxElements = 0)
        #{
        #    List ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        if( maxElements || set.typeId() == Types::Class )
        #        {
        #            ret = ListUtil::addAll(ret, set, maxElements);
        #        }
        #        else
        #        {
        #            packedSet = set.pack();
        #            ret = List::create(packedSet);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static List newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    List ret = ListUtil::addAll(ret, e);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static List nonNull(List list, Types type = Types::AnyType)
        #{
        #    if( !list )
        #    {
        #        list = new List(type);
        #    }
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #notIn
        #// метод возвращает true, если value не содержится в контейнере
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #public static boolean notIn(anytype value, List list)
        #{
        #    boolean ret = !ListUtil::in(value,list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #pack
        #public static container pack(List list)
        #{
        #    container ret;
        #
        #    if( list )
        #    {
        #        ret = list.pack();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #remove
        #// удаляет значение из списка
        #//
        #// @param occurrence указывает какое вхождение значения нужно удалить
        #//
        #// @see removeAll
        #public static List remove(List list, anytype value, int occurrence = 1)
        #{
        #    List ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() == value )
        #        {
        #            occurrence--;
        #            if( occurrence <= 0 )
        #            {
        #                continue;
        #            }
        #        }
        #
        #        ret = ListUtil::add(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeAll
        #// возвращает новый список, в котором отсустстуют элементы, которые содержатся в коллекции 2
        #public static List removeAll(List list, anytype valueOrCollection)
        #{
        #    List ret;
        #    Enumerator e = EnumeratorUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( CollectionUtil::notIn(e.current(), valueOrCollection) )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый список, в котором удалены все пустые элементы
        #public static List removeEmpty(List list)
        #{
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #    List ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeType
        #// возвращает новый список, в котором удалены элементы указанного типа
        #public static List removeType(List list, Types type, int potentialAncestorId = 0)
        #{
        #    List ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( !AnytypeUtil::is(e.current(), type, potentialAncestorId) )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainAll
        #// возвращает новый список, в котором остались элементы, которые содержатся в коллекции 2
        #public static List retainAll(List list, anytype valueOrCollection)
        #{
        #    List ret;
        #    Enumerator e = EnumeratorUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( CollectionUtil::in(e.current(), valueOrCollection) )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainType
        #// возвращает новый список, в котором остались элементы указанного типа
        #public static List retainType(List list, Types type, int potentialAncestorId = 0)
        #{
        #    List ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( AnytypeUtil::is(e.current(), type, potentialAncestorId) )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reverse
        #public static List reverse(List list)
        #{
        #    List ret;
        #    ListEnumerator e = ListUtil::getEnumerator(list);
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = ListUtil::addStart(ret, e.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #slice
        #public static List slice(List list, int fromPos = 1, int toPos = -1, int step = 1)
        #{
        #    List ret;
        #    ListEnumerator e;
        #
        #    int len     = ListUtil::elements(list);
        #
        #    int fromIdx = fromPos + (fromPos < 0 ? len + 1 : 0);
        #    int toIdx   = toPos   + (toPos < 0 ? len + 1 : 0);
        #
        #    int i       = max(1, fromIdx);
        #    int lastIdx = min(len, toIdx);
        #
        #    if( i <= 1 && lastIdx >= len && step == 1 )
        #    {
        #        ret = ListUtil::clone(list);
        #    }
        #    else if( step > 0 )
        #    {
        #        e = ListUtil::getEnumeratorAndSkip(list, i-1);
        #
        #        while( i<=lastIdx && e && e.moveNext() )
        #        {
        #            ret = ListUtil::add(ret, e.current());
        #
        #            EnumeratorUtil::skip(e, step - 1);
        #
        #            i += step;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #tail
        #public static List tail(List list)
        #{
        #    List ret = ListUtil::slice(list, 2);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #public static List take(List list, int n = 1, int startFrom = 1)
        #{
        #    List ret = ListUtil::slice(list, startFrom, startFrom + n - 1);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #takeLast
        #public static List takeLast(List list, int n = 1)
        #{
        #    List ret = ListUtil::slice(list, -n);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toArray
        #public static Array toArray(List list)
        #{
        #    Array ret = ArrayUtil::newFromList(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(List list)
        #{
        #    container ret = ConUtil::newFromList(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toSet
        #public static Set toSet(List list)
        #{
        #    Set ret = SetUtil::newFromList(list);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(List list, str sep = ',')
        #{
        #    str ret = StrUtil::newFromList(list, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(List list)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( list )
        #    {
        #        ret = list.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #zip
        #public static List zip(List list1, List list2, int maxElements = 0)
        #{
        #    List            ret;
        #    int             elements;
        #    int             minLen = min(ListUtil::elements(list1), ListUtil::elements(list2));
        #    ListEnumerator  e1 = ListUtil::getEnumerator(list1);
        #    ListEnumerator  e2 = ListUtil::getEnumerator(list2);
        #
        #    if( maxElements )
        #    {
        #        minLen = min(minLen, maxElements);
        #    }
        #
        #    while( e1 && e2 && e1.moveNext() && e2.moveNext() && elements < minLen )
        #    {
        #        ret = ListUtil::add(ret, e1.current());
        #        ret = ListUtil::add(ret, e2.current());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ListUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ListUtilTest
    PROPERTIES
      Name                #ListUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class ListUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testElements
        #void testElements()
        #{
        #    List list;
        #
        #    this.info('null');
        #
        #    list = null;
        #    this.assertEquals(0, ListUtil::elements(list));
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    this.assertEquals(3, ListUtil::elements(list));
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #    list.addEnd('d');
        #
        #    this.assertEquals(4, ListUtil::elements(list));
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct(1));
        #    list.addEnd(Any::construct(2));
        #    list.addEnd(Any::construct(3));
        #
        #    this.assertEquals(3, ListUtil::elements(list));
        #}
      ENDSOURCE
      SOURCE #testFind
        #void testFind()
        #{
        #    List list = ListUtil::newFromContainer(['a','b','c','d','e','f','b','i','j']);
        #
        #    this.assertEquals(2, ListUtil::find(list, 'b'));
        #    this.assertEquals(2, ListUtil::find(list, 'b', 1));
        #    this.assertEquals(7, ListUtil::find(list, 'b', 2));
        #
        #    this.info('not found');
        #
        #    this.assertEquals(0, ListUtil::find(list, 'z'));
        #    this.assertEquals(0, ListUtil::find(list, 1));
        #    this.assertEquals(0, ListUtil::find(list, null));
        #
        #    this.info('null');
        #
        #    this.assertEquals(0, ListUtil::find(null, 'a'));
        #}
      ENDSOURCE
      SOURCE #testItem
        #void testItem()
        #{
        #    List list = ListUtil::newFromContainer(['a','b','c','d','e','f','g','i','j']);
        #    anytype undefined;
        #
        #    this.info('correct idx');
        #
        #    this.assertEquals('b', ListUtil::item(list, 2));
        #    this.assertEquals('c', ListUtil::item(list, 3));
        #    this.assertEquals('j', ListUtil::item(list, 9));
        #
        #    this.info('out of bounds');
        #
        #    this.assertEquals(undefined, ListUtil::item(list, 0));
        #    this.assertEquals(0,         ListUtil::item(list, 10));
        #    this.assertEquals(undefined, ListUtil::item(list, 22));
        #    this.assertEquals(undefined, ListUtil::item(list, -1));
        #    this.assertEquals(undefined, ListUtil::item(list, -4));
        #}
      ENDSOURCE
      SOURCE #testNewFromArray
        #void testNewFromArray()
        #{
        #    List  list;
        #    Array fromArray;
        #
        #    this.info('null');
        #
        #    fromArray = null;
        #    list = ListUtil::newFromArray(fromArray);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    fromArray = new Array(Types::Integer);
        #    fromArray.value(1,1);
        #    fromArray.value(2,2);
        #    fromArray.value(3,3);
        #    fromArray.value(4,2);
        #
        #    list = ListUtil::newFromArray(fromArray);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Integer, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<1, 2, 3, 2>', list.toString());
        #
        #    this.info('str');
        #
        #    fromArray = new Array(Types::String);
        #    fromArray.value(1,'a');
        #    fromArray.value(2,'b');
        #    fromArray.value(3,'c');
        #    fromArray.value(4,'b');
        #
        #    list = ListUtil::newFromArray(fromArray);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::String, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<"a", "b", "c", "b">', list.toString());
        #
        #    this.info('class');
        #
        #    fromArray = new Array(Types::Class);
        #    fromArray.value(1,Any::construct('a'));
        #    fromArray.value(2,Any::construct('b'));
        #    fromArray.value(3,Any::construct('c'));
        #    fromArray.value(4,Any::construct('b'));
        #
        #    list = ListUtil::newFromArray(fromArray);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Class, list.typeId());
        #    this.assertEquals(4, list.elements());
        #}
      ENDSOURCE
      SOURCE #testNewFromContainer
        #void testNewFromContainer()
        #{
        #    List list;
        #    container con;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    list = ListUtil::newFromContainer(con);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    con = [1,2,3,2];
        #    list = ListUtil::newFromContainer(con);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::Integer, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<1, 2, 3, 2>', list.toString());
        #
        #    this.info('str');
        #
        #    con = ['a','b','c','b'];
        #    list = ListUtil::newFromContainer(con);
        #    this.assertNotNull(list);
        #    this.assertEquals(types::String, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<"a", "b", "c", "b">', list.toString());
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    list = ListUtil::newFromContainer(con);
        #    this.assertEquals(types::Integer, list.typeId());
        #    this.assertEquals(1, list.elements());
        #    this.assertEquals('<1>', list.toString());
        #}
      ENDSOURCE
      SOURCE #testNewFromList
        #void testNewFromList()
        #{
        #    List list;
        #    List fromList;
        #
        #    this.info('null');
        #
        #    fromList = null;
        #    list = ListUtil::newFromList(fromList);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    fromList = new List(Types::Integer);
        #    fromList.addEnd(1);
        #    fromList.addEnd(2);
        #    fromList.addEnd(3);
        #    fromList.addEnd(2);
        #
        #    list = ListUtil::newFromList(fromList);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Integer, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<1, 2, 3, 2>', list.toString());
        #
        #    this.info('str');
        #
        #    fromList = new List(Types::String);
        #    fromList.addEnd('a');
        #    fromList.addEnd('b');
        #    fromList.addEnd('c');
        #    fromList.addEnd('b');
        #
        #    list = ListUtil::newFromList(fromList);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::String, list.typeId());
        #    this.assertEquals(4, list.elements());
        #    this.assertEquals('<"a", "b", "c", "b">', list.toString());
        #
        #    this.info('class');
        #
        #    fromList = new List(Types::Class);
        #    fromList.addEnd(Any::construct('a'));
        #    fromList.addEnd(Any::construct('b'));
        #    fromList.addEnd(Any::construct('c'));
        #    fromList.addEnd(Any::construct('b'));
        #
        #    list = ListUtil::newFromList(fromList);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Class, list.typeId());
        #    this.assertEquals(4, list.elements());
        #}
      ENDSOURCE
      SOURCE #testNewFromSet
        #void testNewFromSet()
        #{
        #    List list;
        #    Set fromSet;
        #
        #    this.info('null');
        #
        #    fromSet = null;
        #    list = ListUtil::newFromSet(fromSet);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    fromSet = new Set(Types::Integer);
        #    fromSet.add(1);
        #    fromSet.add(2);
        #    fromSet.add(3);
        #
        #    list = ListUtil::newfromSet(fromSet);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Integer, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<1, 2, 3>', list.toString());
        #
        #    this.info('str');
        #
        #    fromSet = new Set(Types::String);
        #    fromSet.add('a');
        #    fromSet.add('b');
        #    fromSet.add('c');
        #
        #    list = ListUtil::newfromSet(fromSet);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::String, list.typeId());
        #    this.assertEquals(3, list.elements());
        #    this.assertEquals('<"a", "b", "c">', list.toString());
        #
        #    this.info('class');
        #
        #    fromSet = new Set(Types::Class);
        #    fromSet.add(Any::construct('a'));
        #    fromSet.add(Any::construct('b'));
        #    fromSet.add(Any::construct('c'));
        #
        #    list = ListUtil::newfromSet(fromSet);
        #    this.assertNotNull(list);
        #    this.assertEquals(Types::Class, list.typeId());
        #    this.assertEquals(3, list.elements());
        #}
      ENDSOURCE
      SOURCE #testSlice
        #void testSlice()
        #{
        #    List list = ListUtil::newFromContainer([1,2,3,4,5,6,7,8,9]);
        #
        #    this.info('from');
        #
        #    this.assertEquals('<2, 3, 4, 5, 6, 7, 8, 9>', ListUtil::slice(list, 2).toString());
        #    this.assertEquals('<3, 4, 5, 6, 7, 8, 9>',    ListUtil::slice(list, 3).toString());
        #    this.assertEquals('<6, 7, 8, 9>',             ListUtil::slice(list, -4).toString());
        #
        #    this.info('from, to');
        #
        #    this.assertEquals('<3, 4, 5, 6, 7, 8, 9>',    ListUtil::slice(list, 3, 99).toString());
        #    this.assertEquals('<3, 4, 5, 6, 7, 8, 9>',    ListUtil::slice(list, 3, -1).toString());
        #    this.assertEquals('<3, 4, 5, 6, 7, 8>',       ListUtil::slice(list, 3, -2).toString());
        #    this.assertNull(                              ListUtil::slice(list, 3, 0));
        #
        #    this.info('from, to, step');
        #
        #    this.assertEquals('<3, 5, 7, 9>',             ListUtil::slice(list, 3, 9, 2).toString());
        #    this.assertEquals('<2, 5, 8>',                ListUtil::slice(list, 2, 9, 3).toString());
        #    this.assertNull(                              ListUtil::slice(list, 2, 9, 0));
        #    this.assertNull(                              ListUtil::slice(list, 2, 9, -1));
        #}
      ENDSOURCE
      SOURCE #testToArray
        #void testToArray()
        #{
        #    List list;
        #    Array arr;
        #
        #    this.info('null');
        #
        #    list = null;
        #    arr = ListUtil::toArray(list);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    arr = ListUtil::toArray(list);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3)', arr.toString());
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #
        #    arr = ListUtil::toArray(list);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::String, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c")', arr.toString());
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct('a'));
        #    list.addEnd(Any::construct('b'));
        #    list.addEnd(Any::construct('c'));
        #
        #    arr = ListUtil::toArray(list);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Class, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('((C) Any: a, (C) Any: b, (C) Any: c)', arr.toString());
        #}
      ENDSOURCE
      SOURCE #testToCon
        #void testToCon()
        #{
        #    List list;
        #    container con;
        #
        #    this.info('null');
        #
        #    list = null;
        #    con = ListUtil::toCon(list);
        #    this.assertEquals(connull(), con);
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    con = ListUtil::toCon(list);
        #    this.assertEquals([1, 2, 3], con);
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #
        #    con = ListUtil::toCon(list);
        #    this.assertEquals(["a", "b", "c"], con);
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct(1));
        #    list.addEnd(Any::construct(2));
        #    list.addEnd(Any::construct(3));
        #
        #    con = ListUtil::toCon(list);
        #    this.assertEquals(connull(), con);
        #}
      ENDSOURCE
      SOURCE #testToSet
        #void testToSet()
        #{
        #    List list;
        #    Set set;
        #
        #    this.info('null');
        #
        #    list = null;
        #    set = ListUtil::toSet(list);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct('a'));
        #    list.addEnd(Any::construct('b'));
        #    list.addEnd(Any::construct('c'));
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Class, set.typeId());
        #    this.assertEquals(3, set.elements());
        #}
      ENDSOURCE
      SOURCE #testToStr
        #void testToStr()
        #{
        #    List list;
        #    str s;
        #
        #    this.info('null');
        #
        #    list = null;
        #    s = ListUtil::toStr(list);
        #    this.assertEquals('', s);
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    s = ListUtil::toStr(list);
        #    this.assertEquals('1,2,3', s);
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #
        #    s = ListUtil::toStr(list);
        #    this.assertEquals('a,b,c', s);
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct('a'));
        #    list.addEnd(Any::construct('b'));
        #    list.addEnd(Any::construct('c'));
        #
        #    s = ListUtil::toStr(list, ': ');
        #    this.assertEquals('a: b: c', s);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SetUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SetUtil
    PROPERTIES
      Name                #SetUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class SetUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #public static Set add(Set set, anytype value)
        #{
        #    if( !set )
        #    {
        #        set = SetUtil::newBy(value);
        #    }
        #
        #    if( set.typeId() == typeof(value) ) // значения с другим типом не будет добавлено
        #    {
        #        set.add(value);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #addAll
        #public static Set addAll(Set set, anytype valueOrCollection, int maxElements = 0)
        #{
        #    int elements;
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        set = SetUtil::add(set, e.current());
        #
        #        elements++;
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #addFieldValue
        #// добавляет значение поля из буфера
        #// если поле содержит контейнер, то контейнер добавляется как есть, целиком
        #public static Set addFieldValue(Set set, Common buf, FieldId fieldId)
        #{
        #    anytype value = RecordFieldUtil::getValue(buf, fieldId);
        #    Set ret = SetUtil::add(set, value);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQuery
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Set addFromQuery(Set toSetOrNull, Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    Set ret = SetUtil::addFromQueryRun(toSetOrNull, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromQueryRun
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Set addFromQueryRun(Set toSetOrNull, QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Set ret = toSetOrNull;
        #    int elements;
        #    common rec;
        #    ;
        #    while( qr && qr.next() && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        rec = qr.get(tableId);
        #        ret = SetUtil::addFieldValue(ret, rec, fieldId);
        #
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFromSelect
        #// добавляет значения поля из буфера, который был заполнен командой select
        #//
        #public static Set addFromSelect(Set set, Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    int elements;
        #
        #    while( selectedRecord && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        set = SetUtil::addFieldValue(set, selectedRecord, fieldId);
        #
        #        next selectedRecord;
        #        elements++;
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #addNz
        #public static Set addNz(Set set, anytype value)
        #{
        #    if( value )
        #    {
        #        set = SetUtil::add(set, value);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #clone
        #// клонирует set, не клонирует элементы множества
        #//
        #// @see deepClone()
        #public static Set clone(Set set)
        #{
        #    Set ret;
        #
        #    if( set )
        #    {
        #        ret = new Set(set.typeId());
        #        ret = Set::union(ret, set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #contains
        #public static boolean contains(Set set, anytype value)
        #{
        #    boolean ret;
        #
        #    if( set )
        #    {
        #        ret = set.in(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAll
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если set содержит все значения из collection
        #public static boolean containsAll(Set set, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( set && ret && e && e.moveNext() )
        #    {
        #        ret = ret && (set.in(e.current()));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsAny
        #// второй аргумент трактуется как коллекция (возможно, из одного значения)
        #// возвращает true, если set содержит любое значение из collection
        #public static boolean containsAny(Set set, anytype valueOrCollection)
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #    boolean ret = true; // любой контейнер содержит пустую коллекцию
        #
        #    while( set && e && e.moveNext() )
        #    {
        #        ret = set.in(e.current());
        #
        #        if( ret )
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #containsType
        #public static boolean containsType(Set set, Types type, int potentialAncestorId = 0)
        #{
        #    boolean ret;
        #    SetEnumerator e;
        #
        #    if( set && set.typeId() == type )
        #    {
        #        e = SetUtil::getEnumerator(set);
        #
        #        while( e && e.moveNext() )
        #        {
        #            if( AnytypeUtil::is(e.current(), type, potentialAncestorId) )
        #            {
        #                ret = true;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #create
        #// возвращает Set или null, если не смог распаковать
        #// метод возвратит Set с тем типом, который указан в контейнере
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Set create(anytype packedSet)
        #{
        #    Set ret = SetUtil::createAs(packedSet, Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAs
        #// возвращает Set или null, если не смог распаковать
        #// возвращаемый Set будет содержать элементы указанного типа, если во втором параметре указан тип, иначе будет возвращен null.
        #// проверка типа выполняться не будет, если во втором параметре указан Types::AnyType.
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Set createAs(anytype packedSet, Types asType)
        #{
        #    Set ret;
        #
        #    if( SetUtil::isPackedOk(packedSet, asType) )
        #    {
        #        ret = Set::create(packedSet);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAsSet
        #// возвращает Set или null, если не смог распаковать
        #// возвращаемый Set будет иметь такой же тип, что и во втором параметре
        #// вернет null, если второй параметр null
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Set createAsSet(anytype packedSet, Set asSet)
        #{
        #    Set ret;
        #
        #    if( asSet )
        #    {
        #        ret = SetUtil::createAs(packedSet, asSet.typeId());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #deepClone
        #// клонирует и set, и элементы множества
        #//
        #// see clone()
        #public static Set deepClone(Set set)
        #{
        #    Set ret;
        #    container packedSet;
        #
        #    if( set )
        #    {
        #        packedSet = set.pack();
        #        ret = Set::create(packedSet);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #difference
        #public static Set difference(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    if( !set1 )
        #    {
        #        return null;
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    return Set::difference(set1, set2);
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(Set set)
        #{
        #    int ret;
        #
        #    if( set )
        #    {
        #        ret = set.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static List ensureType(List list, Types valueType)
        #{
        #    if( ListUtil::isType(list, valueType) )
        #    {
        #        return list;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// SetUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом SetEnumerator
        #// и который можно использовать как и обычные SetEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static SetEEnumerator getEEnumerator(Set set)
        #{
        #    SetEEnumerator ret = SetEEnumerator::construct(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorAndSkip
        #// SetUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом SetEnumerator
        #// и который можно использовать как и обычные SetEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static SetEEnumerator getEEnumeratorAndSkip(Set set, int skipIterations)
        #{
        #    SetEEnumerator ret = SetEEnumerator::constructAndSkip(set, skipIterations);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorIfType
        #// SetUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом SetEnumerator
        #// и который можно использовать как и обычные SetEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static SetEEnumerator getEEnumeratorIfType(Set set, Types valueType)
        #{
        #    SetEEnumerator ret = SetEEnumerator::constructIfType(set, valueType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #public static SetEnumerator getEnumerator(Set set)
        #{
        #    SetEnumerator ret;
        #
        #    if( set )
        #    {
        #        ret = set.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorAndSkip
        #public static SetEnumerator getEnumeratorAndSkip(Set set, int skipIterations)
        #{
        #    SetEnumerator ret = SetUtil::getEnumerator(set);
        #
        #    if( ret && EnumeratorUtil::skip(ret, skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorIfType
        #public static SetEnumerator getEnumeratorIfType(Set set, Types valueType)
        #{
        #    SetEnumerator ret;
        #
        #    if( SetUtil::isType(set, valueType) )
        #    {
        #        ret = SetUtil::getEnumerator(set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #public static Set in(Set set, anytype value)
        #{
        #    boolean ret;
        #
        #    if( set )
        #    {
        #        ret = set.in(value);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #intersection
        #public static Set intersection(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return null;
        #    }
        #
        #    if( !set1 )
        #    {
        #        return null;
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return null;
        #    }
        #
        #    return Set::union(set1, set2);
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(Set set)
        #{
        #    boolean ret = true;
        #
        #    if( set )
        #    {
        #        ret = set.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(Set set)
        #{
        #    boolean isEmpty = SetUtil::isEmpty(set);
        #
        #    return !isEmpty;
        #}
      ENDSOURCE
      SOURCE #isNotEmptyWithType
        #public static boolean isNotEmptyWithType(Set set, Types valueType)
        #{
        #    boolean ret = !SetUtil::isEmpty(set) && set.typeId() == valueType;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedNotEmpty
        #// возвращает true, если контейнер можно распаковать как Set и Set скорее всего будет содержать элементы
        #//
        #// "скорее всего" потому что типы элементов контейнера могут отличаться от типа, который объявлен в во втором элементе контейнера.
        #// если типы различаются, то элемент не будет добавлен к коллекцию.
        #// В нормальных случаях такого не бывает. А на точную проверку будет затрачено больше времени, чем создание самой коллекции
        #//
        #// внутреннее устройство Set: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedNotEmpty(anytype packedSet, Types expectedType = Types::AnyType)
        #{
        #    boolean ret = conlen(packedSet) > 3 && SetUtil::isPackedOk(packedSet,expectedType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedOk
        #// возвращает true, если контейнер можно распаковать как Set
        #// удобно использовать в методах unpack
        #// метод не бросает исключения - метод проверит что сможет и вернет false, если что-то не так
        #//
        #// внутреннее устройство Set: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedOk(anytype packedSet, Types expectedType = Types::AnyType)
        #{
        #    boolean ret;
        #
        #    anytype version;
        #    anytype type;
        #    anytype elements;
        #
        #    if( packedSet &&
        #        typeof(packedSet) == Types::Container &&
        #        conlen(packedSet) >= 3 )
        #    {
        #        [version, type, elements] = packedSet;
        #
        #        if( typeof(version)  == Types::Integer && version == 1 &&
        #            typeof(type)     == Types::Integer && TypeUtil::is(type, expectedType) &&
        #            typeof(elements) == Types::Integer )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public static boolean isType(Set set, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( set )
        #    {
        #        ret = TypeUtil::is(set.typeId(), elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #item
        #// первый элемент имеет индекс 1
        #// медленно: выполняет перебор всех элементов до указанного
        #public static anytype item(Set set, int idx)
        #{
        #    SetEnumerator se = SetUtil::getEnumerator(set);
        #    int           i;
        #    anytype       ret;
        #
        #    while( idx > 0 && se && se.moveNext() )
        #    {
        #        i++;
        #        if( i == idx )
        #        {
        #            ret = se.current();
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAs
        #public static anytype itemAs(Set set, int idx, Types type, int potentialAncestorId = 0)
        #{
        #    anytype value = SetUtil::item(set, idx);
        #    anytype ret = AnytypeUtil::as(value, type, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #itemAsValue
        #public static anytype itemAsValue(Set set, int idx, anytype asValue)
        #{
        #    anytype value = SetUtil::item(set, idx);
        #    anytype ret = AnytypeUtil::asValue(value, asValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #merge
        #public static Set merge(Set set1, Set set2)
        #{
        #    return Set::union(set1, set2);
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать set для хранения значений, тип которых совпадает с типом переменной value
        #public static Set newBy(anytype value)
        #{
        #    Types type = typeof(value);
        #    Set ret = new Set(type);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFrom
        #public static Set newFrom(anytype valueOrCollection, int maxElements = 0)
        #{
        #    Set set = SetUtil::addAll(null, valueOrCollection, maxElements);
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #newFrom2
        #public static Set newFrom2(anytype valueOrCollection1, anytype valueOrCollection2, int maxElements = 0)
        #{
        #    Set set = SetUtil::addAll(null, valueOrCollection1, maxElements);
        #    ;
        #
        #    if( maxElements == 0 || SetUtil::elements(set) < maxElements )
        #    {
        #        set = SetUtil::addAll(set, valueOrCollection2, maxElements);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #newFrom3
        #public static Set newFrom3(anytype valueOrCollection1, anytype valueOrCollection2, anytype valueOrCollection3, int maxElements = 0)
        #{
        #    Set set = SetUtil::newFrom2(valueOrCollection1, valueOrCollection2, maxElements);
        #    ;
        #
        #    if( maxElements == 0 || SetUtil::elements(set) < maxElements )
        #    {
        #        set = SetUtil::addAll(set, valueOrCollection3, maxElements);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #newFromArray
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Set newFromArray(Array arr, int maxElements = 0)
        #{
        #    Set ret;
        #
        #    if( arr )
        #    {
        #        ret = SetUtil::addAll(ret, arr, maxElements);
        #
        #        // packedArray = arr.pack();   // не работает, в массиве содержится len - 1
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromContainer
        #public static Set newFromContainer(container con, int maxElements = 0)
        #{
        #    Set ret;
        #    int len = conlen(con);
        #    int i;
        #
        #    if( maxElements )
        #    {
        #        len = min(len, maxElements);
        #    }
        #
        #    for( i=1; i<=len; i++ )
        #    {
        #        ret = SetUtil::add(ret, conpeek(con, i));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromList
        #// быстрое преобразование. https://axforum.info/forums/showthread.php?t=27738
        #// безопасное преобразование в методе newFrom()
        #public static Set newFromList(List list, int maxElements = 0)
        #{
        #    Set ret;
        #    container packedList;
        #
        #    if( list )
        #    {
        #        if( maxElements || list.typeId() == Types::Class )
        #        {
        #            ret = setUtil::addAll(ret, list, maxElements);
        #        }
        #        else
        #        {
        #            packedList = list.pack();
        #            ret = Set::create(packedList);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromNz
        #public static Set newFromNz(anytype valueOrCollection, int maxElements = 0)
        #{
        #    Set set;
        #
        #    if( valueOrCollection )
        #    {
        #        set = SetUtil::addAll(null, valueOrCollection, maxElements);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #newFromQuery
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Set newFromQuery(Query q, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Set ret = SetUtil::addFromQuery(null, q, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromQueryRun
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Set newFromQueryRun(QueryRun qr, TableId tableId, FieldId fieldId, int maxElements = 0)
        #{
        #    Set ret = SetUtil::addFromQueryRun(null, qr, tableId, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSelect
        #// создает множество значений поля из буфера, который был заполнен командой select
        #public static Set newFromSelect(Common selectedRecord, FieldId fieldId, int maxElements = 0)
        #{
        #    Set ret = SetUtil::addFromSelect(null, selectedRecord, fieldId, maxElements);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromSet
        #public static Set newFromSet(Set set, int maxElements = 0)
        #{
        #    Set ret;
        #
        #    if( maxElements )
        #    {
        #        ret = SetUtil::addAll(ret, set, maxElements);
        #    }
        #    else
        #    {
        #        ret = SetUtil::clone(set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromStr
        #public static Set newFromStr(str s, str sep = ',', int maxSubstrings = 0)
        #{
        #    Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        #    Set ret = SetUtil::addAll(ret, e);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Set nonNull(Set set, Types type = Types::AnyType)
        #{
        #    if( !set )
        #    {
        #        set = new Set(type);
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #notIn
        #// метод возвращает true, если value не содержится в set
        #// по сравнению с find параметры метода идут в обратном порядке - значение, конейнер
        #// такой порядок позволяет удобнее записывать выражения в условиях.
        #public static boolean notIn(anytype value, Set set)
        #{
        #    boolean ret;
        #
        #    if( set )
        #    {
        #        ret = !set.in(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #pack
        #public static container pack(Set set)
        #{
        #    container ret;
        #
        #    if( set )
        #    {
        #        ret = set.pack();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #remove
        #// удаляет значение из set. возвращает новый set
        #//
        #// @see removeAll
        #public static Set remove(Set set, anytype value)
        #{
        #    Set ret;
        #
        #    if( set && set.typeId() == typeof(value) )
        #    {
        #        ret = SetUtil::clone(set);
        #        ret.remove(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeAll
        #// возвращает новый set, в котором отсустстуют элементы, которые содержатся в коллекции 2
        #public static Set removeAll(Set set, anytype valueOrCollection)
        #{
        #    Set ret;
        #    Enumerator e;
        #
        #    if( set )
        #    {
        #        ret = SetUtil::clone(set);
        #        e = EnumeratorUtil::getEnumerator(valueOrCollection);
        #
        #        while( e && e.moveNext() )
        #        {
        #            if( ret.typeId() == typeof(e.current()) )
        #            {
        #                ret.remove(e.current());
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый set, в котором удалены все пустые элементы
        #public static Set removeEmpty(Set set)
        #{
        #    SetEnumerator e = SetUtil::getEnumerator(set);
        #    Set ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.current() )
        #        {
        #            ret = SetUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeType
        #// возвращает новый set, в котором удалены элементы указанного типа
        #public static Set removeType(Set set, Types type, int potentialAncestorId = 0)
        #{
        #    Set ret;
        #    SetEnumerator e = setUtil::getEnumerator(set);
        #
        #    if( set && set.typeId() == type )
        #    {
        #        while( e && e.moveNext() )
        #        {
        #            if( !AnytypeUtil::is(e.current(), type, potentialAncestorId) )
        #            {
        #                ret = SetUtil::add(ret, e.current());
        #            }
        #        }
        #    }
        #    else if( set )
        #    {
        #        ret = SetUtil::clone(set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainAll
        #// возвращает новый set, в котором остались элементы, которые содержатся в коллекции 2
        #public static Set retainAll(Set set, anytype valueOrCollection)
        #{
        #    Set ret;
        #    SetEnumerator e = setUtil::getEnumerator(set);
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( CollectionUtil::in(e.current(), valueOrCollection) )
        #        {
        #            ret = SetUtil::add(ret, e.current());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #retainType
        #// возвращает новый список, в котором остались элементы указанного типа
        #public static Set retainType(Set set, Types type, int potentialAncestorId = 0)
        #{
        #    Set ret;
        #    SetEnumerator e;
        #
        #    if( set && set.typeId() == type )
        #    {
        #        e = setUtil::getEnumerator(set);
        #
        #        while( e && e.moveNext() )
        #        {
        #            if( AnytypeUtil::is(e.current(), type, potentialAncestorId) )
        #            {
        #                ret = SetUtil::add(ret, e.current());
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toArray
        #public static Array toArray(Set set)
        #{
        #    Array arr = ArrayUtil::newFromSet(set);
        #
        #    return arr;
        #}
      ENDSOURCE
      SOURCE #toCon
        #public static container toCon(Set set)
        #{
        #    container ret = ConUtil::newFromSet(set);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #toList
        #public static List toList(Set set)
        #{
        #    List list = ListUtil::newFromSet(set);
        #
        #    return list;
        #}
      ENDSOURCE
      SOURCE #toStr
        #public static str toStr(Set set, str sep = ',')
        #{
        #    str ret = StrUtil::newFromSet(set, sep);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #type
        #public static Types type(Set set)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( set )
        #    {
        #        ret = set.typeId();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #union
        #public static Set union(Set set1, Set set2)
        #{
        #    if( !set2 )
        #    {
        #        return SetUtil::clone(set1);
        #    }
        #
        #    if( !set1 )
        #    {
        #        return SetUtil::clone(set2);
        #    }
        #
        #    if( set1.typeId() != set2.typeId() )
        #    {
        #        return null;
        #    }
        #
        #    return Set::union(set1, set2);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SetUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SetUtilTest
    PROPERTIES
      Name                #SetUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class SetUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAddIntToNull
        #public void testAddIntToNull()
        #{
        #    Set set = SetUtil::add(null, 1);
        #
        #    this.assertNotNull(set);
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals(Types::Integer, set.typeId());
        #}
      ENDSOURCE
      SOURCE #testAddListEnumeratorToNull
        #public void testAddListEnumeratorToNull()
        #{
        #    List list = ListUtil::newFrom(['test', 'ttt']);
        #    Set set = SetUtil::add(null, 'test');
        #
        #    this.assertNotNull(set);
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals(Types::String, set.typeId());
        #}
      ENDSOURCE
      SOURCE #testAddOneValueEnumeratorToNull
        #public void testAddOneValueEnumeratorToNull()
        #{
        #    Enumerator e = EnumeratorUtil::getEnumerator('test');
        #    Set set = SetUtil::addAll(null, e);
        #
        #    this.assertNotNull(set);
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals(Types::String, set.typeId());
        #}
      ENDSOURCE
      SOURCE #testAddStrToNull
        #public void testAddStrToNull()
        #{
        #    Set set = SetUtil::add(null, 'test');
        #
        #    this.assertNotNull(set);
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals(Types::String, set.typeId());
        #}
      ENDSOURCE
      SOURCE #testElements
        #void testElements()
        #{
        #    Set set;
        #
        #    this.info('null');
        #
        #    set = null;
        #    this.assertEquals(0, SetUtil::elements(set));
        #
        #    this.info('int');
        #
        #    set = new Set(Types::Integer);
        #    set.add(1);
        #    set.add(2);
        #    set.add(3);
        #
        #    this.assertEquals(3, SetUtil::elements(set));
        #
        #    this.info('str');
        #
        #    set = new Set(Types::String);
        #    set.add('a');
        #    set.add('b');
        #    set.add('c');
        #    set.add('d');
        #
        #    this.assertEquals(4, SetUtil::elements(set));
        #
        #    this.info('class');
        #
        #    set = new Set(Types::Class);
        #    set.add(Any::construct(1));
        #    set.add(Any::construct(2));
        #    set.add(Any::construct(3));
        #
        #    this.assertEquals(3, SetUtil::elements(set));
        #}
      ENDSOURCE
      SOURCE #testItem
        #void testItem()
        #{
        #    Set set = SetUtil::newFromContainer(['a','b','c','d','e','f','g','i','j']);
        #    anytype undefined;
        #
        #    this.info('correct idx');
        #
        #    this.assertEquals('b', SetUtil::item(set, 2));
        #    this.assertEquals('c', SetUtil::item(set, 3));
        #    this.assertEquals('j', SetUtil::item(set, 9));
        #
        #    this.info('out of bounds');
        #
        #    this.assertEquals(undefined, SetUtil::item(set, 0));
        #    this.assertEquals(0,         SetUtil::item(set, 10));
        #    this.assertEquals(undefined, SetUtil::item(set, 22));
        #    this.assertEquals(undefined, SetUtil::item(set, -1));
        #    this.assertEquals(undefined, SetUtil::item(set, -4));
        #}
      ENDSOURCE
      SOURCE #testNewFromArray
        #void testNewFromArray()
        #{
        #    Set set;
        #    Array fromArray;
        #
        #    this.info('null');
        #
        #    fromArray = null;
        #    set = SetUtil::newFromArray(fromArray);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    fromArray = new Array(Types::Integer);
        #    fromArray.value(1,1);
        #    fromArray.value(2,2);
        #    fromArray.value(3,3);
        #    fromArray.value(4,2);
        #
        #    set = SetUtil::newFromArray(fromArray);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    fromArray = new Array(Types::String);
        #    fromArray.value(1,'a');
        #    fromArray.value(2,'b');
        #    fromArray.value(3,'c');
        #    fromArray.value(4,'b');
        #
        #    set = SetUtil::newFromArray(fromArray);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    fromArray = new Array(Types::Class);
        #    fromArray.value(1,Any::construct('a'));
        #    fromArray.value(2,Any::construct('b'));
        #    fromArray.value(3,Any::construct('c'));
        #    fromArray.value(4,Any::construct('a'));
        #
        #    set = SetUtil::newFromArray(fromArray);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Class, set.typeId());
        #    this.assertEquals(4, set.elements());
        #}
      ENDSOURCE
      SOURCE #testNewFromContainer
        #void testNewFromContainer()
        #{
        #    Set set;
        #    container con;
        #
        #    this.info('null');
        #
        #    con = connull();
        #    set = SetUtil::newFromContainer(con);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    con = [1,2,3,2];
        #    set = SetUtil::newFromContainer(con);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    con = ['a','b','c','b'];
        #    set = SetUtil::newFromContainer(con);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('mix');
        #
        #    con = [1, 'b', 'c'];
        #    set = SetUtil::newFromContainer(con);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(1, set.elements());
        #    this.assertEquals('{1}', set.toString());
        #}
      ENDSOURCE
      SOURCE #testNewFromList
        #void testNewFromList()
        #{
        #    Set set;
        #    List fromList;
        #
        #    this.info('null');
        #
        #    fromList = null;
        #    set = SetUtil::newFromList(fromList);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    fromList = new List(Types::Integer);
        #    fromList.addEnd(1);
        #    fromList.addEnd(2);
        #    fromList.addEnd(3);
        #
        #    set = SetUtil::newFromList(fromList);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    fromList = new List(Types::String);
        #    fromList.addEnd('a');
        #    fromList.addEnd('b');
        #    fromList.addEnd('c');
        #
        #    set = SetUtil::newFromList(fromList);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    fromList = new List(Types::Class);
        #    fromList.addEnd(Any::construct('a'));
        #    fromList.addEnd(Any::construct('b'));
        #    fromList.addEnd(Any::construct('c'));
        #    fromList.addEnd(Any::construct('b'));
        #
        #    set = SetUtil::newFromList(fromList);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Class, set.typeId());
        #    this.assertEquals(4, set.elements());
        #}
      ENDSOURCE
      SOURCE #testNewFromSet
        #void testNewFromSet()
        #{
        #    Set set;
        #    Set fromSet;
        #
        #    this.info('null');
        #
        #    fromSet = null;
        #    set = SetUtil::newFromSet(fromSet);
        #    this.assertNull(set);
        #
        #    this.info('int');
        #
        #    fromSet = new Set(Types::Integer);
        #    fromSet.add(1);
        #    fromSet.add(2);
        #    fromSet.add(3);
        #
        #    set = SetUtil::newfromSet(fromSet);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    fromSet = new Set(Types::String);
        #    fromSet.add('a');
        #    fromSet.add('b');
        #    fromSet.add('c');
        #
        #    set = SetUtil::newfromSet(fromSet);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    fromSet = new Set(Types::Class);
        #    fromSet.add(Any::construct('a'));
        #    fromSet.add(Any::construct('b'));
        #    fromSet.add(Any::construct('c'));
        #
        #    set = SetUtil::newfromSet(fromSet);
        #    this.assertNotNull(set);
        #    this.assertEquals(Types::Class, set.typeId());
        #    this.assertEquals(3, set.elements());
        #}
      ENDSOURCE
      SOURCE #testToArray
        #void testToArray()
        #{
        #    Set set;
        #    Array arr;
        #
        #    this.info('null');
        #
        #    set = null;
        #    arr = setUtil::toArray(set);
        #    this.assertNull(arr);
        #
        #    this.info('int');
        #
        #    set = new Set(Types::Integer);
        #    set.add(1);
        #    set.add(2);
        #    set.add(3);
        #
        #    arr = SetUtil::toArray(set);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Integer, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('(1, 2, 3)', arr.toString());
        #
        #    this.info('str');
        #
        #    set = new Set(Types::String);
        #    set.add('a');
        #    set.add('b');
        #    set.add('c');
        #
        #    arr = SetUtil::toArray(set);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::String, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #    this.assertEquals('("a", "b", "c")', arr.toString());
        #
        #    this.info('class');
        #
        #    set = new Set(Types::Class);
        #    set.add(Any::construct('a'));
        #    set.add(Any::construct('b'));
        #    set.add(Any::construct('c'));
        #
        #    arr = SetUtil::toArray(set);
        #    this.assertNotNull(arr);
        #    this.assertEquals(types::Class, arr.typeId());
        #    this.assertEquals(3, arr.lastIndex());
        #}
      ENDSOURCE
      SOURCE #testToCon
        #void testToCon()
        #{
        #    Set set;
        #    container con;
        #
        #    this.info('null');
        #
        #    set = null;
        #    con = SetUtil::toCon(set);
        #    this.assertEquals(connull(), con);
        #
        #    this.info('int');
        #
        #    set = new Set(Types::Integer);
        #    set.add(1);
        #    set.add(2);
        #    set.add(3);
        #
        #    con = SetUtil::toCon(set);
        #    this.assertEquals([1, 2, 3], con);
        #
        #    this.info('str');
        #
        #    set = new Set(Types::String);
        #    set.add('a');
        #    set.add('b');
        #    set.add('c');
        #
        #    con = SetUtil::toCon(set);
        #    this.assertEquals(["a", "b", "c"], con);
        #
        #    this.info('class');
        #
        #    set = new Set(Types::Class);
        #    set.add(Any::construct(1));
        #    set.add(Any::construct(2));
        #    set.add(Any::construct(3));
        #
        #    con = SetUtil::toCon(set);
        #    this.assertEquals(connull(), con);
        #}
      ENDSOURCE
      SOURCE #testToList
        #void testToList()
        #{
        #    Set set;
        #    List list;
        #
        #    this.info('null');
        #
        #    set = null;
        #    list = SetUtil::toList(set);
        #    this.assertNull(list);
        #
        #    this.info('int');
        #
        #    list = new List(Types::Integer);
        #    list.addEnd(1);
        #    list.addEnd(2);
        #    list.addEnd(3);
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Integer, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{1, 2, 3}', set.toString());
        #
        #    this.info('str');
        #
        #    list = new List(Types::String);
        #    list.addEnd('a');
        #    list.addEnd('b');
        #    list.addEnd('c');
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::String, set.typeId());
        #    this.assertEquals(3, set.elements());
        #    this.assertEquals('{"a", "b", "c"}', set.toString());
        #
        #    this.info('class');
        #
        #    list = new List(Types::Class);
        #    list.addEnd(Any::construct('a'));
        #    list.addEnd(Any::construct('b'));
        #    list.addEnd(Any::construct('c'));
        #
        #    set = ListUtil::toSet(list);
        #    this.assertNotNull(set);
        #    this.assertEquals(types::Class, set.typeId());
        #    this.assertEquals(3, set.elements());
        #}
      ENDSOURCE
      SOURCE #testToStr
        #void testToStr()
        #{
        #    Set set;
        #    str s;
        #
        #    this.info('null');
        #
        #    set = null;
        #    s = SetUtil::toStr(set);
        #    this.assertEquals('', s);
        #
        #    this.info('int');
        #
        #    set = new Set(Types::Integer);
        #    set.add(1);
        #    set.add(2);
        #    set.add(3);
        #
        #    s = SetUtil::toStr(set);
        #    this.assertEquals('1,2,3', s);
        #
        #    this.info('str');
        #
        #    set = new Set(Types::String);
        #    set.add('a');
        #    set.add('b');
        #    set.add('c');
        #
        #    s = SetUtil::toStr(set);
        #    this.assertEquals('a,b,c', s);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StackUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StackUtil
    PROPERTIES
      Name                #StackUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StackUtil
        #{
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StructUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StructUtil
    PROPERTIES
      Name                #StructUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class StructUtil
        #{
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapUtil
    PROPERTIES
      Name                #MapUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class MapUtil
        #{
        #}
      ENDSOURCE
      SOURCE #add
        #// добавляет value к значению, которое уже хранится в map по ключу
        #// может бросить исключение или проигнорировать параметр value,
        #// если в map хранится значение, для которого не определен оператор суммирование с value
        #//
        #// map вполне может хранить list, set, array, container
        #// тогда этот метод добавит значение к хранимой коллекции
        #//
        #// value также может иметь тип list, set, array, container
        #//
        #// если по ключу ничего не хранится, то просто создает значение для указанного ключа
        #//
        #// @see insert() чтобы просто вставить значение в Map, как в стандартном классе Map
        #// @see addVector() чтобы добавить покомпонентно
        #//
        #public static Map add(Map map, anytype key, anytype value)
        #{
        #    anytype v;
        #
        #    if( map && map.exists(key) )
        #    {
        #        v = AnytypeUtil::addOrValue1(map.lookup(key), value);
        #    }
        #    else
        #    {
        #        v = value;
        #    }
        #
        #    map = MapUtil::insert(map, key, v);
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #addVector
        #// трактует контейнер под текущем ключём и добавляемую коллекцию как компоненты векторов
        #//
        #// добавляет value к вектору, которое уже хранится в map по ключу
        #// может бросить исключение или проигнорировать параметр value,
        #// если в map хранится значение, для которого не определен оператор суммирование с value
        #//
        #// map вполне может хранить list, set, array, container
        #// тогда этот метод добавит значение к хранимой коллекции
        #//
        #// value также может иметь тип list, set, array, container
        #//
        #// если по ключу ничего не хранится, то просто создает значение для указанного ключа
        #//
        #// @see insert() чтобы просто вставить значение в Map, как в стандартном классе Map
        #// @see add() чтобы добавить value к уже существующему в map значению
        #//
        #public static Map addVector(Map map, anytype key, anytype value, int maxElements = 0)
        #{
        #    anytype v;
        #
        #    if( map && map.valueType() == Types::Container && map.exists(key) )
        #    {
        #        v = ConUtil::addVector(map.lookup(key), value, maxElements);
        #    }
        #    else
        #    {
        #        v = value;
        #    }
        #
        #    map = MapUtil::insert(map, key, v);
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #clone
        #public static Map clone(Map map)
        #{
        #    Map ret;
        #    MapEnumerator me;
        #
        #    if (map)
        #    {
        #        ret = new Map(map.keyType(), map.valueType());
        #
        #        me = map.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            map.insert(me.currentKey(), me.currentValue());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #create
        #// возвращает Map или null, если не смог распаковать
        #// метод возвратит Map с тем типом, который указан в контейнере
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Map create(anytype packedMap)
        #{
        #    Map ret = MapUtil::createAs(packedMap, Types::AnyType, Types::AnyType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAs
        #// возвращает Map или null, если не смог распаковать
        #// возвращаемый Map будет содержать элементы указанного типа, если во втором и третьем параметрах указан значимый тип, иначе будет возвращен null.
        #// проверка типа выполняться не будет, если во втором параметре указан Types::AnyType.
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Map createAs(anytype packedMap, Types asKeyType, Types asValueType)
        #{
        #    Map ret;
        #
        #    if( MapUtil::isPackedOk(packedMap, asKeyType, asValueType) )
        #    {
        #        ret = Map::create(packedMap);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #createAsMap
        #// возвращает Map или null, если не смог распаковать
        #// возвращаемый Map будет иметь такие же типы, что и во втором параметре
        #// вернет null, если второй параметр null
        #//
        #// удобно использовать в методах unpack, в которых мы получаем anytype значение
        #// метод не бросает исключения - метод проверит что сможет и вернет null, если что-то не так
        #//
        #public static Map createAsMap(anytype packedMap, Map asMap)
        #{
        #    Map ret;
        #
        #    if( asMap )
        #    {
        #        ret = MapUtil::createAs(packedMap, asMap.keyType(), asMap.valueType());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elements
        #public static int elements(Map map)
        #{
        #    int ret;
        #
        #    if( map )
        #    {
        #        ret = map.elements();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #empty
        #public static boolean empty(Map map)
        #{
        #    boolean ret = true;
        #
        #    if( map )
        #    {
        #        ret = map.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static Map ensureType(Map map, Types keyType, Types valueType)
        #{
        #    if( MapUtil::isType(map, keyType, valueType) )
        #    {
        #        return map;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(funcname()));
        #}
      ENDSOURCE
      SOURCE #exists
        #public static boolean exists(Map map, anytype key)
        #{
        #    boolean ret = false;
        #
        #    if( map )
        #    {
        #        ret = map.exists(key);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// MapUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом MapEnumerator
        #// и который можно использовать как и обычные MapEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static MapEEnumerator getEEnumerator(Map map)
        #{
        #    MapEEnumerator ret = MapEEnumerator::construct(map);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorAndSkip
        #// MapUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом MapEnumerator
        #// и который можно использовать как и обычные MapEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static MapEEnumerator getEEnumeratorAndSkip(Map map, int skipIterations)
        #{
        #    MapEEnumerator ret = MapEEnumerator::constructAndSkip(map, skipIterations);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumeratorIfType
        #// MapUtil возвращает объект с типом EEnumerator,
        #// который можно присваивать переменным с типом MapEnumerator
        #// и который можно использовать как и обычные MapEnumerator'ы.
        #// но у этого объекта реализованы методы, объявленные в интерфейсе EEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static MapEEnumerator getEEnumeratorIfType(Map map, Types keyType, Types valueType)
        #{
        #    MapEEnumerator ret = MapEEnumerator::constructIfType(map, keyType, valueType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// @see getEEnumerator
        #//
        #public static MapEnumerator getEnumerator(Map map)
        #{
        #    MapEnumerator ret;
        #
        #    if( map )
        #    {
        #        ret = map.getEnumerator();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorAndSkip
        #// @see getEEnumeratorAndSkip
        #//
        #public static MapEnumerator getEnumeratorAndSkip(Map map, int skipIterations)
        #{
        #    MapEnumerator ret = MapUtil::getEnumerator(map);
        #
        #    if( ret && EnumeratorUtil::skip(ret, skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEnumeratorIfType
        #// @see getEEnumeratorIfType
        #//
        #public static MapEnumerator getEnumeratorIfType(Map map, Types keyType, Types valueType)
        #{
        #    MapEnumerator ret;
        #
        #    if( MapUtil::isType(map, keyType, valueType) )
        #    {
        #        ret = MapUtil::getEnumerator(map);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #// вставляет элемент в Map
        #// создает Map, если map is null
        #//
        #// @see add() чтобы добавить value к уже существующему в map значению
        #// @see addVector() чтобы добавить покомпонентно
        #//
        #public static Map insert(Map map, anytype key, anytype value)
        #{
        #    if( !map )
        #    {
        #        map = new Map(typeof(key), typeof(value));
        #        map.insert(key, value);
        #    }
        #    else if( map.keyType() == typeof(key) && map.valueType() == typeof(value) )
        #    {
        #        map.insert(key, value);
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #insertMap
        #public static Map insertMap(Map map, Map insertThisMap)
        #{
        #    MapEnumerator me;
        #
        #    if( insertThisMap )
        #    {
        #        me = insertThisMap.getEnumerator();
        #
        #        while( me && me.moveNext() )
        #        {
        #            map = MapUtil::insert(map, me.currentKey(), me.currentValue());
        #        }
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #public static boolean isEmpty(Map map)
        #{
        #    boolean ret = true;
        #
        #    if( map )
        #    {
        #        ret = map.empty();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #public static boolean isNotEmpty(Map map)
        #{
        #    boolean isEmpty = MapUtil::isEmpty(map);
        #
        #    return !isEmpty;
        #}
      ENDSOURCE
      SOURCE #isNotEmptyWithType
        #public static boolean isNotEmptyWithType(Map map, Types keyType, Types valueType)
        #{
        #    boolean ret = !MapUtil::isEmpty(map) && map.keyType() == keyType && map.valueType() == valueType;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedNotEmpty
        #// возвращает true, если контейнер можно распаковать как Map и Map скорее всего будет содержать элементы
        #//
        #// "скорее всего" потому что типы элементов контейнера могут отличаться от типа, который объявлен в во втором и третьем элементах контейнера.
        #// если типы различаются, то элемент не будет добавлен к коллекцию.
        #// В нормальных случаях такого не бывает. А на точную проверку будет затрачено больше времени, чем создание самой коллекции.
        #//
        #// внутреннее устройство Map: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedNotEmpty(anytype packedSet, Types expectedType = Types::AnyType)
        #{
        #    boolean ret = conlen(packedSet) > 4 && SetUtil::isPackedOk(packedSet,expectedType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isPackedOk
        #// возвращает true, если контейнер можно распаковать как Map
        #// удобно использовать в методах unpack
        #// метод не бросает исключения - метод проверит что сможет и вернет false, если что-то не так
        #//
        #// внутреннее устройство Set: https://axforum.info/forums/showthread.php?t=27738
        #public static boolean isPackedOk(anytype packedMap, Types expectedKeyType = Types::AnyType, Types expectedValueType = Types::AnyType)
        #{
        #    boolean ret;
        #
        #    anytype version;
        #    anytype keyType;
        #    anytype valueType;
        #    anytype elements;
        #
        #    if( packedMap &&
        #        typeof(packedMap) == Types::Container &&
        #        conlen(packedMap) >= 4 )
        #    {
        #        [version, keyType, valueType, elements] = packedMap;
        #
        #        if( typeof(version)   == Types::Integer && version == 1 &&
        #            typeof(keyType)   == Types::Integer && TypeUtil::is(keyType, expectedKeyType) &&
        #            typeof(valueType) == Types::Integer && TypeUtil::is(valueType, expectedValueType) &&
        #            typeof(elements)  == Types::Integer )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public static boolean isType(Map map, Types keyType, Types valueType)
        #{
        #    boolean ret;
        #
        #    if( map )
        #    {
        #        ret = TypeUtil::is(map.keyType(), keyType) &&
        #              TypeUtil::is(map.valueType(), valueType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #keySet
        #public static Set keySet(Map map)
        #{
        #    Set ret;
        #
        #    if( map )
        #    {
        #        ret = map.keySet();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #keyType
        #public static Types keyType(Map map)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( map )
        #    {
        #        ret = map.keyType();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lookup
        #public static anytype lookup(Map map, anytype key)
        #{
        #    anytype ret;
        #
        #    if( map && map.exists(key) )
        #    {
        #        ret = map.lookup(key);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lookupAsValue
        #public static anytype lookupAsValue(Map map, anytype key, anytype asValue)
        #{
        #    anytype ret;
        #
        #    if( map && map.exists(key) )
        #    {
        #        ret = map.lookup(key);
        #    }
        #
        #    return AnytypeUtil::asValue(ret, asValue);
        #}
      ENDSOURCE
      SOURCE #lookupOrDefault
        #public static anytype lookupOrDefault(Map map, anytype key, anytype defaultValue)
        #{
        #    anytype ret;
        #
        #    if( map && map.exists(key) )
        #    {
        #        ret = map.lookup(key);
        #    }
        #    else
        #    {
        #        ret = defaultValue;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #lookupOrThrow
        #// бросает исключение, если map isNull или key отсутствует в map
        #public static anytype lookupOrThrow(Map map, anytype key)
        #{
        #    anytype ret = map.lookup(key);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newBy
        #// создать map для хранения значений, тип которых совпадает с типом переменной value
        #public static Map newBy(anytype key, anytype value)
        #{
        #    Types typeKey = typeof(key);
        #    Types typeValue = typeof(value);
        #    Map ret = new Map(typeKey, typeValue);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static Map nonNull(Map map, Types keyType = Types::AnyType, Types valueType = Types::AnyType)
        #{
        #    if( !map )
        #    {
        #        map = new Map(keyType, valueType);
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #pack
        #public static container pack(Map map)
        #{
        #    container ret;
        #
        #    if( map )
        #    {
        #        ret = map.pack();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #remove
        #public static Map remove(Map map, anytype key)
        #{
        #    if( map )
        #    {
        #        map.remove(key);
        #    }
        #
        #    return map;
        #}
      ENDSOURCE
      SOURCE #removeEmpty
        #// возвращает новый map, в котором удалены все пустые ключи и пустые value
        #public static Map removeEmpty(Map map)
        #{
        #    MapEnumerator e = MapUtil::getEnumerator(map);
        #    Map ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.currentKey() && e.currentValue() )
        #        {
        #            ret = MapUtil::insert(ret, e.currentKey(), e.currentValue());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeEmptyKeys
        #// возвращает новый map, в котором удалены все пустые ключи
        #public static Map removeEmptyKeys(Map map)
        #{
        #    MapEnumerator e = MapUtil::getEnumerator(map);
        #    Map ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.currentKey() )
        #        {
        #            ret = MapUtil::insert(ret, e.currentKey(), e.currentValue());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeEmptyValues
        #// возвращает новый map, в котором удалены все пустые value
        #public static Map removeEmptyValues(Map map)
        #{
        #    MapEnumerator e = MapUtil::getEnumerator(map);
        #    Map ret;
        #
        #    while( e && e.moveNext() )
        #    {
        #        if( e.currentValue() )
        #        {
        #            ret = MapUtil::insert(ret, e.currentKey(), e.currentValue());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #valueSet
        #public static Set valueSet(Map map)
        #{
        #    Set ret;
        #
        #    if( map )
        #    {
        #        ret = map.valueSet();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #valueType
        #public static Types valueType(Map map)
        #{
        #    Types ret = Types::AnyType;
        #
        #    if( map )
        #    {
        #        ret = map.valueType();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapOfSets unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapOfSets
    PROPERTIES
      Name                #MapOfSets
      Extends             #Map
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #add
        #// добавляет значение в Set, который привязан к ключу
        #public Set add(anytype key, anytype value)
        #{
        #    Set values = this.lookup(key);
        #
        #    if( AnytypeUtil::is(value, leafType) )
        #    {
        #        values = SetUtil::add(values, value);
        #        this.insert(key, values);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #// Map, который содержит множества (sets) значений в качестве value
        #//
        #// Map требует, чтобы типы ключей и значений были указаны при создании экземпляра
        #// поэтому мы вынуждены требовать тип ключей в new().
        #// Однако, тип значений в sets можно определить позже, при добавлении первого элемента.
        #//
        #class MapOfSets extends Map // {keyTypes, Types::Class}
        #{
        #    Types leafType;        // тип значений, которые содержатся или будут содержатся в sets
        #}
        #
        #// Рекомендация:
        #// не изменяйте поведение методов valueType и valueSet
        #// эти методы используются внутренними механизмами Аксапты
        #
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    str ret = super();
        #
        #    ret += strfmt(' of %1', leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #public MapEEnumerator getEEnumerator()
        #{
        #    MapEEnumerator ret = MapEEnumerator::construct(this);
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #getValuesEnumerator
        #public SetEEnumerator getValuesEnumerator(anytype key)
        #{
        #    Set values = this.lookup(key);
        #    SetEEnumerator ret = SetEEnumerator::construct(values);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #in
        #// проверяет значение в соотвествующем Set
        #public boolean in(anytype key, anytype value)
        #{
        #    boolean ret;
        #    Set values = this.lookup(key);
        #
        #    if( values )
        #    {
        #        ret = values.in(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #// сигнатура этого метода совпадает с сигнатурой метода в родительском классе
        #// используйте более специфичный insertSet чтобы и Аксапта тоже знала, что вторым аргументом Set
        #public boolean insert(anytype key, anytype values)
        #{
        #    boolean ret;
        #
        #    if( AnytypeUtil::is(key, this.keyType()) )
        #    {
        #        if( TypeUtil::isSpecified(leafType) && AnytypeUtil::isNull(values) )
        #        {
        #            values = new Set(leafType);
        #        }
        #
        #        if( AnytypeUtil::isSetWithType(values, leafType) ) // valueType может = Anytype
        #        {
        #            leafType = SetUtil::type(values);
        #            ret = super(key, values);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insertSet
        #public boolean insertSet(anytype key, Set values = null)
        #{
        #    boolean ret = this.insert(key, values);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public boolean isType(Types _keyType, Types _leafType)
        #{
        #    boolean ret =
        #            TypeUtil::is(this.keyType(), _keyType) &&
        #            TypeUtil::is(this.valueType(), Types::Class) &&
        #            TypeUtil::is(this.leafType(), _leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #leafSet
        #public Set leafSet()
        #{
        #    Set ret;
        #    MapEnumerator e = this.getEnumerator();
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = SetUtil::union(ret, e.currentValue());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #leafType
        #public Types leafType()
        #{
        #    return leafType;
        #}
      ENDSOURCE
      SOURCE #lookup
        #// сигнатура этого метода совпадает с сигнатурой метода в родительском классе
        #// используйте более специфичный lookupSet чтобы и Аксапта тоже знала, что будет возвращен Set
        #public anytype lookup(anytype key)
        #{
        #    Set values;
        #
        #    if( this.exists(key) )
        #    {
        #        values = super(key);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #lookupSet
        #public Set lookupSet(anytype key)
        #{
        #    Set values;
        #
        #    if( this.exists(key) )
        #    {
        #        values = this.lookup(key);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #new
        #// если valueType будет не определен, то тип значений будет уточнен при вставке методами insert или add
        #public void new(Types _keyType, Types _leafType = Types::AnyType)
        #{
        #    super(_keyType, Types::Class);
        #
        #    leafType = _leafType;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    str ret = super();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addTo
        #// добавляет значение в Set, который привязан к ключу
        #public static MapOfSets addTo(MapOfSets mapOfSets, anytype key, anytype value)
        #{
        #    if( !mapOfSets )
        #    {
        #        mapOfSets = MapOfSets::construct(typeof(key), typeof(value));
        #    }
        #
        #    if( mapOfSets )
        #    {
        #        mapOfSets.add(key, value); // игнорируем возможную ошибку вставки.
        #    }
        #
        #    return mapOfSets;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static MapOfSets construct(Types keyType, Types leafType = Types::AnyType)
        #{
        #    MapOfSets ret = new MapOfSets(keyType, leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static MapOfSets ensureType(MapOfSets mapOfSets, Types keyType, Types leafType)
        #{
        #    if( mapOfSets && mapOfSets.isType(keyType, leafType) )
        #    {
        #        return mapOfSets;
        #    }
        #
        #    throw error(strfmt('тип переменной mapOfSets не совпадает с ожидаемым key:%1, leaf:%2', keyType, leafType));
        #}
      ENDSOURCE
      SOURCE #newFrom
        #// добавляет значение в Set, который привязан к ключу
        #public static MapOfSets newFrom(anytype key, anytype value)
        #{
        #    MapOfSets ret = MapOfSets::addTo(null, key, value);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapOfSetsTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapOfSetsTest
    PROPERTIES
      Name                #MapOfSetsTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class MapOfSetsTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAddTo
        #void testAddTo()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', 2);
        #    m = MapOfSets::addTo(m, 'b', 3);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_Empty
        #void testAddTo_Empty()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::String);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_EnumKey
        #void testAddTo_EnumKey()
        #{
        #    MapOfSets m = MapOfSets::newFrom(StatusIssue::Sold, 1);
        #    ;
        #
        #    m = MapOfSets::addTo(m, StatusIssue::Sold, 2);
        #    m = MapOfSets::addTo(m, StatusIssue::Deducted, 3);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::Enum, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_EnumValue
        #void testAddTo_EnumValue()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', StatusIssue::Sold);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', StatusIssue::Deducted);
        #    m = MapOfSets::addTo(m, 'b', StatusIssue::Sold);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Enum, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_Null
        #void testAddTo_Null()
        #{
        #    MapOfSets m = MapOfSets::addTo(null, 'a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_sameKey
        #void testAddTo_SameKey()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_WrongKeyType
        #void testAddTo_WrongKeyType()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::String, Types::Integer);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 10, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_WrongValueType
        #void testAddTo_WrongValueType()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::String, Types::Integer);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'b', 'str');
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #void testConstruct()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::String, Types::String);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::String, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct_AnytypeKey
        #void testConstruct_AnytypeKey()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::AnyType, Types::Integer);
        #
        #    m.add('a', 2);
        #    m.add(3, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::Anytype, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct_DefaultValueType
        #void testConstruct_DefaultValueType()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::String);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::AnyType, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testEnsureType
        #void testEnsureType()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::Date,Types::Integer);
        #
        #    this.assertNotNull(m);
        #
        #    this.parmExceptionExpected(false);
        #
        #    MapOfSets::ensureType(m, Types::Date   , Types::Integer);
        #    MapOfSets::ensureType(m, Types::AnyType, Types::AnyType);
        #    MapOfSets::ensureType(m, Types::Date   , Types::AnyType);
        #    MapOfSets::ensureType(m, Types::AnyType, Types::Integer);
        #
        #    this.parmExceptionExpected(true);
        #
        #    MapOfSets::ensureType(m, Types::String, Types::String);
        #}
      ENDSOURCE
      SOURCE #testIn
        #void testIn()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', 2);
        #    m = MapOfSets::addTo(m, 'b', 3);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertTrue (m.in('a', 1), '1 in a');
        #    this.assertTrue (m.in('a', 2), '2 in a');
        #    this.assertFalse(m.in('a', 3), '3 in a');
        #
        #    this.assertFalse(m.in('b', 1), '1 in b');
        #    this.assertFalse(m.in('b', 2), '2 in b');
        #    this.assertTrue (m.in('b', 3), '3 in b');
        #}
      ENDSOURCE
      SOURCE #testIn_AnytypeKey
        #void testIn_AnytypeKey()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::AnyType);   // все ключи равны -> все в один элемент
        #    ;
        #
        #    m.add('a', 2);
        #    m.add(300, 4);
        #    m.add(StatusIssue::Sold, 6);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #    this.assertEquals(1, m.elements());
        #
        #    this.assertFalse(m.in('a', 1), '1 in a');
        #    this.assertTrue (m.in('a', 2), '2 in a');
        #    this.assertTrue (m.in('a', 4), '4 in a');
        #    this.assertTrue (m.in('a', 6), '6 in a');
        #
        #    this.assertFalse(m.in(300, 1), '1 in 300');
        #    this.assertTrue (m.in(300, 2), '2 in 300');
        #    this.assertTrue (m.in(300, 4), '4 in 300');
        #    this.assertTrue (m.in(300, 6), '6 in 300');
        #
        #    this.assertFalse(m.in(StatusIssue::Sold, 1), '1 in Sold');
        #    this.assertTrue (m.in(StatusIssue::Sold, 2), '2 in Sold');
        #    this.assertTrue (m.in(StatusIssue::Sold, 4), '4 in Sold');
        #    this.assertTrue (m.in(StatusIssue::Sold, 6), '6 in Sold');
        #}
      ENDSOURCE
      SOURCE #testIsType
        #void testIsType()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::Date,Types::Integer);
        #
        #    this.assertNotNull(m);
        #
        #    this.info('valid types');
        #
        #    this.assertTrue(m.isType(Types::Date   , Types::Integer));
        #    this.assertTrue(m.isType(Types::AnyType, Types::AnyType));
        #    this.assertTrue(m.isType(Types::Date   , Types::AnyType));
        #    this.assertTrue(m.isType(Types::AnyType, Types::Integer));
        #
        #    this.info('wrong types');
        #
        #    this.assertFalse(m.isType(Types::String, Types::String));
        #}
      ENDSOURCE
      SOURCE #testIsType_VarString
        #void testIsType_VarString()
        #{
        #    MapOfSets m = MapOfSets::construct(Types::RString,Types::VarString);
        #
        #    this.assertNotNull(m);
        #
        #    this.info('valid types');
        #
        #    this.assertTrue(m.isType(Types::String , Types::String));
        #    this.assertTrue(m.isType(Types::RString , Types::RString));
        #    this.assertTrue(m.isType(Types::VarString , Types::VarString));
        #
        #    this.info('wrong types');
        #
        #    this.assertFalse(m.isType(Types::Integer, Types::Container));
        #}
      ENDSOURCE
      SOURCE #testNewFrom
        #void testNewFrom()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testNewFrom_AnytypeKey
        #void testNewFrom_AnytypeKey()
        #{
        #    anytype key; // not defined value
        #    MapOfSets m = MapOfSets::newFrom(key, 1);
        #
        #    m.add('a', 2);
        #    m.add(3, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::Anytype, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testToString
        #void testToString()
        #{
        #    MapOfSets m = MapOfSets::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfSets::addTo(m, 'a', 2);
        #    m = MapOfSets::addTo(m, 'b', 3);
        #
        #    this.assertNotNull(m);
        #    this.assertEquals('["a"->(C) Set: {1, 2},"b"->(C) Set: {3}]', m.toString());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapOfLists unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapOfLists
    PROPERTIES
      Name                #MapOfLists
      Extends             #Map
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #add
        #// добавляет значение в List, который привязан к ключу
        #public List add(anytype key, anytype value)
        #{
        #    List values = this.lookup(key);
        #
        #    if( AnytypeUtil::is(value, leafType) )
        #    {
        #        values = ListUtil::add(values, value);
        #        this.insert(key, values);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #// Map, который содержит списки значений в качестве value
        #//
        #// Map требует, чтобы типы ключей и типы значений были указаны при создании экземпляра
        #// поэтому мы вынуждены требовать тип ключей в new().
        #// Однако, тип значений в lists можно определить позже, при добавлении первого элемента.
        #//
        #class MapOfLists extends Map // {keyTypes, Types::Class}
        #{
        #    Types leafType;
        #}
        #
        #// Рекомендация:
        #// не изменяйте поведение методов valueType и valueSet
        #// эти методы используются внутренними механизмами Аксапты
        #
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    str ret = super();
        #
        #    ret += strfmt(' of %1', leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #public MapEEnumerator getEEnumerator()
        #{
        #    MapEEnumerator ret = MapEEnumerator::construct(this);
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #getValuesEnumerator
        #public ListEEnumerator getValuesEnumerator(anytype key)
        #{
        #    List values = this.lookup(key);
        #    ListEEnumerator ret = ListEEnumerator::construct(values);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insert
        #// сигнатура этого метода совпадает с сигнатурой метода в родительском классе
        #// используйте более специфичный insertList чтобы и Аксапта тоже знала, что вторым аргументом List
        #public boolean insert(anytype key, anytype values)
        #{
        #    boolean ret;
        #
        #    if( AnytypeUtil::is(key, this.keyType()) )
        #    {
        #        if( TypeUtil::isSpecified(leafType) && AnytypeUtil::isNull(values) )
        #        {
        #            values = new List(leafType);
        #        }
        #
        #        if( AnytypeUtil::isListWithType(values, leafType) ) // valueType может = Anytype
        #        {
        #            leafType = ListUtil::type(values);
        #            ret = super(key, values);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insertList
        #public boolean insertList(anytype key, List values = null)
        #{
        #    boolean ret = this.insert(key, values);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isType
        #public boolean isType(Types _keyType, Types _leafType)
        #{
        #    boolean ret =
        #            TypeUtil::is(this.keyType(), _keyType) &&
        #            TypeUtil::is(this.valueType(), Types::Class) &&
        #            TypeUtil::is(this.leafType(), _leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #leafSet
        #public Set leafSet()
        #{
        #    Set ret;
        #    MapEnumerator e = this.getEnumerator();
        #
        #    while( e && e.moveNext() )
        #    {
        #        ret = SetUtil::addAll(ret, e.currentValue());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #leafType
        #public Types leafType()
        #{
        #    return leafType;
        #}
      ENDSOURCE
      SOURCE #lookup
        #public anytype lookup(anytype key)
        #{
        #    List values;
        #
        #    if( this.exists(key) )
        #    {
        #        values = super(key);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #lookupList
        #// сигнатура этого метода совпадает с сигнатурой метода в родительском классе
        #// используйте более специфичный lookupList чтобы и Аксапта тоже знала, что будет возвращен List
        #public List lookupList(anytype key)
        #{
        #    List values;
        #
        #    if( this.exists(key) )
        #    {
        #        values = this.lookup(key);
        #    }
        #
        #    return values;
        #}
      ENDSOURCE
      SOURCE #new
        #// если leafType будет не определен, то тип значений будет уточнен при вставке методами insert или add
        #public void new(Types _keyType, Types _leafType = Types::AnyType)
        #{
        #    super(_keyType, Types::Class);
        #
        #    leafType = _leafType;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    str ret = super();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addTo
        #// добавляет значение в List, который привязан к ключу
        #public static MapOfLists addTo(MapOfLists mapOfLists, anytype key, anytype value)
        #{
        #    if( !mapOfLists )
        #    {
        #        mapOfLists = MapOfLists::construct(typeof(key), typeof(value));
        #    }
        #
        #    if( mapOfLists )
        #    {
        #        mapOfLists.add(key, value); // игнорируем возможную ошибку вставки.
        #    }
        #
        #    return mapOfLists;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static MapOfLists construct(Types keyType, Types leafType = Types::AnyType)
        #{
        #    MapOfLists ret = new MapOfLists(keyType, leafType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureType
        #public static MapOfLists ensureType(MapOfLists mapOfLists, Types keyType, Types leafType)
        #{
        #    if( mapOfLists && mapOfLists.isType(keyType, leafType) )
        #    {
        #        return mapOfLists;
        #    }
        #
        #    throw error(strfmt('тип переменной mapOfLists не совпадает с ожидаемым key:%1, leaf:%2', keyType, leafType));
        #}
      ENDSOURCE
      SOURCE #newFrom
        #// добавляет значение в List, который привязан к ключу
        #public static MapOfLists newFrom(anytype key, anytype value)
        #{
        #    MapOfLists ret = MapOfLists::addTo(null, key, value);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapOfListsTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapOfListsTest
    PROPERTIES
      Name                #MapOfListsTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class MapOfListsTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAddTo
        #void testAddTo()
        #{
        #    MapOfLists m = MapOfLists::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'a', 2);
        #    m = MapOfLists::addTo(m, 'b', 3);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_Empty
        #void testAddTo_Empty()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::String);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_EnumKey
        #void testAddTo_EnumKey()
        #{
        #    MapOfLists m = MapOfLists::newFrom(StatusIssue::Sold, 1);
        #    ;
        #
        #    m = MapOfLists::addTo(m, StatusIssue::Sold, 2);
        #    m = MapOfLists::addTo(m, StatusIssue::Deducted, 3);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::Enum, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_EnumValue
        #void testAddTo_EnumValue()
        #{
        #    MapOfLists m = MapOfLists::newFrom('a', StatusIssue::Sold);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'a', StatusIssue::Deducted);
        #    m = MapOfLists::addTo(m, 'b', StatusIssue::Sold);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(2, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Enum, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_Null
        #void testAddTo_Null()
        #{
        #    MapOfLists m = MapOfLists::addTo(null, 'a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_SameKey
        #void testAddTo_SameKey()
        #{
        #    MapOfLists m = MapOfLists::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'a', 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_WrongKeyType
        #void testAddTo_WrongKeyType()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::String, Types::Integer);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 10, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testAddTo_WrongValueType
        #void testAddTo_WrongValueType()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::String, Types::Integer);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'b', 'str');
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #void testConstruct()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::String, Types::String);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::String, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct_AnytypeKey
        #void testConstruct_AnytypeKey()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::AnyType, Types::Integer);
        #
        #    m.add('a', 2);
        #    m.add(3, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::Anytype, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testConstruct_DefaultValueType
        #void testConstruct_DefaultValueType()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::String);
        #
        #    this.assertNotNull(m);
        #    this.assertTrue(m.empty());
        #
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::AnyType, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testEnsureType
        #void testEnsureType()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::Date,Types::Integer);
        #
        #    this.assertNotNull(m);
        #
        #    this.parmExceptionExpected(false);
        #
        #    MapOfLists::ensureType(m, Types::Date   , Types::Integer);
        #    MapOfLists::ensureType(m, Types::AnyType, Types::AnyType);
        #    MapOfLists::ensureType(m, Types::Date   , Types::AnyType);
        #    MapOfLists::ensureType(m, Types::AnyType, Types::Integer);
        #
        #    this.parmExceptionExpected(true);
        #
        #    MapOfLists::ensureType(m, Types::String, Types::String);
        #}
      ENDSOURCE
      SOURCE #testIsType
        #void testIsType()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::Date,Types::Integer);
        #
        #    this.assertNotNull(m);
        #
        #    this.info('valid types');
        #
        #    this.assertTrue(m.isType(Types::Date   , Types::Integer));
        #    this.assertTrue(m.isType(Types::AnyType, Types::AnyType));
        #    this.assertTrue(m.isType(Types::Date   , Types::AnyType));
        #    this.assertTrue(m.isType(Types::AnyType, Types::Integer));
        #
        #    this.info('wrong types');
        #
        #    this.assertFalse(m.isType(Types::String, Types::String));
        #}
      ENDSOURCE
      SOURCE #testIsType_VarString
        #void testIsType_VarString()
        #{
        #    MapOfLists m = MapOfLists::construct(Types::RString,Types::VarString);
        #
        #    this.assertNotNull(m);
        #
        #    this.info('valid types');
        #
        #    this.assertTrue(m.isType(Types::String , Types::String));
        #    this.assertTrue(m.isType(Types::RString , Types::RString));
        #    this.assertTrue(m.isType(Types::VarString , Types::VarString));
        #
        #    this.info('wrong types');
        #
        #    this.assertFalse(m.isType(Types::Integer, Types::Container));
        #}
      ENDSOURCE
      SOURCE #testNewFrom
        #void testNewFrom()
        #{
        #    MapOfLists m = MapOfLists::newFrom('a', 1);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::String, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testNewFrom_AnytypeKey
        #void testNewFrom_AnytypeKey()
        #{
        #    anytype key; // not defined value
        #    MapOfLists m = MapOfLists::newFrom(key, 1);
        #
        #    m.add('a', 2);
        #    m.add(3, 2);
        #
        #    this.assertNotNull(m);
        #    this.assertFalse(m.empty());
        #
        #    this.assertEquals(1, m.elements());
        #    this.assertEquals(Types::Anytype, m.keyType());
        #    this.assertEquals(Types::Integer, m.leafType());
        #}
      ENDSOURCE
      SOURCE #testToString
        #void testToString()
        #{
        #    MapOfLists m = MapOfLists::newFrom('a', 1);
        #    ;
        #
        #    m = MapOfLists::addTo(m, 'a', 2);
        #    m = MapOfLists::addTo(m, 'b', 3);
        #
        #    this.assertNotNull(m);
        #    this.assertEquals('["a"->(C) List: <1, 2>,"b"->(C) List: <3>]', m.toString());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: EnumeratorUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #EnumeratorUtil
    PROPERTIES
      Name                #EnumeratorUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class EnumeratorUtil
        #{
        #}
      ENDSOURCE
      SOURCE #current
        #void current() // TODO !!!
        #{
        #}
      ENDSOURCE
      SOURCE #currentAs
        #void currentAs() // TODO !!!
        #{
        #}
      ENDSOURCE
      SOURCE #currentAsValue
        #void currentAsValue() // TODO !!!
        #{
        #}
      ENDSOURCE
      SOURCE #head
        #public Enumerator head() // TODO
        #{
        #}
      ENDSOURCE
      SOURCE #tail
        #public Enumerator tail()
        #{
        #}
      ENDSOURCE
      SOURCE #asEEnumerator
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static EEnumerator asEEnumerator(anytype value)
        #{
        #    if( EnumeratorUtil::isEEnumerator(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asEnumerable
        #public static anytype asEnumerable(anytype value)
        #{
        #    if( EnumeratorUtil::isEnumerable(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #asEnumerator
        #public static Enumerator asEnumerator(anytype value)
        #{
        #    if( EnumeratorUtil::isEnumerator(value) )
        #    {
        #        return value;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// возвращает @nonNull объект, который реализует интерфейс EEnumerator
        #// если в качестве аргумента передана не коллекция, то возвращает энумератор по коллекции из одного элемента
        #// поэтому результат этого метода всегда можно энумерировать
        #//
        #// используйте CollectionUtil::getEnumerator()
        #// если хотите получить энумератор только для коллекции, но не по элементу
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #public static EEnumerator getEEnumerator(anytype collectionOrValue)
        #{
        #    EEnumerator e = CollectionUtil::getEEnumerator(collectionOrValue);
        #
        #    if( !e )
        #    {
        #        e = OneValueEnumerator::construct(collectionOrValue);
        #    }
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает @nonNull объект, который реализует интерфейс Enumerator
        #// если в качестве аргумента передана не коллекция, то возвращает энумератор по коллекции из одного элемента
        #// поэтому результат этого метода всегда можно энумерировать
        #//
        #// используйте CollectionUtil::getEnumerator()
        #// если хотите получить энумератор только для коллекции, но не по элементу
        #public static Enumerator getEnumerator(anytype collectionOrValue)
        #{
        #    Enumerator e = CollectionUtil::getEnumerator(collectionOrValue);
        #
        #    if( !e )
        #    {
        #        e = OneValueEnumerator::construct(collectionOrValue);
        #    }
        #
        #    return e;
        #}
      ENDSOURCE
      SOURCE #isEEnumerator
        #public static boolean isEEnumerator(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isEEnumerator(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для значения, для которого можно получить enumerator
        #public static boolean isEnumerable(anytype value)
        #{
        #    Types type = typeof(value);
        #
        #    switch( type )
        #    {
        #        case Types::Container:
        #        case Types::Record:
        #            return true;
        #
        #        case Types::Class:
        #            return ObjectUtil::isEnumerable(value);
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #public static boolean isEnumerator(anytype value)
        #{
        #    boolean ret;
        #
        #    if( typeof(value) == Types::Class )
        #    {
        #        ret = ObjectUtil::isEnumerator(value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #skip
        #// пропускает заданное количество итераций
        #// возвращает true, если после пропуска мы все еще находимся внутри коллекции
        #public static boolean skip(Enumerator e, int skipIterations = 1)
        #{
        #    boolean ret = true;
        #
        #    while( ret && e && skipIterations > 0 )
        #    {
        #        ret = e.moveNext();
        #        skipIterations--;
        #    }
        #
        #    ret = (ret && e && skipIterations <= 0);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: EnumeratorUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #EnumeratorUtilTest
    PROPERTIES
      Name                #EnumeratorUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class EnumeratorUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testSkip
        #void testSkip()
        #{
        #    ConEnumerator e = ConEnumerator::construct([1,2,3,4,5]);
        #    ;
        #
        #    this.assertTrue(EnumeratorUtil::skip(e, 2));
        #    while( e && e.moveNext() )
        #    {
        #        this.assertEquals(3, e.current());
        #        this.assertTrue(EnumeratorUtil::skip(e, 2));
        #    }
        #}
      ENDSOURCE
      SOURCE #testSkipEmptyContainer
        #void testSkipEmptyContainer()
        #{
        #    ConEnumerator e = ConEnumerator::construct(connull());
        #    ;
        #
        #    this.assertFalse(EnumeratorUtil::skip(e, 2));
        #}
      ENDSOURCE
      SOURCE #testSkipEmptyList
        #void testSkipEmptyList()
        #{
        #    List list = new List(Types::Integer);
        #    ListEnumerator e = list.getEnumerator();
        #    ;
        #
        #    this.assertFalse(EnumeratorUtil::skip(e, 2));
        #}
      ENDSOURCE
      SOURCE #testSkipEmptySet
        #void testSkipEmptySet()
        #{
        #    Set set = new Set(Types::Integer);
        #    SetEnumerator e = set.getEnumerator();
        #    ;
        #
        #    this.assertFalse(EnumeratorUtil::skip(e, 2));
        #}
      ENDSOURCE
      SOURCE #testSkipNull
        #void testSkipNull()
        #{
        #    ;
        #
        #    this.assertFalse(EnumeratorUtil::skip(null, 2));
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: EEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  INTERFACE #EEnumerator
    PROPERTIES
      Name                #EEnumerator
      Extends             #Enumerator
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #// Extended Enumerator
        #//
        #// наследование интерфейсов вместо mixin улучшает intellisence, а также
        #// вместо двух проверок (энумератор и индексированный) достаточно одной is(IdxEnumerator)
        #//
        #// в наследуемых классах рекомендуется перечислять оба интерфейса. @see ConEnumerator
        #// чтобы аксапта позволяла явно присваивать переменным с типом Enumerator.
        #// тип Enumerator может использоваться в "универсальных" алгоритмах
        #//
        #// TODO добавить limit (maxElements)?
        #//
        #interface EEnumerator extends Enumerator
        #{
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    // return Idx;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    // return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SetEEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SetEEnumerator
    PROPERTIES
      Name                #SetEEnumerator
      Extends             #SetEnumerator
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #// Энумератор с индексом и скипом для set явно реализует интерфейсы Enumerator и EEnumerator
        #// и расширяет функционал класса SetEnumerator,
        #// чтобы объект этого типа можно было бы передавать туда, где принимается SetEnumerator.
        #//
        #// у класса SetEnumerator нельзя передать set в метод new
        #// поэтому приходится использовать переменную внутри класса.
        #// и НЕ использовать функционал родительского объекта (да, тратим память ради удобства).
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #class SetEEnumerator extends SetEnumerator implements Enumerator, EEnumerator
        #{
        #    SetEnumerator e;
        #
        #    int idx; // 0: before, >0: inside, <0: after. Inside if (pos > 0)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    anytype ret;
        #
        #    if( e )
        #    {
        #        ret = e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return classstr(SetEEnumerator); // TODO
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(Set set)
        #{
        #    ;
        #
        #    e = set ? set.getEnumerator() : null;
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    boolean ret;
        #
        #    if( e )
        #    {
        #        ret = e.moveNext();
        #    }
        #
        #    if( ret )
        #    {
        #        idx++;
        #    }
        #    else
        #    {
        #        idx = -1;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #//BP deviation documented
        #// @override - не вызываем super
        #public void new(Set set = null)
        #{
        #    this.init(set);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    if( e )
        #    {
        #        e.reset();
        #    }
        #
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #// поскольку этот метод может вызваться в отладчике еще до инициализации,
        #// то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #// и ни в коем случае не бросаем исключение на неинициализированные значения
        #public str toString()
        #{
        #    str ret = 'SetEEnumerator(null)';
        #
        #    if( e )
        #    {
        #        ret = e.toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static SetEEnumerator construct(Set set)
        #{
        #    SetEEnumerator ret;
        #
        #    if( set )
        #    {
        #        ret = new SetEEnumerator(set);
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static SetEEnumerator constructAndSkip(Set set, int skipIterations)
        #{
        #    SetEEnumerator ret = SetEEnumerator::construct(set);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #constructIfType
        #public static SetEEnumerator constructIfType(Set set, Types valueType)
        #{
        #    SetEEnumerator ret;
        #
        #    if( SetUtil::isType(set, valueType) )
        #    {
        #        ret = SetEEnumerator::construct(set);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ListEEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ListEEnumerator
    PROPERTIES
      Name                #ListEEnumerator
      Extends             #SetEnumerator
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #// Энумератор с индексом и скипом для list явно реализует интерфейсы Enumerator и EEnumerator
        #// и расширяет функционал класса ListEnumerator,
        #// чтобы объект этого типа можно было бы передавать туда, где принимается ListEnumerator.
        #//
        #// у класса ListEnumerator нельзя передать list в метод new
        #// поэтому приходится использовать переменную внутри класса.
        #// и НЕ использовать функционал родительского объекта (да, тратим память ради удобства).
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #class ListEEnumerator extends SetEnumerator implements Enumerator, EEnumerator
        #{
        #    ListEnumerator e;
        #
        #    int idx; // 0: before, >0: inside, <0: after. Inside if (pos > 0)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    anytype ret;
        #
        #    if( e )
        #    {
        #        ret = e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return classstr(ListEEnumerator); // TODO
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(List list)
        #{
        #    ;
        #
        #    e = list ? list.getEnumerator() : null;
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    boolean ret;
        #
        #    if( e )
        #    {
        #        ret = e.moveNext();
        #    }
        #
        #    if( ret )
        #    {
        #        idx++;
        #    }
        #    else
        #    {
        #        idx = -1;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #//BP deviation documented
        #// @override - не вызываем super
        #public void new(list list = null)
        #{
        #    this.init(list);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    if( e )
        #    {
        #        e.reset();
        #    }
        #
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #// поскольку этот метод может вызваться в отладчике еще до инициализации,
        #// то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #// и ни в коем случае не бросаем исключение на неинициализированные значения
        #public str toString()
        #{
        #    str ret = 'ListEEnumerator(null)';
        #
        #    if( e )
        #    {
        #        ret = e.toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static ListEEnumerator construct(List list)
        #{
        #    ListEEnumerator ret;
        #
        #    if( list )
        #    {
        #        ret = new ListEEnumerator(list);
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static ListEEnumerator constructAndSkip(List list, int skipIterations)
        #{
        #    ListEEnumerator ret = ListEEnumerator::construct(list);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #constructIfType
        #public static ListEEnumerator constructIfType(List list, Types valueType)
        #{
        #    ListEEnumerator ret;
        #
        #    if( ListUtil::isType(list, valueType) )
        #    {
        #        ret = ListEEnumerator::construct(list);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: MapEEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MapEEnumerator
    PROPERTIES
      Name                #MapEEnumerator
      Extends             #MapEnumerator
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #// Энумератор с индексом и скипом для Map явно реализует интерфейсы Enumerator и EEnumerator
        #// и расширяет функционал класса MapEnumerator,
        #// чтобы объект этого типа можно было бы передавать туда, где принимается MapEnumerator.
        #//
        #// у класса MapEnumerator нельзя передать map в метод new
        #// поэтому приходится использовать переменную внутри класса.
        #// и НЕ использовать функционал родительского объекта (да, тратим память ради удобства).
        #//
        #// @see EEnumerator - расширенный энумератор, который умеет показывать номер текущего элемента и другое полезное
        #//
        #class MapEEnumerator extends MapEnumerator implements Enumerator, EEnumerator
        #{
        #    MapEnumerator e;
        #
        #    int idx; // 0: before, >0: inside, <0: after. Inside if (pos > 0)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    anytype ret;
        #
        #    if( e )
        #    {
        #        ret = e.current();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #currentKey
        #public anytype currentKey()
        #{
        #    anytype ret;
        #
        #    if( e )
        #    {
        #        ret = e.currentKey();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #currentValue
        #public anytype currentValue()
        #{
        #    anytype ret;
        #
        #    if( e )
        #    {
        #        ret = e.currentValue();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return classStr(MapEEnumerator); // TODO
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(Map map)
        #{
        #    ;
        #
        #    e = map ? map.getEnumerator() : null;
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    boolean ret;
        #
        #    if( e )
        #    {
        #        ret = e.moveNext();
        #    }
        #
        #    if( ret )
        #    {
        #        idx++;
        #    }
        #    else
        #    {
        #        idx = -1;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #//BP deviation documented
        #// @override - не вызываем super
        #public void new(Map map = null)
        #{
        #    this.init(map);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    if( e )
        #    {
        #        e.reset();
        #    }
        #
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #// поскольку этот метод может вызваться в отладчике еще до инициализации,
        #// то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #// и ни в коем случае не бросаем исключение на неинициализированные значения
        #public str toString()
        #{
        #    str ret = 'MapEEnumerator(null)';
        #
        #    if( e )
        #    {
        #        ret = e.toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static MapEEnumerator construct(Map map)
        #{
        #    MapEEnumerator ret;
        #
        #    if( map )
        #    {
        #        ret = new MapEEnumerator(map);
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static MapEEnumerator constructAndSkip(Map map, int skipIterations)
        #{
        #    MapEEnumerator ret = MapEEnumerator::construct(map);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #constructIfType
        #public static MapEEnumerator constructIfType(Map map, Types keyType, Types valueType)
        #{
        #    MapEEnumerator ret;
        #
        #    if( MapUtil::isType(map, keyType, valueType) )
        #    {
        #        ret = MapEEnumerator::construct(map);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArrayEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArrayEnumerator
    PROPERTIES
      Name                #ArrayEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public class ArrayEnumerator implements Enumerator, EEnumerator
        #{
        #    Array   arr;
        #    int     idx;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( arr )
        #    {
        #        // мы не делаем никаких проверок индекса
        #        // ядро выбросит исключение, если индекс выходит за пределы массива
        #        return arr.value(idx);
        #    }
        #
        #    return AnytypeUtil::undefined();
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'Array enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(Array _arr)
        #{;
        #    arr = _arr;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if(arr && idx < arr.lastIndex())
        #    {
        #        idx++;
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Array _arr)
        #{
        #    this.init(_arr);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    return AnytypeUtil::toString(this.current());
        #}
      ENDSOURCE
      SOURCE #construct
        #public static ArrayEnumerator construct(Array arr)
        #{
        #    ArrayEnumerator ret;
        #
        #    if( arr )
        #    {
        #        ret = new ArrayEnumerator(arr);
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static ArrayEnumerator constructAndSkip(Array arr, int skipIterations)
        #{
        #    ArrayEnumerator ret = ArrayEnumerator::construct(arr);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #constructIfType
        #public static ArrayEnumerator constructIfType(Array arr, Types valueType)
        #{
        #    ArrayEnumerator ret;
        #
        #    if( ArrayUtil::isType(arr, valueType) )
        #    {
        #        ret = ArrayEnumerator::construct(arr);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ConEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ConEnumerator
    PROPERTIES
      Name                #ConEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public class ConEnumerator implements Enumerator, EEnumerator
        #{
        #    container   con;
        #    int         len;
        #    int         idx;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    // никаких проверок:
        #    // если индекс выходит за границы контейнера, то conPeek возвратит целый 0
        #    return conPeek(con, idx);
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'Container enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(container _con)
        #{
        #    con = _con;
        #    len = conlen(con);
        #}
        #
      ENDSOURCE
      SOURCE #len
        #public int len()
        #{
        #    return len;
        #}
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if( idx < len )
        #    {
        #        idx++;
        #        return true;
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(container _con)
        #{
        #    this.init(_con);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    idx = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    return AnytypeUtil::toString(this.current());
        #}
      ENDSOURCE
      SOURCE #construct
        #public static server ConEnumerator construct(container con)
        #{
        #    return new ConEnumerator(con);
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static ConEnumerator constructAndSkip(container con, int skipIterations)
        #{
        #    ConEnumerator ret = ConEnumerator::construct(con);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse a container.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: EnumEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #EnumEnumerator
    PROPERTIES
      Name                #EnumEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// выполняет итерации по всем элементам переданного в конструктор enum
        #//
        #public class EnumEnumerator implements Enumerator, EEnumerator
        #{
        #    anytype     origValue;      // запомним любое значение, которое прислал внешний код
        #    anytype     currentEnum;    // текущее значение enum, если в класс был прислан enum. или неинициализированное значение Anytype
        #    DictEnum    dictEnum;       // если в класс передали не enum, то здесь будет null, а энумератор не сделает ни одной итерации
        #    int         len;            // если в класс передали не enum, то длина будет = 0, а энумератор не сделает ни одной итерации
        #    int         idx;
        #
        #    boolean     hideFirstEntry;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    return currentEnum;
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'enum enumerator';
        #}
      ENDSOURCE
      SOURCE #dictEnum
        #public DictEnum dictEnum()
        #{
        #    return dictEnum;
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(anytype value, int _hideFirstEntry = false)
        #{
        #    EnumId enumId = DictEnum::value2id(value);
        #    ;
        #
        #    origValue = value; // запомним любое значение, которое прислал внешний код
        #    hideFirstEntry = _hideFirstEntry;
        #
        #    if( enumId )
        #    {
        #        currentEnum = value; // фиксируем тип anytype переменной в enum
        #        dictEnum = new DictEnum(enumId);
        #        len = dictEnum.values();
        #    }
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    boolean ret = false;
        #
        #    if( dictEnum && idx < len )
        #    {
        #        idx++;
        #        ret = (idx < len);
        #
        #        if( ret )
        #        {
        #            currentEnum = dictEnum.index2Value(idx);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(anytype value, int _hideFirstEntry = false)
        #{
        #    this.init(value, _hideFirstEntry);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    idx = -1;   // индекс для не опеределенного значения enum
        #
        #    if( hideFirstEntry )
        #    {
        #        idx++;
        #    }
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    str ret;
        #
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    if( dictEnum )
        #    {
        #        ret = strfmt('%1:%2', dictEnum.name(), currentEnum);
        #    }
        #    else
        #    {
        #        ret = '<unknown enum>';
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #// принимает любой anytype, но итерации сделает только для enum.
        #// если передать enum, то выполнит итерации по всем элементам
        #// если передать не enum, то не сделает ни одной итерации
        #public static server EnumEnumerator construct(anytype value, int hideFirstEntry = false)
        #{
        #    return new EnumEnumerator(value, hideFirstEntry);
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse a enum.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: OneValueEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #OneValueEnumerator
    PROPERTIES
      Name                #OneValueEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// enumerator для ОДНОГО значения произвольного типа
        #class OneValueEnumerator implements Enumerator, EEnumerator
        #{
        #    anytype currentValue;
        #    int pos; // 0: before, 1: inside, >1: after. Inside if (pos == 1)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( pos == 1 )
        #    {
        #        return currentValue;
        #    }
        #
        #    return AnytypeUtil::undefined();
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return pos;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return strfmt('anytype[%1] enumerator', typeof(currentValue));
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// повторный вызов этого метода не приведет к изменению типа переменной currentValue. И не должен приводить.
        #// не вызывайте этот метод напрямую.
        #public void init(anytype value)
        #{
        #    currentValue = value;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    pos++;
        #
        #    return (pos == 1);
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(anytype value)
        #{
        #    this.init(value);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    pos = 0;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    if( pos < 1 )
        #    {
        #        return '(before)';
        #    }
        #    else if( pos > 1 )
        #    {
        #        return '(end)';
        #    }
        #
        #    return strfmt('[%1]', currentValue);
        #}
      ENDSOURCE
      SOURCE #construct
        #public static OneValueEnumerator construct(anytype value)
        #{
        #    return new OneValueEnumerator(value);
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordEnumerator
    PROPERTIES
      Name                #RecordEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// enumerator по записям, которые выбраны оператором select
        #// работает по постоянным и временным таблицам
        #class RecordEnumerator implements Enumerator, EEnumerator
        #{
        #    // для временных таблиц переменные указывают на разные буфера в куче
        #    // для регулярных таблиц переменные указывают на один и тот же буфер в куче
        #    Common origBuf;
        #    Common currentBuf;
        #
        #    int idx; // 0: before, >0: inside, <0: after. Inside if (pos > 0)
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    if( idx > 0 )
        #    {
        #        return currentBuf;
        #    }
        #
        #    return RecordUtil::commonRecord();
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return idx;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return strfmt('record[%2:%3] enumerator', currentBuf.TableId, tableid2name(currentBuf.TableId));
        #}
      ENDSOURCE
      SOURCE #init
        #// не вызывайте этот метод напрямую.
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// повторный вызов этого метода не приведет к изменению типа переменной currentValue. И не должен приводить.
        #public void init(Common buf)
        #{
        #    origBuf = buf;
        #
        #    idx = 0;
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #public boolean moveNext()
        #{
        #    if( idx == 0 )
        #    {
        #        if( currentBuf.isTmp() )
        #        {
        #            // создаем отдельный буфер на временные данные
        #            currentBuf = RecordUtil::makeRecordTmp(origBuf);
        #            currentBuf.setTmpData(origBuf);
        #            select currentBuf;
        #        }
        #        else
        #        {
        #            currentBuf = origBuf;
        #            // обе переменные разделяют один и тот же буфер в куче для регулярных таблиц
        #            // нет способа создать clone буфера и при этом сохранить запросы select на разделенных буферах
        #        }
        #    }
        #    else if( idx > 0 && currentBuf.RecId )
        #    {
        #        next currentBuf;
        #        // next изменит состояние буфера в куче.
        #        // поэтому у регулярных таблиц здесь изменится и currentBuf, и origBuf
        #        // а для временных таблиц здесь изменится только currentBuf
        #    }
        #
        #    if( currentBuf.RecId )
        #    {
        #        idx++;
        #        return true;
        #    }
        #
        #    idx = -1;
        #    return false;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Common value)
        #{
        #    this.init(value);
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    if( currentBuf.isTmp() )
        #    {
        #        idx = 0;
        #    }
        #    else
        #    {
        #        throw error(Error::missingOverride(funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    if( idx == 0 )
        #    {
        #        return strfmt('%1(before)', tableId2name(currentBuf.TableId));
        #    }
        #    else if( idx < 0 )
        #    {
        #        return strfmt('%1(end)', tableId2name(currentBuf.TableId));
        #    }
        #
        #    return RecordUtil::getInfo(currentBuf);
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordEnumerator construct(Common buf)
        #{
        #    return new RecordEnumerator(buf);
        #}
        #
      ENDSOURCE
      SOURCE #constructAndSkip
        #public static RecordEnumerator constructAndSkip(Common buf, int skipIterations)
        #{
        #    RecordEnumerator ret = RecordEnumerator::construct(buf);
        #
        #    if( ret && ret.skip(skipIterations) )
        #    {
        #        return ret;
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #constructIfType
        #public static RecordEnumerator constructIfType(Common buf, TableId tableOrMapId)
        #{
        #    RecordEnumerator ret;
        #
        #    if( RecordUtil::is(buf, tableOrMapId) )
        #    {
        #        ret = RecordEnumerator::construct(buf);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrSplitEnumerator unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrSplitEnumerator
    PROPERTIES
      Name                #StrSplitEnumerator
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// делит строку на подстроки, разделенные строкой delimiter
        #// Если maxSubstrings не ноль, то максимальная контейнера не будет превышать maxSubstrings.
        #// делает одну итерацию на всю исходную строку, если ни одного символа-разделителя не найдено.
        #//
        #// пример:
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=')   => ['ABC','DEF','GH']
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',2) => ['ABC','DEF:=GH']
        #//      StrSplitEnumerator::construct('ABC:=DEF:=GH',':=',1) => ['ABC:=DEF:=GH']
        #//
        #// @see StrUtil::split(), StrUtil::splitChar(), StrUtil::splitCon()
        #//
        #class StrSplitEnumerator implements Enumerator, EEnumerator
        #{
        #    str     string;
        #    int     stringLenPlus1;
        #    str     delimiterStr;
        #    int     delimiterLen;
        #    int     maxSubstrings;
        #
        #    int     currentIdx; // индекс текущего чанка (не более, чем maxSubstrings)
        #    int     currentPos; // начальная позиция текущего чанка
        #    int     currentLen; // длина текущего чанка
        #
        #    int     nextPos;
        #}
      ENDSOURCE
      SOURCE #current
        #public anytype current()
        #{
        #    // никаких проверок:
        #    // substr вернет что-нибудь, если параметры странные. скорее всего пустую строку.
        #    str ret = substr(string, currentPos, currentLen);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #currentIdx
        #public int currentIdx()
        #{
        #    return currentIdx;
        #}
      ENDSOURCE
      SOURCE #currentLen
        #public int currentLen()
        #{
        #    return currentLen;
        #}
      ENDSOURCE
      SOURCE #currentPos
        #public int currentPos()
        #{
        #    return currentPos;
        #}
      ENDSOURCE
      SOURCE #definitionString
        #public str definitionString()
        #{
        #    return 'Str split enumerator';
        #}
      ENDSOURCE
      SOURCE #init
        #// метод публичный, чтобы объект данного класса можно было создавать из classFactory и инициализировать из всевозможных unpack
        #// не вызывайте этот метод напрямую
        #public void init(str s, str _delimiter, int _maxSubstrings = 0)
        #{
        #    string = s;
        #    stringLenPlus1 = strlen(s) + 1;
        #    delimiterStr = _delimiter;
        #    delimiterLen = strlen(_delimiter);
        #    maxSubstrings = _maxSubstrings;
        #
        #    this.reset();
        #}
        #
      ENDSOURCE
      SOURCE #moveNext
        #// вычисляет параметры для метода current(): currentPos, currentLen и currentIdx
        #// currentIdx - сколько раз вызывался метод moveNext()
        #//
        #public boolean moveNext()
        #{
        #    int pos;
        #    ;
        #
        #    currentIdx++;
        #    currentPos = nextPos;
        #
        #    // ещё не знаем есть ли ещё разделител. поэтому пока считаем,
        #    // что следующая итерация будет последней, а current() пока должен вернуть пустую строку
        #    nextPos = stringLenPlus1 + 1;
        #    currentLen = 0;
        #
        #    // начнем проверки
        #    if( currentPos > stringLenPlus1 )
        #    {
        #        return false;
        #    }
        #
        #    if( delimiterLen <= 0  )
        #    {
        #        if( currentIdx <= 1 )
        #        {
        #            currentLen = stringLenPlus1; // current() должен вернуть все оставшееся в строке
        #            return true;
        #        }
        #
        #        return false;
        #    }
        #
        #    if( maxSubstrings )
        #    {
        #        if( currentIdx == maxSubstrings )
        #        {
        #            currentLen = stringLenPlus1 - currentPos; // current() должен вернуть все оставшееся в строке
        #            return true;
        #        }
        #        else if( currentIdx > maxSubstrings )
        #        {
        #            return false;
        #        }
        #    }
        #
        #    // где наш разделитель?
        #    pos = strscan(string, delimiterStr, currentPos, stringLenPlus1);
        #    if( pos == 0 )
        #    {
        #        currentLen = stringLenPlus1 - currentPos; // current() должен вернуть все оставшееся в строке
        #        return true;
        #    }
        #
        #    // вот наш разделитель!
        #    // установим правильную длину и правильную позицию для следующей итерации
        #    currentLen = pos - currentPos;
        #    nextPos = pos + delimiterLen;
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(str s, str delimiter, int _maxSubstrings = 0)
        #{
        #    this.init(s, delimiter, _maxSubstrings);
        #}
        #
      ENDSOURCE
      SOURCE #reset
        #// устанавливает индексы в начальное состояние
        #// никак не запоминает уже найденные позиции подстрок
        #public void reset()
        #{
        #    currentIdx = 0;
        #    currentPos = 0;
        #    currentLen = 0;
        #
        #    nextPos = 1;
        #}
      ENDSOURCE
      SOURCE #skip
        #public boolean skip(int skipIterations = 1)
        #{
        #    return EnumeratorUtil::skip(this, skipIterations);
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    // поскольку этот метод может вызваться в отладчике еще до инициализации,
        #    // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        #    // и ни в коем случае не бросаем исключение на неинициализированные значения
        #    str ret;
        #
        #    if( currentIdx )
        #    {
        #        if( currentPos <= stringLenPlus1 )
        #        {
        #            ret = strfmt('{%1}', this.current());
        #        }
        #        else
        #        {
        #            ret = '{after}';
        #        }
        #    }
        #    else
        #    {
        #        ret = '{before}';
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static server StrSplitEnumerator construct(str s, str delimiter, int maxSubstrings = 0)
        #{
        #    if( s )
        #    {
        #        return new StrSplitEnumerator(s, delimiter, maxSubstrings);
        #    }
        #
        #    return null;
        #}
        #
      ENDSOURCE
      SOURCE #description
        #public static ClassDescription description()
        #{
        #    return "An enumerator to traverse a splitted string chunks.";
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: StrSplitEnumeratorTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #StrSplitEnumeratorTest
    PROPERTIES
      Name                #StrSplitEnumeratorTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysUtil
        #//
        #class StrSplitEnumeratorTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testSplit
        #void testSplit()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=');
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(6, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(12, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_around
        #void testSplit_around()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct(':=ABC:=DEF?:=GH:=',':=');
        #
        #    this.assertNotNull(e);
        #
        #    this.info('[before]');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(0, e.currentLen());
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(3, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(8, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(4, e.currentIdx());
        #    this.assertEquals(14, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('Chunk last');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('', e.current());
        #    this.assertEquals(5, e.currentIdx());
        #    this.assertEquals(18, e.currentPos());
        #    this.assertEquals(0, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_Empty
        #void testSplit_Empty()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('',':=');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('',e.current());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyDelimiter
        #void testSplit_EmptyDelimiter()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH','');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF?:=GH', e.current());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyDelimiter_max4
        #void testSplit_EmptyDelimiter_max4()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH','',4);
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF?:=GH', e.current());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_EmptyEmptyDelimiter
        #void testSplit_EmptyEmptyDelimiter()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('','');
        #
        #    this.assertNotNull(e);
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('',e.current());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max0
        #void testSplit_max0()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=',0);
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(6, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(12, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max1
        #void testSplit_max1()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=',1);
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC:=DEF?:=GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC:=DEF?:=GH', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(13, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max2
        #void testSplit_max2()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=',2);
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?:=GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?:=GH', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(6, e.currentPos());
        #    this.assertEquals(8, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max3
        #void testSplit_max3()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=',3);
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(6, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(12, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_max4
        #void testSplit_max4()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC:=DEF?:=GH',':=',4);
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(6, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(12, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
      SOURCE #testSplit_OneChar
        #void testSplit_oneChar()
        #{
        #    StrSplitEnumerator e = StrSplitEnumerator::construct('ABC=DEF?=GH','=');
        #
        #    this.assertNotNull(e);
        #
        #    this.info('Chunk ABC');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('ABC', e.current());
        #    this.assertEquals(1, e.currentIdx());
        #    this.assertEquals(1, e.currentPos());
        #    this.assertEquals(3, e.currentLen());
        #
        #    this.info('Chunk DEF?');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('DEF?', e.current());
        #    this.assertEquals(2, e.currentIdx());
        #    this.assertEquals(5, e.currentPos());
        #    this.assertEquals(4, e.currentLen());
        #
        #    this.info('Chunk GH');
        #
        #    this.assertTrue(e.moveNext());
        #    this.assertEquals('GH', e.current());
        #    this.assertEquals(3, e.currentIdx());
        #    this.assertEquals(10, e.currentPos());
        #    this.assertEquals(2, e.currentLen());
        #
        #    this.info('[after]');
        #
        #    this.assertFalse(e.moveNext());
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictClass unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictClass
    PROPERTIES
      Name                #SysDictClass
      Extends             #DictClass
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #as
        #static public Object as(Object _class, classId _classId)
        #{
        #    if (_class && SysDictClass::is(_class, _classId))
        #        return _class;
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static SysDictClass construct(ClassId classId)
        #{
        #    return new SysDictClass(classId);
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Object _class, classId _classId)
        #{
        #    boolean ret = false;
        #
        #    if( _classId )
        #    {
        #        ret = SysDictClass::isEqualOrSuperclass(classidget(_class), _classId);
        #
        #        if( !ret )
        #        {
        #            ret = new SysDictClass(classidget(_class)).isImplementing(_classId);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictEnum unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictEnum
    PROPERTIES
      Name                #SysDictEnum
      Extends             #DictEnum
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #label2value
        #//mazzy 08.12.2020
        #//Eshp CL005594 2019/09/25
        #public int label2value(
        #    str         _labelStr,
        #    LanguageId  _languageId = CompanyInfo::languageId())
        #{
        #    int ret = this.label2valueNoThrow(_labelStr, _languageId);
        #    ;
        #
        #    if (ret < 0)
        #    {
        #        throw error(strfmt(@'Не удалось преобразовать текст "%1" в элемент Enum "%2" (%3).',
        #            _labelStr, this.label(), this.name()));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #label2valueNoThrow
        #//mazzy 08.12.2020
        #//Eshp CL005594 2019/09/25
        #public int label2valueNoThrow(
        #    str         _labelStr,
        #    LanguageId  _languageId     = CompanyInfo::languageId())
        #{
        #    Label   label   = new Label(_languageId);
        #    int     idx;
        #    int     value;
        #    str     labelValue;
        #    int     ret     = -1;
        #    ;
        #
        #    for (idx = 0; idx < this.values(); idx++)
        #    {
        #        value = this.index2Value(idx);
        #        if (int2str(value) == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #
        #        labelValue = label.extractString(this.index2LabelId(idx));
        #        if (labelValue == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #
        #        if (this.index2Symbol(idx) == _labelStr)
        #        {
        #            ret = value;
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #newFromEnum
        #public static SysDictEnum newFromEnum(anytype enum)
        #{
        #    enumId          enumId          = DictEnum::value2id(enum);
        #    SysDictEnum     sysDictEnum     = new SysDictEnum(enumId);
        #
        #    return sysDictEnum;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysDictTable unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysDictTable
    PROPERTIES
      Name                #SysDictTable
      Extends             #DictTable
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #fieldsWithEDT
        #// 04.02.2021, mazzy, основано на методе this.fields()
        #public Set fieldsWithEDT(ExtendedTypeId edt)
        #{
        #    int cnt;
        #    int i;
        #    int j;
        #    tableId tableId = this.id();
        #    SysDictField sysDictField;
        #    SysDictField sysDictFieldArray;
        #    Set set = new Set(Types::Class);
        #
        #    if (!edt)
        #    {
        #        return set;
        #    }
        #
        #    //
        #    // Include fields
        #    //
        #    cnt = this.fieldCnt();
        #    for (i=1; i<=cnt; i++)
        #    {
        #        sysDictField = new SysDictField(tableId, this.fieldCnt2Id(i));
        #
        #        //
        #        // Skip fields not stored in the database
        #        // This is typical system fields, like ModifiedBy, CreatedBy, etc.
        #        //
        #        if (sysDictField && sysDictField.saveContents() && SysDictType::isEqualOrExtending(sysDictField.extendedTypeId(), edt))
        #        {
        #            for (j=1; j<=sysDictField.arraySize(); j++)
        #            {
        #                sysDictFieldArray = new SysDictField(tableId, this.fieldCnt2Id(i), j);
        #                set.add(sysDictFieldArray);
        #            }
        #        }
        #    }
        #    return set;
        #}
      ENDSOURCE
      SOURCE #fieldsWithEnum
        #// 04.02.2021, mazzy, основано на методе this.fields()
        #public Set fieldsWithEnum(EnumId enumId)
        #{
        #    int cnt;
        #    int i;
        #    int j;
        #    tableId tableId = this.id();
        #    SysDictField sysDictField;
        #    SysDictField sysDictFieldArray;
        #    Set set = new Set(Types::Class);
        #
        #    if (!enumId)
        #    {
        #        return set;
        #    }
        #
        #    //
        #    // Include fields
        #    //
        #    cnt = this.fieldCnt();
        #    for (i=1; i<=cnt; i++)
        #    {
        #        sysDictField = new SysDictField(tableId, this.fieldCnt2Id(i));
        #
        #        //
        #        // Skip fields not stored in the database
        #        // This is typical system fields, like ModifiedBy, CreatedBy, etc.
        #        //
        #        if (sysDictField && sysDictField.saveContents() && sysDictField.enumId() == enumId)
        #        {
        #            for (j=1; j<=sysDictField.arraySize(); j++)
        #            {
        #                sysDictFieldArray = new SysDictField(tableId, this.fieldCnt2Id(i), j);
        #                set.add(sysDictFieldArray);
        #            }
        #        }
        #    }
        #    return set;
        #}
      ENDSOURCE
      SOURCE #sysDictFieldGroup
        #// ava 31/08/2015 TSM02096
        #SysDictFieldGroup sysDictFieldGroup(str _fieldGroupName)
        #{
        #    int i;
        #    ;
        #
        #    for(i = 1; i <= this.fieldGroupCnt(); i++)
        #        if( this.fieldGroup(i) == _fieldGroupName )
        #            return new SysDictFieldGroup(this.id(), _fieldGroupName);
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #toString
        #public str toString()
        #{
        #    return strFmt('%1 [%2]', this.name(), this.id());
        #}
      ENDSOURCE
      SOURCE #as
        #public static Common as(Common rec, TableId tableOrMapId)
        #{
        #    if( SysDictTable::is(rec, tableOrMapId) )
        #        return rec;
        #
        #    return RecordUtil::commonRecord();
        #}
      ENDSOURCE
      SOURCE #construct
        #//TSUM001815 DYask 26.02.2018
        #public static SysDictTable construct(tableId _tableId)
        #{
        #    SysDictTable sysDictTable = new SysDictTable(_tableId);
        #
        #    return sysDictTable;
        #}
        #
      ENDSOURCE
      SOURCE #fieldEnumerator
        #//mazzy 30.01.2020
        #public static SetEnumerator fieldEnumerator(tableId tableId)
        #{
        #    SysDictTable    dt      = new SysDictTable(tableId);
        #    SetEnumerator   fe      = dt ? dt.fields().getEnumerator() : null;
        #
        #    return fe;
        #}
      ENDSOURCE
      SOURCE #fieldIdWithEDT
        #// находит id n-ого поля с указанным типом
        #// порядок полей может не совпадать с объявленным в AOT
        #public static FieldId fieldIdWithEDT(TableId tableId, ExtendedTypeId edt, int occurrence = 1)
        #{
        #    SysDictField df = SysDictTable::fieldWithEDT(tableId, edt, occurrence);
        #
        #    if( df )
        #    {
        #        return df.id();
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #fieldIdWithEnum
        #// находит id n-ого поля с указанным enum
        #// порядок полей может не совпадать с объявленным в AOT
        #public static FieldId fieldIdWithEnum(TableId tableId, EnumId enumId, int occurrence = 1)
        #{
        #    SysDictField df = SysDictTable::fieldWithEnum(tableId, enumId, occurrence);
        #
        #    if( df )
        #    {
        #        return df.id();
        #    }
        #
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #fieldNames
        #// mazzy 30.01.2020
        #// Внимание! наименования полей могут совпадать, поэтому set названий полей может быть меньше, чем полей в таблице
        #// используйте с осторожностью
        #public static Set fieldNames(tableId tableId, boolean includeSystem = false)
        #{
        #    Set             set     = new Set(Types::String);
        #    SetEnumerator   fe      = SysDictTable::fieldEnumerator(tableId);
        #    SysDictField    df;
        #;
        #    while( fe && fe.moveNext() )
        #    {
        #        df = fe.current();
        #
        #        if( df && (includeSystem || !df.isSystem()) )
        #        {
        #            set.add(df.name());
        #        }
        #    }
        #
        #    return set;
        #}
      ENDSOURCE
      SOURCE #fieldWithEDT
        #// находит n-ое поле с указанным типом
        #// порядок полей может не совпадать с объявленным в AOT
        #// используйте SysDictTable.fieldsWithEDT, чтобы найти все поля
        #public static SysDictField fieldWithEDT(TableId tableId, ExtendedTypeId edt, int occurrence = 1)
        #{
        #    SysDictTable    dt       = new SysDictTable(tableId);
        #    Set             fields   = dt ? dt.fieldsWithEDT(edt) : null;
        #    SetEnumerator   se       = fields ? fields.getEnumerator() : null;
        #    SysDictField    df;
        #
        #    while( se && se.moveNext() && occurrence > 0 )
        #    {
        #        df = se.current();
        #        occurrence--;
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #fieldWithEnum
        #// находит n-ое поле с указанным enum
        #// порядок полей может не совпадать с объявленным в AOT
        #// используйте SysDictTable.fieldsWithEDT, чтобы найти все поля
        #public static SysDictField fieldWithEnum(TableId tableId, EnumId enumId, int occurrence = 1)
        #{
        #    SysDictTable    dt       = tableId  ? new SysDictTable(tableId) : null;
        #    Set             fields   = dt       ? dt.fieldsWithEnum(enumId) : null;
        #    SetEnumerator   se       = fields   ? fields.getEnumerator() : null;
        #    SysDictField    df;
        #
        #    while( se && se.moveNext() && occurrence > 0 )
        #    {
        #        df = se.current();
        #        occurrence--;
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #formRefName
        #// mazzy 10.03.2021
        #public static MenuItemName formRefName(TableId tableId)
        #{
        #    DictTable dt = new DictTable(tableId);
        #
        #    if( dt )
        #    {
        #        return dt.formRef();
        #    }
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #getMandatoryFields
        #// mazzy, 07.04.2020
        #static client server List getMandatoryFields(tableId _tableId)
        #{
        #    List                    fieldIdList  = new List(Types::Integer);
        #    SysDictTable            sysDictTable = new SysDictTable(_tableId);
        #    SysDictField            sysDictField;
        #    int                     i;
        #    ;
        #
        #    for (i=1;i<=sysDictTable.fieldCnt();i++)
        #    {
        #        sysDictField = new SysDictField(_tableId, sysDictTable.fieldCnt2Id(i));
        #        if( sysDictField && sysDictField.saveContents() && sysDictField.mandatory() )
        #        {
        #            fieldIdList.addEnd(sysDictField.id());
        #        }
        #    }
        #
        #    return fieldIdList;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Common rec, TableId tableOrMapId)
        #{
        #    if( rec.TableId == tableOrMapId )
        #        return true;
        #
        #    if( tableOrMapId && SysDictTable::isTableMapped(tableOrMapId, rec.TableId) )
        #        return true;
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isTableMapped
        #static boolean isTableMapped(tableId _mapTableId, tableId _tableIdToTest)
        #{
        #    #AOT
        #    TreeNode treeNode = TreeNode::findNode(#TableMapsPath+'\\'+tableid2name(_mapTableId)+'\\mappings');
        #
        #    if( treeNode )
        #        return treeNode.AOTfindChild(tableid2name(_tableIdToTest)) != null;
        #
        #    return false;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ClassUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ClassUtil
    PROPERTIES
      Name                #ClassUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом ClassId
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ObjectUtil
        #// @see DictClassUtil
        #//
        #abstract class ClassUtil
        #{
        #}
      ENDSOURCE
      SOURCE #containsGetEnumeratorMethod
        #// TODO перенести в отдельый класс?
        #// для утиной типизации: есть метод getEnumerator,
        #// у которого нет параметров и который возвращает объект с типом Enumerator
        #private static boolean containsGetEnumeratorMethod(ClassId classId)
        #{
        #    boolean ret;
        #    SysDictMethod sdm;
        #
        #    if( classId )
        #    {
        #        sdm = new SysDictMethod(UtilElementType::ClassInstanceMethod, classId, methodstr(Enumerable, getEnumerator));
        #
        #        if( sdm &&
        #            sdm.parameterCnt() == 0 &&
        #            sdm.returnType() == Types::Class &&
        #            ClassUtil::isImplement(sdm.returnId(), classnum(Enumerator)) )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #dictClass_NonNull
        #// используйте <c>new DictClass(classId)<c> чтобы создать объект DictClass без проверки на null
        #//
        #public static DictClass dictClass_NonNull(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    ;
        #
        #    dc = DictClassUtil::nonNull(dc);
        #
        #    return dc;
        #}
      ENDSOURCE
      SOURCE #enumerableClasses
        #public static container enumerableClasses()
        #{
        #    return [
        #        classnum(List),
        #        classnum(Map),
        #        classnum(Set),
        #        // classnum(Array), // нет метода getEnumerator. класс должен обрабатываться отдельно.
        #        classnum(Enumerable)
        #    ];
        #}
      ENDSOURCE
      SOURCE #extendedBy
        #public static List extendedBy(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    List list;
        #
        #    if( dc )
        #    {
        #        list = dc.extendedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #implementedBy
        #// @warning медленный метод. перебирает все классы в AOT
        #public static List implementedBy(ClassId classId)
        #{
        #    SysDictClass dc = new SysDictClass(classId);
        #    List list;
        #
        #    if( dc )
        #    {
        #        list = dc.implementedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(ClassId classId, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    DictClass dictClass;
        #    int       n;
        #    ;
        #
        #    while( classId && potentialClassAncestorOrInterfaceId )
        #    {
        #        if( classId == potentialClassAncestorOrInterfaceId )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( n = dictClass.implementsCnt(); n > 0; --n )
        #            {
        #                if( dictClass.implements(n) == potentialClassAncestorOrInterfaceId )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isArray
        #public static boolean isArray(ClassId classId)
        #{
        #    boolean ret = ClassUtil::is(classId, classnum(Array));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEEnumerator
        #// возвращает true для объекта, класс которого реализует EEnumerator
        #public static boolean isEEnumerator(ClassId classId)
        #{
        #    boolean ret = ClassUtil::isImplement(classId, classnum(EEnumerator));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для класса, для которого можно получить enumerator
        #public static boolean isEnumerable(ClassId classId)
        #{
        #    boolean ret;
        #
        #    if( classId )
        #    {
        #        if( ClassUtil::isOneOf(classId, ClassUtil::enumerableClasses()) )
        #        {
        #            ret = true;
        #        }
        #        else if( ClassUtil::containsGetEnumeratorMethod(classId) )
        #        {
        #            ret = true;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для объекта, класс которого реализует enumerator
        #public static boolean isEnumerator(ClassId classId)
        #{
        #    boolean ret = ClassUtil::isImplement(classId, classnum(Enumerator));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends, без implements
        #public static boolean isExtend(ClassId classId, ClassId potentialClassAncestorId)
        #{
        #    DictClass dictClass;
        #
        #    while( classId && potentialClassAncestorId )
        #    {
        #        if( classId == potentialClassAncestorId )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(ClassId classId, ClassId interfaceId)
        #{
        #    DictClass dictClass;
        #    int       n;
        #
        #    while( classId && interfaceId )
        #    {
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( n = dictClass.implementsCnt(); n > 0; --n )
        #            {
        #                if( dictClass.implements(n) == interfaceId )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isList
        #public static boolean isList(ClassId classId)
        #{
        #    boolean ret = ClassUtil::is(classId, classnum(List));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMap
        #public static boolean isMap(ClassId classId)
        #{
        #    boolean ret = ClassUtil::is(classId, classnum(Map));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(ClassId classId)
        #{
        #    boolean ret = (classId == 0 || classId == ClassUtil::objectClassId());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(ClassId classId, anytype potentialAncestorIds)
        #{
        #    Set         set = SetUtil::newFrom(potentialAncestorIds);
        #    DictClass   dictClass;
        #    int         i;
        #
        #    while( classId && set )
        #    {
        #        if( set.in(classId) )
        #        {
        #            return true;
        #        }
        #
        #        dictClass = new DictClass(classId);
        #
        #        if( dictClass )
        #        {
        #            for( i = dictClass.implementsCnt(); i > 0; --i )
        #            {
        #                if( set.in(dictClass.implements(i)) )
        #                {
        #                    return true;
        #                }
        #            }
        #
        #            classId = dictClass.extend();
        #        }
        #        else
        #        {
        #            classId = 0;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isSet
        #public static boolean isSet(ClassId classId)
        #{
        #    boolean ret = ClassUtil::is(classId, classnum(Set));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(ClassId classId)
        #{
        #    boolean ret = (classId != 0 && classId != ClassUtil::objectClassId());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStack
        #public static boolean isStack(ClassId classId)
        #{
        #    boolean ret = AnytypeUtil::isClass(classId, classnum(StackBase));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStruct
        #public static boolean isStruct(ClassId classId)
        #{
        #    boolean ret = ClassUtil::is(classId, classnum(Struct));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #name2id
        #public static ClassId name2id(ClassName className)
        #{
        #    Dictionary dict = new Dictionary();
        #    ClassId classId;
        #
        #    if( dict )
        #    {
        #        classId = dict.className2Id(className);
        #    }
        #
        #    return classId;
        #}
      ENDSOURCE
      SOURCE #objectClassId
        #// возвращает код класса Object
        #public static ClassId objectClassId()
        #{
        #    // Object obj;
        #    //
        #    // return claggidget(obj);
        #
        #    return classnum(Object);
        #
        #    //return 65535;
        #}
      ENDSOURCE
      SOURCE #path
        #static TreeNodePath path(ClassId classId)
        #{
        #    DictClass dc = new DictClass(classId);
        #    TreeNodePath ret = DictClassUtil::path(dc);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(ClassId classId)
        #{
        #    DictClass       dc  = new DictClass(classId);
        #    ListEnumerator  le  = DictClassUtil::subClassListEnumerator(dc);
        #
        #    return le;
        #}
      ENDSOURCE
      SOURCE #sysDictClass_NonNull
        #public static SysDictClass sysDictClass_NonNull(ClassId classId)
        #{
        #    SysDictClass dc = new SysDictClass(classId);
        #
        #    if( dc )
        #    {
        #        dc = new SysDictClass(classnum(Object));
        #    }
        #
        #    return dc;
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #private static void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
      SOURCE #treeNode
        #// возвращает null, если класс не найден
        #public static TreeNode treeNode(ClassId classId)
        #{
        #    TreeNodePath path = ClassUtil::path(classId);
        #    TreeNode treeNode;
        #
        #    if( path )
        #    {
        #        treeNode = TreeNode::findNode(path);
        #    }
        #
        #    return treeNode;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictClassUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictClassUtil
    PROPERTIES
      Name                #DictClassUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictClass
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ClassIdUtil
        #// @see ObjectUtil
        #//
        #abstract class DictClassUtil
        #{
        #}
      ENDSOURCE
      SOURCE #extendedBy
        #public static List extendedBy(DictClass dictClass)
        #{
        #    List list;
        #
        #    if( dictClass )
        #    {
        #        list = dictClass.extendedBy();
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #implementedBy
        #// @warning медленный метод. перебирает все классы в AOT
        #public static List implementedBy(DictClass dictClass)
        #{
        #    List list;
        #
        #    if( dictClass )
        #    {
        #        list = ClassUtil::implementedBy(dictClass.id());
        #    }
        #
        #    return List;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(DictClass dictClass, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::is(dictClass.id(), potentialClassAncestorOrInterfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isArray
        #public static boolean isArray(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isArray(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEEnumerator
        #public static boolean isEEnumerator(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isEEnumerator(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для класса, для которого можно получить enumerator
        #public static boolean isEnumerable(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isEnumerable(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для объекта, класс которого реализует enumerator
        #public static boolean isEnumerator(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isEnumerator(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends
        #public static boolean isExtend(DictClass dictClass, ClassId potentialClassAncestorId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isExtend(dictClass.id(), potentialClassAncestorId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(DictClass dictClass, ClassId interfaceId)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isImplement(dictClass.id(), interfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isList
        #public static boolean isList(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isList(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMap
        #public static boolean isMap(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isMap(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(DictClass dictClass)
        #{
        #    boolean ret = true;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isNotSpecified(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(DictClass dictClass, anytype potentialAncestorIds)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isOneOf(dictClass.id(), potentialAncestorIds);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSet
        #public static boolean isSet(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isSet(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isSpecified(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStack
        #public static boolean isStack(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isStack(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStruct
        #public static boolean isStruct(DictClass dictClass)
        #{
        #    boolean ret;
        #
        #    if( dictClass )
        #    {
        #        ret = ClassUtil::isStruct(dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictClass nonNull(DictClass dictClass)
        #{
        #    if( !dictClass )
        #    {
        #        dictClass = new DictClass(classnum(Object));
        #    }
        #
        #    return dictClass;
        #}
      ENDSOURCE
      SOURCE #path
        #// взято из SysDictClass.path
        #public static TreeNodePath path(DictClass dictClass)
        #{
        #    TreeNodePath ret;
        #
        #    if( dictClass )
        #    {
        #        ret = xRefNames::calcPath(xRefKind::Class,dictClass.name(),'',dictClass.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(DictClass dictClass)
        #{
        #    List list = DictClassUtil::extendedBy(dictClass);
        #
        #    return ListUtil::getEnumerator(list);
        #}
      ENDSOURCE
      SOURCE #treeNode
        #// возвращает null, если класс не найден
        #public static TreeNode treeNode(DictClass dictClass)
        #{
        #    TreeNodePath path = DictClassUtil::path(dictClass);
        #    TreeNode treeNode = TreeNode::findNode(path);
        #
        #    return treeNode;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ObjectUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ObjectUtil
    PROPERTIES
      Name                #ObjectUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом Object (в том числе и с типом DictClass)
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see ClassIdUtil
        #// @see DictClassUtil
        #//
        #abstract class ObjectUtil
        #{
        #}
      ENDSOURCE
      SOURCE #TODO_duckTyping
        #void TODO_duckTyping()
        #{
        #}
      ENDSOURCE
      SOURCE #as
        #static public Object as(Object obj, classId potentialClassAncestorOrInterfaceId)
        #{
        #    Object ret;
        #
        #    if (potentialClassAncestorOrInterfaceId && ObjectUtil::is(obj, potentialClassAncestorOrInterfaceId))
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asArray
        #static public Array asArray(Object obj)
        #{
        #    Array ret;
        #
        #    if( ObjectUtil::isArray(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asArrayWithType
        #static public Array asArrayWithType(Object obj, Types elementType)
        #{
        #    Array ret;
        #
        #    if( ObjectUtil::isArrayWithType(obj, elementType) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEEnumerator
        #static public EEnumerator asEEnumerator(Object obj)
        #{
        #    EEnumerator ret;
        #
        #    if( ObjectUtil::isEEnumerator(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEnumerable
        #static public Enumerable asEnumerable(Object obj)
        #{
        #    Object ret;
        #
        #    if( ObjectUtil::isEnumerable(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asEnumerator
        #static public Enumerator asEnumerator(Object obj)
        #{
        #    Enumerator ret;
        #
        #    if( ObjectUtil::isEnumerator(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asList
        #static public List asList(Object obj)
        #{
        #    List ret;
        #
        #    if( ObjectUtil::isList(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asListWithType
        #static public List asListWithType(Object obj, Types elementType)
        #{
        #    List ret;
        #
        #    if( ObjectUtil::isListWithType(obj, elementType) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asMap
        #static public Map asMap(Object obj)
        #{
        #    Map ret;
        #
        #    if( ObjectUtil::isMap(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asMapWithType
        #static public Map asMapWithType(Object obj, Types keyType, Types valueType)
        #{
        #    Map ret;
        #
        #    if( ObjectUtil::isMapWithType(obj, keyType, valueType) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asOneOf
        #static public Object asOneOf(Object obj, anytype potentialAncestorIds)
        #{
        #    if (ObjectUtil::isOneOf(obj, potentialAncestorIds))
        #    {
        #        return obj;
        #    }
        #
        #    return null;
        #}
      ENDSOURCE
      SOURCE #assertObjectOnClient
        #public static void assertObjectOnClient(Object obj)
        #{
        #    if( obj && xGlobal::objectOnServer(obj) )
        #    {
        #        throw error(Error::wrongUseOfFunction(funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #assertObjectOnServer
        #public static void assertObjectOnServer(Object obj)
        #{
        #    if( obj && !xGlobal::objectOnServer(obj) )
        #    {
        #        throw error(Error::wrongUseOfFunction(funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #asSet
        #static public Set asSet(Object obj)
        #{
        #    Set ret;
        #
        #    if( ObjectUtil::isSet(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asSetWithType
        #static public Set asSetWithType(Object obj, Types elementType)
        #{
        #    Set ret;
        #
        #    if( ObjectUtil::isSetWithType(obj, elementType) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #asStruct
        #static public Struct asStruct(Object obj)
        #{
        #    Struct ret;
        #
        #    if( ObjectUtil::isStruct(obj) )
        #    {
        #        ret = obj;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureNonNull
        #public static Object ensureNonNull(Object obj, str _funcname = funcname(), anytype _varNameOrText = '')
        #{
        #    if( obj )
        #    {
        #        return obj;
        #    }
        #
        #    throw error(Error::unsupportedNull(_funcname, _varNameOrText));
        #}
      ENDSOURCE
      SOURCE #ensureObjectOnClient
        #public static Object ensureObjectOnClient(Object obj)
        #{
        #    ;
        #
        #    ObjectUtil::assertObjectOnClient(obj);
        #
        #    return obj;
        #}
      ENDSOURCE
      SOURCE #ensureObjectOnServer
        #public static Object ensureObjectOnServer(Object obj)
        #{
        #    ;
        #
        #    ObjectUtil::assertObjectOnServer(obj);
        #
        #    return obj;
        #}
      ENDSOURCE
      SOURCE #getEEnumerator
        #// возвращает @nonNull объект, у которого можно вызвать метод moveNext или Null
        #// если в качестве аргумента передана не коллекция, то возвращает энумератор по коллекции из одного элемента
        #// поэтому результат этого метода всегда можно энумерировать
        #//
        #// используйте CollectionUtil::getEnumerator()
        #// если хотите получить энумератор только для коллекции, но не по элементу
        #public static EEnumerator getEEnumerator(Object collection)
        #{
        #    Enumerator ret;
        #    ClassId    classId;
        #
        #    if( collection )
        #    {
        #        classId = classidget(collection);
        #
        #        if( ClassUtil::isEEnumerator(classId) )
        #        {
        #            ret = collection;
        #        }
        #
        #        // well known collections
        #
        #        else if( ClassUtil::isSet(classId)  )
        #        {
        #            ret = SetEEnumerator::construct(collection);
        #        }
        #        else if( ClassUtil::isMap(classId)  )
        #        {
        #            ret = MapEEnumerator::construct(collection);
        #        }
        #        else if( ClassUtil::isList(classId)  )
        #        {
        #            ret = ListEEnumerator::construct(collection);
        #        }
        #        else if( ClassUtil::isArray(classId)  )
        #        {
        #            ret = new ArrayEnumerator(collection);
        #        }
        #
        #        // TODO добавить распознавание объектов, для которых есть реализация SysEnumerable
        #        // else if( ClassUtil::isSysEnumerable(classId) )
        #        // {
        #        // }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getEnumerator
        #// возвращает @nonNull объект, который реализует интерфейс EEnumerator
        #// если в качестве аргумента передана не коллекция, то возвращает энумератор по коллекции из одного элемента
        #// поэтому результат этого метода всегда можно энумерировать
        #//
        #// используйте CollectionUtil::CopyOfgetEnumerator()
        #// если хотите получить энумератор только для коллекции, но не по элементу
        #public static Enumerator getEnumerator(Object collection)
        #{
        #    Enumerator ret;
        #    ClassId    classId;
        #
        #    if( collection )
        #    {
        #        classId = classidget(collection);
        #
        #        if( ClassUtil::isEEnumerator(classId) )
        #        {
        #            ret = collection;
        #        }
        #        else if( classId == classnum(Array) )
        #        {
        #            ret = new ArrayEnumerator(collection);
        #        }
        #        else if( ClassUtil::isEnumerable(classId) )
        #        {
        #            ret = collection.getEnumerator();
        #            // проверки на пустое значение и isEnumerable выше гарантируют,
        #            // что метод getEnumerator существует и определен правильно
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #is
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean is(Object obj, ClassId potentialClassAncestorOrInterfaceId)
        #{
        #    ClassId classId;
        #    boolean ret;
        #
        #    if( potentialClassAncestorOrInterfaceId )
        #    {
        #        classId = classidget(obj);
        #        ret = ClassUtil::is(classId, potentialClassAncestorOrInterfaceId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isArray
        #public static boolean isArray(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isArray(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isArrayWithType
        #public static boolean isArrayWithType(Object obj, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( obj && ObjectUtil::isArray(obj) )
        #    {
        #        ret = ArrayUtil::isType(obj, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEEnumerator
        #// возвращает true для объекта, класс которого реализует EEnumerator
        #public static boolean isEEnumerator(Object obj)
        #{
        #    boolean ret;
        #
        #    if( obj )
        #    {
        #        ret = ClassUtil::isEEnumerator(classidget(obj));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerable
        #// возвращает true для объекта, для которого можно получить enumerator
        #public static boolean isEnumerable(Object obj)
        #{
        #    boolean ret;
        #
        #    if( obj )
        #    {
        #        ret = ClassUtil::isEnumerable(classidget(obj));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEnumerator
        #// возвращает true для объекта, класс которого реализует enumerator
        #public static boolean isEnumerator(Object obj)
        #{
        #    boolean ret;
        #
        #    if( obj )
        #    {
        #        ret = ClassUtil::isEnumerator(classidget(obj));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEqual
        #public static boolean isEqual(Object obj1, Object obj2)
        #{
        #    if( obj1 && obj2 )
        #    {
        #        return obj1.equal(obj2);
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isExtend
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #//
        #// только extends
        #public static boolean isExtend(Object obj, ClassId potentialClassAncestorId)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isExtend(classId, potentialClassAncestorId);
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isImplement
        #// отличается от SysDictClass:
        #// 1. итерация, а не рекурсия.
        #// 2. один проход вместо двух отдельных для extends и implements
        #// 3. минимальное число создаваемых в памяти объектов
        #public static boolean isImplement(Object obj, ClassId interfaceId)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isImplement(classId, interfaceId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isList
        #public static boolean isList(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isList(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isListWithType
        #public static boolean isListWithType(Object obj, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( obj && ObjectUtil::isList(obj) )
        #    {
        #        ret = ListUtil::isType(obj, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMap
        #public static boolean isMap(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isMap(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMapWithType
        #public static boolean isMapWithType(Object obj, Types keyType, Types valueType)
        #{
        #    boolean ret;
        #
        #    if( obj && ObjectUtil::isList(obj) )
        #    {
        #        ret = MapUtil::isType(obj, keyType, valueType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isObjectOnClient
        #// для null всегда будет false
        #public static boolean isObjectOnClient(Object obj)
        #{
        #    boolean ret;
        #
        #    if( obj )
        #    {
        #        ret = !xGlobal::objectOnServer(obj);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isObjectOnServer
        #// для null всегда будет false
        #public static boolean isObjectOnServer(Object obj)
        #{
        #    boolean ret;
        #
        #    if( obj )
        #    {
        #        ret = xGlobal::objectOnServer(obj);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isOneOf
        #public static boolean isOneOf(Object obj, anytype potentialAncestorIds)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isOneOf(classId, potentialAncestorIds);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSet
        #public static boolean isSet(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isSet(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSetWithType
        #public static boolean isSetWithType(Object obj, Types elementType)
        #{
        #    boolean ret;
        #
        #    if( obj && ObjectUtil::isSet(obj) )
        #    {
        #        ret = SetUtil::isType(obj, elementType);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStack
        #public static boolean isStack(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isStack(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isStruct
        #public static boolean isStruct(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    boolean ret = ClassUtil::isStruct(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #subClassListEnumerator
        #public static ListEnumerator subClassListEnumerator(Object obj)
        #{
        #    ClassId classId = classidget(obj);
        #    ListEnumerator ret = ClassUtil::subClassListEnumerator(classId);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: TableUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #TableUtil
    PROPERTIES
      Name                #TableUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом TableId
        #
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see DictTableUtil
        #//
        #abstract class TableUtil
        #{
        #}
      ENDSOURCE
      SOURCE #commonTableId
        #public static TableId commonTableId()
        #{
        #    // Common rec;
        #    //
        #    // return rec.TableId;
        #
        #    return tablenum(Common);
        #
        #    // return 65535;
        #}
      ENDSOURCE
      SOURCE #dictTable_NonNull
        #// используйте new DictTable чтобы создать объект без проверки на null
        #public static DictTable dictTable_NonNull(TableId tableId)
        #{
        #    DictTable dt = new DictTable(tableId);
        #    ;
        #    dt = DictTableUtil::nonNull(dt);
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(TableId tableId, TableId tableOrMapId)
        #{
        #    if( tableId == tableOrMapId )
        #        return true;
        #
        #    if( tableOrMapId && TableUtil::isMapped(tableId, tableOrMapId) )
        #        return true;
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(TableId tableId)
        #{
        #    boolean ret = (tableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isMapped
        #static boolean isMapped(TableId tableId, TableId potentialMapId)
        #{
        #    #AOT
        #
        #    TableName   mapName;
        #    TreeNode    treeNode;
        #    TableName   tableName;
        #    boolean     ret;
        #
        #    if( tableId )
        #    {
        #        if( TableUtil::isCommon(potentialMapId) )
        #        {
        #            ret = true;
        #        }
        #        else
        #        {
        #            tableName = tableid2name(tableId);
        #            mapName = tableid2name(potentialMapId);
        #
        #            if( tableName && mapName )
        #            {
        #                treeNode = TreeNode::findNode(#TableMapsPath+'\\'+mapName+'\\mappings');
        #                ret = treeNode ? (treeNode.AOTfindChild(tableName) != null) : false;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(TableId tableId)
        #{
        #    boolean ret = (tableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(TableId tableId)
        #{
        #    boolean ret = (tableId == 0 || tableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(TableId tableId)
        #{
        #    boolean ret = (tableId && tableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(TableId tableId = 0)
        #{
        #    Common record;
        #    DictTable dt;
        #
        #    if( tableId )
        #    {
        #        dt = new DictTable(tableId);
        #        if( dt )
        #        {
        #            record = dt.makeRecord();
        #        }
        #    }
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #makeRecordTmp
        #public static Common makeRecordTmp(TableId tableId = 0)
        #{
        #    Common record = TableUtil::makeRecord(tableId);
        #    ;
        #
        #    record.setTmp();
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #select
        #// выбирает из указанной таблицы запись, в которой указанное поле равно указанному значению
        #// перебрать все записи можно оператором next
        #//
        #// @see SysQuery::query(), RecordUtil::select()
        #public static Common select(TableId tableId, FieldId fieldId, anytype value, boolean _forupdate = false)
        #{
        #    Common ret = TableUtil::makeRecord(tableId);
        #    ;
        #
        #    if( RecordUtil::isSpecified(ret) &&
        #        FieldUtil::is(tableId, fieldId, typeof(value)) )
        #    {
        #        ret.selectForUpdate(_forupdate);
        #
        #        select ret
        #        where ret.(fieldId) == value;
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #selectFirstOnly
        #// выбирает из указанной таблицы первую запись, в которой указанное поле равно указанному значению
        #public static Common selectFirstOnly(TableId tableId, FieldId fieldId, anytype value, boolean _forupdate = false)
        #{
        #    Common ret = TableUtil::makeRecord(tableId);
        #    ;
        #
        #    if( RecordUtil::isSpecified(ret) &&
        #        FieldUtil::is(tableId, fieldId, typeof(value)) )
        #    {
        #        ret.selectForUpdate(_forupdate);
        #
        #        select firstOnly ret
        #        where ret.(fieldId) == value;
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #selectRecId
        #// выбирает из указанной таблицы первую запись, в которой RecId равено указанному значению
        #public static Common selectRecId(TableId tableId, RefRecId recId, boolean _forupdate = false)
        #{
        #    Common ret = TableUtil::makeRecord(tableId);
        #    ;
        #
        #    ret.selectForUpdate(_forupdate);
        #
        #    select firstOnly ret
        #    where ret.RecId == recId;
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #sysDictTable_NonNull
        #// используйте new SysDictTable чтобы создать объект без проверки на Null
        #public static SysDictTable sysDictTable_NonNull(TableId tableId)
        #{
        #    SysDictTable dt = new SysDictTable(tableId);
        #    ;
        #
        #    if( !dt )
        #    {
        #        dt = new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #sysNonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictTable sysNonNull(SysDictTable dt)
        #{
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictTableUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictTableUtil
    PROPERTIES
      Name                #DictTableUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictTable
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see TableIdUtil
        #//
        #abstract class DictTableUtil
        #{
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() == tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() != tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() == 0 || dt.id() == tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(DictTable dt)
        #{
        #    boolean ret = false;
        #
        #    if( dt )
        #    {
        #        ret = (dt.id() != 0 && dt.id() != tablenum(Common));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(DictTable dt)
        #{
        #    Common record;
        #    ;
        #
        #    if( dt )
        #    {
        #        record = dt.makeRecord();
        #    }
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictTable nonNull(DictTable dt)
        #{
        #    if( !dt )
        #    {
        #        dt = new DictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #select
        #// выбирает из указанной таблицы запись, в которой указанное поле равно указанному значению
        #// перебрать все записи можно оператором next
        #//
        #// @see SysQuery::query(), RecordUtil::select()
        #public static Common select(DictTable dt, FieldId fieldId, anytype value, boolean _forupdate = false)
        #{
        #    Common ret;
        #    ;
        #
        #    if( dt )
        #    {
        #        ret = TableUtil::select(dt.id(), fieldId, value, _forupdate);
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #selectFirstOnly
        #// выбирает из указанной таблицы первую запись, в которой указанное поле равно указанному значению
        #public static Common selectFirstOnly(DictTable dt, FieldId fieldId, anytype value, boolean _forupdate = false)
        #{
        #    Common ret;
        #    ;
        #
        #    if( dt )
        #    {
        #        ret = TableUtil::selectFirstOnly(dt.id(), fieldId, value, _forupdate);
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #selectRecId
        #// выбирает из указанной таблицы первую запись, в которой RecId равено указанному значению
        #public static Common selectRecId(DictTable dt, RefRecId recId, boolean _forupdate = false)
        #{
        #    Common ret
        #    ;
        #
        #    if( dt )
        #    {
        #        ret = TableUtil::selectRecId(dt.id(), recId, _forupdate);
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #sysNonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictTable sysNonNull(SysDictTable dt)
        #{
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordUtil
    PROPERTIES
      Name                #RecordUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает табличные буферы
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class RecordUtil
        #{
        #}
      ENDSOURCE
      SOURCE #cacheLookup
        #public static RecordCacheLevel cacheLookup(Common rec)
        #{
        #    RecordCacheLevel ret = RecordUtil::dictTable(rec).cacheLookup();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clone
        #public static Common clone(Common orig, RefTableId expectedTableId = 0)
        #{
        #    Common clone;
        #
        #    if( expectedTableId &&
        #        expectedTableId != orig.TableId &&
        #        expectedTableId != TableUtil::commonTableId() )
        #    {
        #        throw error(strFmt('%1: Не совпадают TableId. Ожидается %2, фактическое значение %3',
        #                        funcname(),
        #                        SysDictTable::construct(expectedTableId).toString(),
        #                        SysDictTable::construct(orig.TableId).toString()
        #        ));
        #    }
        #
        #    clone = RecordUtil::makeRecord(orig);
        #    clone.data(orig);
        #
        #    return clone;
        #}
      ENDSOURCE
      SOURCE #commonRecord
        #public static Common commonRecord()
        #{
        #    Common rec;
        #
        #    return rec;
        #}
      ENDSOURCE
      SOURCE #dictTable
        #// всегда возвращает not nullable объект. Полезно в выражениях
        #public static DictTable dictTable(Common rec)
        #{
        #    DictTable dt = new DictTable(rec.TableId);
        #
        #    if( !dt )
        #    {
        #        dt = new DictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #findFromUniqueIndexFields
        #// ищет по значениям из полей, которые входят в уникальный индекс
        #public static Common findFromUniqueIndexFields(Common rec)
        #{
        #    KeyData     keyData     = SysDictTable::getKeyData(rec).pack();
        #    Common      ret         = SysDictTable::findFromKeyData(rec.TableId, keyData);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getFieldValue
        #// @deprecated! see RecordFieldIdUtil.getValue
        #public static anytype getFieldValue(Common record, FieldId fieldid)
        #{
        #    anytype value = RecordFieldUtil::getValue(record, fieldId);
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #getInfo
        #// mazzy, 18.12.2020
        #//
        #// возвращает строку, которая содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в информационных сообщениях
        #//
        #// пример использования:
        #// str s = SysDictTable::getInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// результат будет похож на: "RContractTable[CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]"
        #public static str getInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    str valueInfo = RecordUtil::getValuesInfo(rec, fieldIdCollection, uniqueCollection, mandatoryCollection);
        #    str ret = strFmt('%1[%2]', tableId2name(rec.TableId), valueInfo);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValues
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValues(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static container getValues(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set         fields  = new Set(Types::Integer);
        #    container   ret;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        Enumerator e = collection ? EnumeratorUtil::getEnumerator(collection) : null;
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                ret += rec.(fieldId);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValuesInfo
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValuesInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static str getValuesInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set fields = new Set(Types::Integer);
        #    TextBuffer text;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        DictField df;
        #        str info;
        #        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                df = new DictField(rec.TableId, fieldId);
        #                info = strfmt("%1=%2", df.label(), rec.(df.id()));
        #
        #                text = TextBufferUtil::appendIfNotEmpty(text, ', ');
        #                text = TextBufferUtil::appendStr(text, info);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return TextBufferUtil::getText(text);
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public static boolean hasTableAccess(Common rec, AccessType neededAccessType)
        #{
        #    AccessType accessType = RecordUtil::dictTable(rec).rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(Common rec, TableId tableOrMapId)
        #{
        #    boolean ret = TableUtil::is(rec.TableId, tableOrMapId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isCommon
        #public static boolean isCommon(Common record)
        #{
        #    boolean ret = (record.TableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isEmpty
        #// возвращает true, если таблица не содержит ни одной записи
        #// возвращает false, если хотя бы одна запись есть.
        #//
        #// метод особенно полезен для временных таблиц
        #public static boolean isEmpty(Common record)
        #{
        #    Common buf = RecordUtil::makeRecord(record);
        #
        #    if( record.isTmp() )
        #    {
        #        buf.setTmp();
        #        buf.setTmpData(record);
        #    }
        #
        #    select firstOnly firstFast buf;
        #
        #    return (buf.RecId == 0);
        #}
      ENDSOURCE
      SOURCE #isMapped
        #static boolean isMapped(Common rec, TableId potentialMapId)
        #{
        #    boolean ret = TableUtil::isMapped(rec.TableId, potentialMapId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotCommon
        #public static boolean isNotCommon(Common record)
        #{
        #    boolean ret = (record.TableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isNotEmpty
        #// возвращает false, если таблица не содержит ни одной записи
        #// возвращает true, если хотя бы одна запись есть.
        #//
        #// метод особенно полезен для временных таблиц
        #public static boolean isNotEmpty(Common record)
        #{
        #    return !RecordUtil::isEmpty(record);
        #}
      ENDSOURCE
      SOURCE #isNotSpecified
        #public static boolean isNotSpecified(Common record)
        #{
        #    boolean ret = (record.TableId == 0 || record.TableId == tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isSpecified
        #public static boolean isSpecified(Common record)
        #{
        #    boolean ret = (record.TableId != 0 && record.TableId != tablenum(Common));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #makeRecord
        #public static Common makeRecord(Common buf)
        #{
        #    Common record = TableUtil::makeRecord(buf.TableId);
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #makeRecordTmp
        #public static Common makeRecordTmp(Common buf)
        #{
        #    Common record = RecordUtil::makeRecord(buf);
        #    ;
        #
        #    record.setTmp();
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #makeRecordTmpData
        #public static Common makeRecordTmpData(Common buf)
        #{
        #    Common record = RecordUtil::makeRecord(buf);
        #    ;
        #
        #    record.setTmp();
        #    record.setTmpData(buf);
        #
        #    return record;
        #}
      ENDSOURCE
      SOURCE #match
        #// проверяет есть ли вхожение паттерна в какое-нибудь поле
        #// проверку выполняет рекурсивно, если есть поля-контейнеры
        #public static boolean match(
        #    str         pattern,
        #    Common      record,
        #    boolean     includeSystemFields     = false)
        #{
        #    SysDictTable    sysDictTable    = new SysDictTable(record.TableId);
        #    Set             fields          = sysDictTable.fields();
        #    SetEnumerator   fe              = fields ? fields.getEnumerator() : null;
        #    SysDictField    field;
        #    Any             value;
        #;
        #    while( fe && fe.moveNext() )
        #    {
        #        field = fe.current();
        #        if( !includeSystemFields && field.isSystem() )
        #            continue;
        #
        #        switch( field.type() )
        #        {
        #            case Types::String:
        #            case Types::RString:
        #            case Types::VarString:
        #                value = Any::field(record, field.id());
        #                if( match(pattern, value.asString()) )
        #                    return true;
        #                break;
        #
        #            case Types::Container:
        #                value = Any::field(record, field.id());
        #                if( ConUtil::match(pattern, value.asContainer()) )
        #                    return true;
        #                break;
        #
        #            case Types::Record:
        #                value = Any::field(record, field.id());
        #                if( RecordUtil::match(pattern, value.asRecord()) )
        #                    return true;
        #                break;
        #
        #            default:
        #                break;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #selectAndWrite
        #// 1. выбирает запись из базы, если запись еще не выбиралась
        #// 2. копирует пользовательские данные в выбранный буфер
        #// 3. записыват новые данные
        #// поэтому может возвратить новый буфер, который был прочитан из базы
        #//
        #// Внимание! не выполняет валидацию.
        #// @see validateSelectAndWriteOrThrow
        #public static Common selectAndWrite(Common buf)
        #{
        #    Common upd;
        #    ;
        #
        #    if( buf.RecId == 0 ||                   // новая запись. будет выполнен insert. безопасно.
        #        buf.selectForUpdate() ||            // запись выбрана с признаком ForUpdate = true. можно просто делать write.
        #        RecordUtil::isNotSpecified(buf) )   // для Common алкоголь в малых дозах безопасен в любом количестве
        #    {
        #        buf.write();                        // можно безопасно делать write без транзакции и без лишних телодвижений
        #    }
        #    else
        #    {
        #        // все сложно: запись вполне конкретной таблицы существует в базе, но выбиралась без ForUpdate.
        #        // что ж, выбираем запись, копируем в нее данные, записываем, возвращаем записанное
        #
        #        upd = RecordUtil::makeRecord(buf);
        #
        #        ttsbegin;
        #
        #        select firstOnly forUpdate upd
        #        where upd.RecId == buf.RecId;
        #
        #        upd.data(buf);
        #        upd.write();                        // не выполняем validate
        #
        #        ttscommit;
        #
        #        buf = upd;
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #setFieldValue
        #// @deprecated! see RecordFieldIdUtil::setValue
        #public static anytype setFieldValue(Common record, fieldId fieldid, anytype value)
        #{
        #    anytype ret = RecordFieldUtil::setValue(record, fieldId, value);
        #    record.(fieldid) = value;
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #sysDictTable
        #// всегда возвращает not nullable объект. Полезно в выражениях
        #public static SysDictTable sysDictTable(Common rec)
        #{
        #    SysDictTable dt = new SysDictTable(rec.TableId);
        #
        #    if( !dt )
        #    {
        #        new SysDictTable(tablenum(Common));
        #    }
        #
        #    return dt;
        #}
      ENDSOURCE
      SOURCE #tableName
        #public static TableName tableName(Common rec)
        #{
        #    TableName ret = tableid2name(rec.tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #tmpCount
        #public static Int64 tmpCount(Common buf)
        #{
        #    Common rec;
        #    ;
        #
        #    if( buf.isTmp() )
        #    {
        #        rec = RecordUtil::makeRecordTmpData(buf);
        #
        #        select count(recid) from rec;
        #    }
        #
        #    return rec.RecId;
        #}
        #
      ENDSOURCE
      SOURCE #tmpFilter
        #public static Common tmpFilter(Common buf, FieldId filterFieldId, AnyType filterValue)
        #{
        #    Common rec = RecordUtil::makeRecordTmp(buf);
        #
        #    Query       query = SysQuery::query(buf.TableId, filterFieldId, filterValue);
        #    QueryRun    queryRun = new QueryRun(query);
        #    ;
        #
        #    queryRun.setCursor(buf);
        #    while (queryRun.next())
        #    {
        #        rec = queryRun.get(buf.TableId);
        #        rec.insert();
        #    }
        #
        #    return rec;
        #}
        #
      ENDSOURCE
      SOURCE #validateAndDelete
        #public static boolean validateAndDelete(Common buf)
        #{
        #    boolean ret;
        #
        #    /* TODO надо ли вручную управлять методами, когда установлен skipDeleteMethod? или Аксапта сама сообразит?
        #    if( buf.skipDeleteMethod() )
        #    {
        #        buf.doDelete();
        #
        #        ret = true;
        #    }
        #    else
        #    */
        #    if( buf.validateDelete() )
        #    {
        #        buf.delete();
        #
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public static Common validateAndDeleteOrThrow(Common buf)
        #{;
        #    RecordUtil::validateDeleteOrThrow(buf);
        #    buf.delete();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #public static boolean validateAndInsert(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.insert();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public static Common validateAndInsertOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.insert();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #public static boolean validateAndUpdate(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.update();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public static Common validateAndUpdateOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.update();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #public static boolean validateAndWrite(Common buf)
        #{
        #    /* TODO надо ли вручную управлять методами, когда установлен skipDataMethod? или Аксапта сама сообразит?
        #    if( buf.skipDeleteMethod() )
        #    {
        #        buf.doWrtie();
        #
        #        ret = true;
        #    }
        #    else
        #    */
        #
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    buf.write();
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public static Common validateAndWriteOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #    buf.write();
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public static boolean validateDelete(Common buf)
        #{
        #    if( !buf.validateDelete() )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public static Common validateDeleteOrThrow(Common buf)
        #{
        #    if( !buf.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error for %1', RecordUtil::getInfo(buf)));
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateSelectAndWriteOrThrow
        #// 1. выполняет валидацию (бросает исключение, если валидация не прошла)
        #// 2. выбирает запись из базы, если запись еще не выбиралась
        #// 3. копирует пользовательские данные в выбранный буфер
        #// 4. записыват новые данные
        #// поэтому может возвратить новый буфер, который был прочитан из базы
        #public static Common validateSelectAndWriteOrThrow(Common buf)
        #{;
        #    RecordUtil::validateWriteOrThrow(buf);
        #
        #    buf = RecordUtil::selectAndWrite(buf);
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public static boolean validateWrite(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        return false;
        #    }
        #
        #    return true;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public static Common validateWriteOrThrow(Common buf)
        #{
        #    if( !buf.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error for %1', RecordUtil::getInfo(buf)));
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordUtilTest
    PROPERTIES
      Name                #RecordUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class RecordUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testTmpCount
        #void testTmpCount()
        #{
        #    TmpAccountSum tmp;
        #    int64 expected = 3;
        #    ;
        #
        #    tmp.clear();
        #    tmp.AccountNum = 'A';
        #    tmp.insert();
        #
        #    tmp.clear();
        #    tmp.AccountNum = 'B';
        #    tmp.insert();
        #
        #    tmp.clear();
        #    tmp.AccountNum = 'C';
        #    tmp.insert();
        #
        #    this.assertEquals(expected, RecordUtil::tmpCount(tmp));
        #
        #    // при этом текущая запись в самом буфере не изменилась
        #    this.assertEquals('C', tmp.AccountNum);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordList unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordList
    PROPERTIES
      Name                #RecordList
      Extends             #List
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addEnd
        #public anytype addEnd(anytype value)
        #{
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        buf = super(value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #addStart
        #public anytype addStart(anytype value)
        #{
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        buf = super(value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #appendEnumerator
        #// возвращает число добавленных элементов
        #public int appendEnumerator(Enumerator e, int maxElements = 0)
        #{
        #    int elements;
        #    Common buf;
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        buf = this.addEnd(e.current());
        #        elements += this.isAssignableBuf(buf);
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendList
        #// @override
        #public void appendList(List list)
        #{
        #    if( list &&
        #        confind([Types::Record, Types::Integer, Types::String, Types::RString, Types::VarString], list.typeId()) )
        #    {
        #        this.appendEnumerator(list.getEnumerator());
        #    }
        #}
      ENDSOURCE
      SOURCE #appendMarked
        #// добавляет все отмеченные на форме записи
        #// возвращает число добавленных элементов
        #public int appendMarked(FormDataSource fds, int maxElements = 0)
        #{
        #    int elements;
        #    common buf = fds ? fds.getFirst(1) : null;
        #
        #    while( fds && buf && (maxElements == 0 || elements <= maxElements) )
        #    {
        #        buf = this.addEnd(buf);
        #        elements = this.isAssignableBuf(buf);
        #
        #        buf = fds.getNext();
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendQuery
        #// добавляет в список datasource из query, которые получат значения в выборке из базы
        #// Получится список неинициализированых буферов
        #// возвращает число добавленных элементов
        #public int appendQuery(Query q, int maxElements = 0)
        #{
        #    int elements;
        #    QueryBuildDataSource qbds;
        #    int qbdsId;
        #
        #    if( q )
        #    {
        #        qbdsId = q.nextUniqueId();
        #        while( qbdsId && (maxElements == 0 || elements <= maxElements) )
        #        {
        #            qbds = q.dataSourceUniqueId(qbdsId);
        #
        #            if (qbds &&
        #                qbds.table() &&
        #                qbds.enabled() &&
        #                confind([JoinMode::InnerJoin, JoinMode::OuterJoin], qbds.joinMode()))
        #            {
        #                elements += this.addEnd(qbds.table());
        #            }
        #
        #            qbdsId = q.nextUniqueId();
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendRecIdEnumerator
        #// добавляет табличные буфера с указанными RecId
        #// возвращает число добавленных элементов
        #public int appendRecIdEnumerator(TableId tableId, Enumerator e, boolean selectForUpdate = false, int maxElements = 0)
        #{
        #    int       elements;
        #    RecId     recId;
        #    common    buf;
        #
        #    while( e && e.moveNext() && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        recId = AnytypeUtil::asRecId(e.current());
        #        if( recId )
        #        {
        #            buf = RecordUtil::commonRecord(); // на случай, если в списке табличные буфера разного типа
        #            buf.selectForUpdate(selectForUpdate);
        #            select firstonly buf where buf.RecId == recId;
        #
        #            buf = this.addEnd(e.current());
        #            elements += this.isAssignableBuf(buf);
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #appendSelect
        #// добавляет все записи из табличного буфера, который был заполнен командой select
        #// возвращает число добавленных элементов
        #//
        #// пример:
        #//
        #// {
        #//     CustTable ct;
        #//     select ct where ct.Name like 'Micro*';
        #//     SysRecordList::fromList(ct);
        #// }
        #//
        #public int appendSelect(Common selectedBuf, int maxElements = 0)
        #{
        #    int elements;
        #    Common buf;
        #
        #    while( selectedBuf && (maxElements == 0 || elements <= maxElements)  )
        #    {
        #        buf = this.addEnd(selectedBuf);
        #        elements += this.isAssignableBuf(buf);
        #
        #        next selectedBuf;
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #assignable
        #public Common assignable(anytype value)
        #{
        #    Common buf = AnytypeUtil::toBuf(value);
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/StrUtil
        #//
        #// Класс RecordList содержит список записей из таблиц *разного типа* (в том числе могут быть типа Common)
        #// для записей всех типов вполне успешно срабатывают табличные методы initValue, validateWrite, write, insert, update и т.д.
        #// класс позволяет единообразно обслуживать записи из списка
        #//
        #// класс во многом похож на RecordLinkList. отличия:
        #// * работает предсказуемым образом
        #// * гарантировано держит все записи в памяти
        #// * позволяет создавать несколько энумераторов и делать вложенные циклы по одному списку
        #// * не вмешивается и не копирует записи, поэтому внутренние флаги и проперти в записи сохраняются.
        #//   это значит что:
        #//   * методы update получат правильный флаг forupdate
        #//   * оператор next будет правильно работать с записями, которые выбраны из списка
        #//   * запись из map останется записью из map
        #// * методы pack/unpack позволяют эффективно передавать значения между клиентом и сервером (внутренние флаги и проперти сбрасываются)
        #// * методы validateDelete и validateWrite сначала проверят все записи, лишь потом выполнят действия для всех записей
        #// * реализованы методы merge и appendList и другие методы базового класса List
        #//
        #// по сравнению с RecordLinkList этот класс не позволяет:
        #// * получить доступ к записи по индексу (см. второй параметр в RecordLinkList.get)
        #// * перейти к предыдущей записи в цикле (см. метод RecordLinkList.prev)
        #// * удалять элементы из списка
        #//
        #// TODO добавить выборку табличных буферов из QueryRun
        #class RecordList extends List
        #{
        #    Set tableIds;
        #}
      ENDSOURCE
      SOURCE #deleteDatabase
        #// выполняет удаление без валиадции.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordList deleteDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        buf.delete();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public boolean hasTableAccess(AccessType neededAccessType)
        #{
        #    AccessType accessType = this.rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #initValue
        #// выполняет initValue для буферов с пустым recId.
        #public void initValue()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( !buf.RecId )
        #        {
        #            buf.initValue();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// выполняет вставку без валиадции для буферов с пустым recId.
        #// Может, стоит использовать метод validateAndInsert?
        #public RecordList insertDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( !buf.RecId )
        #        {
        #            buf.insert();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #isAssignableBuf
        #public boolean isAssignableBuf(Common buf)
        #{
        #    boolean ret = buf.TableId && !RecordUtil::isCommon(buf);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Types _type = Types::Record)
        #{
        #    anytype contract = Debug::assert(_type == Types::Record);
        #
        #    super(Types::Record);
        #}
      ENDSOURCE
      SOURCE #rights
        #// возвращает минимальный уровень доступа
        #// пустой список записей имеет максимальный уровень доступа
        #public AccessType rights()
        #{
        #    AccessType ret = AccessType::Delete;
        #    AccessType rights;
        #
        #    SetEnumerator se = this.tableIds().getEnumerator();
        #    TableId tableId;
        #
        #    while( se && se.moveNext() )
        #    {
        #        tableId = se.current();
        #        rights = new DictTable(tableId).rights(); // так мы получаем права с учетом свойства таблицы maxAccessMode
        #        ret = min(ret, rights);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #selectForUpdate
        #// устанавливает режим выборки для всех табличных буферов в true, если selectForUpdate == true
        #// не изменяет флаг у табличных буферов, если selectForUpdate == false
        #public void selectForUpdate(boolean selectForUpdate = false)
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( selectForUpdate && le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        buf.selectForUpdate(selectForUpdate);
        #    }
        #}
      ENDSOURCE
      SOURCE #setTmp
        #public void setTmp()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        buf.setTmp();
        #    }
        #}
      ENDSOURCE
      SOURCE #tableIds
        #public Set tableIds()
        #{
        #    if( !tableIds )
        #        tableIds = new Set(Types::Integer);
        #
        #    return tableIds;
        #}
      ENDSOURCE
      SOURCE #updateDatabase
        #// выполняет обновление без валиадции для буферов с заполненным recId.
        #// Может, стоит использовать метод validateAndupdate?
        #public RecordList updateDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( le && le.moveNext() )
        #    {
        #        buf = le.current();
        #        if( buf.RecId )
        #        {
        #            buf.update();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndDelete
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, удаляет
        #public boolean validateAndDelete()
        #{
        #    boolean valid = this.validateDelete();
        #
        #    if( valid )
        #    {
        #        this.deleteDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public RecordList validateAndDeleteOrThrow()
        #{
        #    this.validateDeleteOrThrow();
        #    this.deleteDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #// выполняет валидацию всех еще не вставленных записей (recId == 0),
        #// а затем, если валидация успешна, вставку еще не вставленных записей
        #public boolean validateAndInsert()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.insertDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public RecordList validateAndInsertOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.insertDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #// выполняет валидацию всех уже вставленных записей (recId != 0),
        #// а затем, если валидация успешна, update уже вставленных записей
        #public boolean validateAndUpdate()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.updateDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public RecordList validateAndUpdateOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, запись всех буферов (Аксапта сама разбирается нужно вставить или обновить буфер)
        #public boolean validateAndWrite()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.writeDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public RecordList validateAndWriteOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public boolean validateDelete()
        #{
        #    boolean valid = true;
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        valid = buf.validateDelete();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public RecordList validateDeleteOrThrow()
        #{
        #    if( !this.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error in %1', funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public boolean validateWrite()
        #{
        #    boolean valid = true;
        #    ListEnumerator le = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && le && le.moveNext() )
        #    {
        #        buf = le.current();         // строка для отладчика
        #        valid = buf.validateWrite();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public RecordList validateWriteOrThrow()
        #{
        #    if( !this.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error in %1', funcname()));
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #writeDatabase
        #// выполняет запись без валиадции всех буферов.
        #// Может, стоит использовать метод validateAndWrite?
        #public RecordList writeDatabase()
        #{
        #    ListEnumerator le = this.getEnumerator();
        #    Common rec;
        #
        #    while( le && le.moveNext() )
        #    {
        #        rec = le.current(); // строка для отладчика
        #        rec.write();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordList construct()
        #{
        #    RecordList recordList = new RecordList(Types::Record);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf
        #// табличные буфера как параметры, чтобы не потерять внутренние флаги
        #// такие как SelectForUpdate, formDataSource, был сделан select, isTmp
        #public static RecordList fromBuf(
        #    Common buf1 = null,
        #    Common buf2 = null,
        #    Common buf3 = null,
        #    Common buf4 = null,
        #    Common buf5 = null,
        #    Common buf6 = null,
        #    Common buf7 = null,
        #    Common buf8 = null,
        #    Common buf9 = null,
        #    Common buf10 = null,
        #    Common buf11 = null,
        #    Common buf12 = null)
        #{
        #    RecordList recordList = RecordList::construct();
        #
        #    if( !prmisdefault(buf1) ) recordList.addEnd(buf1);
        #    if( !prmisdefault(buf2) ) recordList.addEnd(buf2);
        #    if( !prmisdefault(buf3) ) recordList.addEnd(buf3);
        #    if( !prmisdefault(buf4) ) recordList.addEnd(buf4);
        #    if( !prmisdefault(buf5) ) recordList.addEnd(buf5);
        #    if( !prmisdefault(buf6) ) recordList.addEnd(buf6);
        #    if( !prmisdefault(buf7) ) recordList.addEnd(buf7);
        #    if( !prmisdefault(buf8) ) recordList.addEnd(buf8);
        #    if( !prmisdefault(buf9) ) recordList.addEnd(buf9);
        #    if( !prmisdefault(buf10) ) recordList.addEnd(buf10);
        #    if( !prmisdefault(buf11) ) recordList.addEnd(buf11);
        #    if( !prmisdefault(buf12) ) recordList.addEnd(buf12);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf1
        #public static RecordList fromBuf1(Common buf)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf2
        #public static RecordList fromBuf2(Common buf1, Common buf2)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf3
        #public static RecordList fromBuf3(Common buf1, Common buf2, Common buf3)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf4
        #public static RecordList fromBuf4(Common buf1, Common buf2, Common buf3, Common buf4)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf5
        #public static RecordList fromBuf5(Common buf1, Common buf2, Common buf3, Common buf4, Common buf5)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #    recordList.addEnd(buf5);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBuf6
        #public static RecordList fromBuf6(Common buf1, Common buf2, Common buf3, Common buf4, Common buf5, Common buf6)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(buf1);
        #    recordList.addEnd(buf2);
        #    recordList.addEnd(buf3);
        #    recordList.addEnd(buf4);
        #    recordList.addEnd(buf5);
        #    recordList.addEnd(buf6);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromBufCon
        #// табличные буфера в контейнере потеряют внутренние флаги
        #// такие как SelectForUpdate, formDataSource, был сделан select, isTmp
        #public static RecordList fromBufCon(container records, TableId tableId = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    Common buf;
        #    int len = conlen(records);
        #    int i;
        #
        #    for (i=1; i<=len; i++)
        #    {
        #        buf = ConUtil::peekAsRecord(records, i, tableId);
        #        if( tableId == 0 || RecordUtil::isNotCommon(buf) )
        #        {
        #            recordList.addEnd(buf);
        #        }
        #    }
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromCon
        #public static RecordList fromCon(container tableIds_tableNames_records)
        #{
        #    RecordList recordList = RecordList::construct();
        #    int len = conlen(tableIds_tableNames_records);
        #    int i;
        #
        #    for (i=1; i<=len; i++)
        #    {
        #        recordList.addEnd(conpeek(tableIds_tableNames_records, i));
        #    }
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromEnumerator
        #public static RecordList fromEnumerator(Enumerator e, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendEnumerator(e, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromList
        #// возвращает объект, содержащий клон списка
        #// внимание: объекты (элементы списка) являются общими для старого и нового списка, а сами списки - разные
        #public static RecordList fromList(List list)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendList(list);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromMarked
        #// добавляет все отмеченные на форме записи
        #// возвращает число добавленных элементов
        #public static RecordList fromMarked(FormDataSource fds, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendMarked(fds, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromQuery
        #// добавляет в список те datasource из query, которые получат значения в выборке из базы
        #public static RecordList fromQuery(Query q, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendQuery(q, maxElements);
        #
        #    return recordList;
        #}
      ENDSOURCE
      SOURCE #fromSelect
        #// добавляет все записи из буфера, который был заполнен командой select
        #//
        #// пример:
        #//
        #// {
        #//     ...
        #//     select custVendTable where custVendTable.Name like 'Micro*';
        #//     recordList = SysRecordList::fromSelect(custVendTable);
        #//     rle = recordList.getEnumerator()
        #//
        #//     while( rle && rle.moveNext() )
        #//     {
        #//        rle.current(); // возвращает табличный буфер
        #//     }
        #// }
        #//
        #public static RecordList fromSelect(Common rec, int maxElements = 0)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.appendSelect(rec, maxElements);
        #
        #    return recordList;
        #}
        #
        #
        #
      ENDSOURCE
      SOURCE #fromTableId
        #public static RecordList fromTableId(TableId tableId)
        #{
        #    RecordList recordList = RecordList::construct();
        #    ;
        #
        #    recordList.addEnd(tableId);
        #
        #    return recordList;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordMap unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordMap
    PROPERTIES
      Name                #RecordMap
      Extends             #Map
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #assignable
        #public Common assignable(anytype value)
        #{
        #    Common buf = AnytypeUtil::toBuf(value);
        #
        #    return buf;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс содержит map записей из таблиц *разного типа* (в том числе могут быть типа Common)
        #// для записей всех типов вполне успешно срабатывают табличные методы initValue, validateWrite, write, insert, update и т.д.
        #// класс позволяет единообразно обслуживать записи из списка
        #//
        #class RecordMap extends Map
        #{
        #    Set tableIds;
        #}
      ENDSOURCE
      SOURCE #deleteDatabase
        #// выполняет удаление без валиадции.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap deleteDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        buf.delete();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #hasTableAccess
        #public boolean hasTableAccess(AccessType neededAccessType)
        #{
        #    AccessType accessType = this.rights();
        #    boolean ret = (accessType >= neededAccessType);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #initValue
        #// выполняет initValue для буферов с пустым recId.
        #public void initValue()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.current();
        #        if( !buf.RecId )
        #        {
        #            buf.initValue();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #insert
        #public boolean insert(anytype key, anytype value)
        #{
        #    boolean ret;
        #    Common buf = this.assignable(value);
        #
        #    if( this.isAssignableBuf(buf) )
        #    {
        #        ret = super(key, value);
        #        this.tableIds().add(buf.TableId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// выполняет вставку без валиадции для буферов с пустым recId.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap insertDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.current();
        #        if( !buf.RecId )
        #        {
        #            buf.insert();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #isAssignableBuf
        #public boolean isAssignableBuf(Common buf)
        #{
        #    boolean ret = buf.TableId && !RecordUtil::isCommon(buf);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #public void new(Types _keyType, Types _valueType = Types::Record)
        #{
        #    anytype contract = Debug::assert(_valueType == Types::Record);
        #
        #    super(_keyType, Types::Record);
        #}
      ENDSOURCE
      SOURCE #rights
        #// возвращает минимальный уровень доступа
        #// пустой список записей имеет максимальный уровень доступа
        #public AccessType rights()
        #{
        #    AccessType ret = AccessType::Delete;
        #    AccessType rights;
        #
        #    SetEnumerator se = this.tableIds().getEnumerator();
        #    TableId tableId;
        #
        #    while( se && se.moveNext() )
        #    {
        #        tableId = se.current();
        #        rights = new DictTable(tableId).rights(); // так мы получаем права с учетом свойства таблицы maxAccessMode
        #        ret = min(ret, rights);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #selectForUpdate
        #// устанавливает режим выборки для всех табличных буферов в true, если selectForUpdate == true
        #// не изменяет флаг у табличных буферов, если selectForUpdate == false
        #public void selectForUpdate(boolean selectForUpdate = false)
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( selectForUpdate && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();
        #        buf.selectForUpdate(selectForUpdate);
        #    }
        #}
      ENDSOURCE
      SOURCE #setTmp
        #public void setTmp()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        buf.setTmp();
        #    }
        #}
      ENDSOURCE
      SOURCE #tableIds
        #public Set tableIds()
        #{
        #    if( !tableIds )
        #        tableIds = new Set(Types::Integer);
        #
        #    return tableIds;
        #}
      ENDSOURCE
      SOURCE #updateDatabase
        #// выполняет обновление без валиадции для буферов с заполненным recId.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap updateDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue();
        #        if( buf.RecId )
        #        {
        #            buf.update();
        #        }
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #validateAndDelete
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, удаляет
        #public boolean validateAndDelete()
        #{
        #    boolean valid = this.validateDelete();
        #
        #    if( valid )
        #    {
        #        this.deleteDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndDeleteOrThrow
        #public void validateAndDeleteOrThrow()
        #{
        #    this.validateDeleteOrThrow();
        #    this.deleteDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndInsert
        #// выполняет валидацию всех еще не вставленных записей (recId == 0),
        #// а затем, если валидация успешна, вставку еще не вставленных записей
        #public boolean validateAndInsert()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.insertDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndInsertOrThrow
        #public void validateAndInsertOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.insertDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndUpdate
        #// выполняет валидацию всех уже вставленных записей (recId != 0),
        #// а затем, если валидация успешна, update уже вставленных записей
        #public boolean validateAndUpdate()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.updateDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndUpdateOrThrow
        #public void validateAndUpdateOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #}
      ENDSOURCE
      SOURCE #validateAndWrite
        #// выполняет валидацию всех записей,
        #// а затем, если валидация успешна, запись всех буферов (Аксапта сама разбирается нужно вставить или обновить буфер)
        #public boolean validateAndWrite()
        #{
        #    boolean valid = this.validateWrite();
        #
        #    if( valid )
        #    {
        #        this.writeDatabase();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateAndWriteOrThrow
        #public void validateAndWriteOrThrow()
        #{
        #    this.validateWriteOrThrow();
        #    this.writeDatabase();
        #}
      ENDSOURCE
      SOURCE #validateDelete
        #public boolean validateDelete()
        #{
        #    boolean valid = true;
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        valid = buf.validateDelete();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateDeleteOrThrow
        #public void validateDeleteOrThrow()
        #{
        #    if( !this.validateDelete() )
        #    {
        #        throw error(strFmt('Delete validation error in %1', funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #validateWrite
        #public boolean validateWrite()
        #{
        #    boolean valid = true;
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( valid && me && me.moveNext() )
        #    {
        #        buf = me.currentValue();         // строка для отладчика
        #        valid = buf.validateWrite();
        #    }
        #
        #    return valid;
        #}
      ENDSOURCE
      SOURCE #validateWriteOrThrow
        #public void validateWriteOrThrow()
        #{
        #    if( !this.validateWrite() )
        #    {
        #        throw error(strFmt('Write validation error in %1', funcname()));
        #    }
        #}
      ENDSOURCE
      SOURCE #writeDatabase
        #// выполняет запись без валиадции всех буферов.
        #// Может, стоит использовать метод validateAndDelete?
        #public RecordMap writeDatabase()
        #{
        #    MapEnumerator me = this.getEnumerator();
        #    Common buf;
        #
        #    while( me && me.moveNext() )
        #    {
        #        buf = me.currentValue(); // строка для отладчика
        #        buf.writeDatabase();
        #    }
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static RecordMap construct(Types keyType)
        #{
        #    RecordMap recordMap = new RecordMap(keyType, Types::Record);
        #
        #    return recordMap;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysRecordInsertList unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysRecordInsertList
    PROPERTIES
      Name                #SysRecordInsertList
      Extends             #RecordInsertList
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #add
        #// добавляет запись к набору RecordInsertList
        #// перед добавлением выполняет validateVrite, если это не запрещено параметрами класса
        #public int add(Common record)
        #{
        #    int ret;
        #
        #    if (this.skipValidateWrite() || record.validateWrite())
        #    {
        #        ret = super(record);    // внимание! на клиенте всегда возвращает 0
        #        elements++;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysRecordInsertList extends RecordInsertlist
        #{
        #    boolean skipValidateWrite;
        #
        #    int elements;
        #    int lastInserted;
        #}
      ENDSOURCE
      SOURCE #elements
        #// всего элементов было добавлено в этот список
        #public int elements()
        #{
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #insertDatabase
        #// возвращает число записей, которые были вставлены в базу данной командой
        #public int insertDatabase()
        #{
        #    int ret;
        #
        #    if( elements )
        #    {
        #        ret = super();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #skipValidateWrite
        #public boolean skipValidateWrite(boolean _skipValidateWrite = skipValidateWrite)
        #{
        #    skipValidateWrite = _skipValidateWrite;
        #    return skipValidateWrite;
        #}
      ENDSOURCE
      SOURCE #construct
        #// создает объект на сервере
        #// используйте new(), если вы хотите вручную управлять местом создания объекта
        #public server static SysRecordInsertList construct(
        #    TableId     tableId,
        #    boolean     skipInsertMethod    = false,
        #    boolean     skipDatabaseLog     = false,
        #    boolean     skipEvents          = false,
        #    boolean     skipAosValidation   = false,
        #    boolean     skipRLSValidation   = false,
        #    boolean     skipValidateWrite   = false)
        #{
        #    SysRecordInsertList ril = new SysRecordInsertList(
        #                                    tableId,
        #                                    skipInsertMethod,
        #                                    skipDatabaseLog,
        #                                    skipEvents,
        #                                    skipAosValidation,
        #                                    skipRLSValidation);
        #    ;
        #
        #    ril.skipValidateWrite(skipValidateWrite);
        #
        #    return ril;
        #}
      ENDSOURCE
      SOURCE #fromRecord
        #// создает объект на сервере
        #// используйте new(), если вы хотите вручную управлять местом создания объекта
        #public server static SysRecordInsertList fromRecord(
        #    Common      record,
        #    boolean     skipValidateWrite   = false,
        #    boolean     skipRLSValidation   = record.recordLevelSecurity())
        #{
        #    SysRecordInsertList     ril     = SysRecordInsertList::construct(
        #                                            record.tableId,
        #                                            record.skipDataMethods(),
        #                                            record.skipDatabaseLog(),
        #                                            record.skipEvents(),
        #                                            record.skipAosValidation(),
        #                                            skipRLSValidation);
        #    ;
        #
        #    ril.skipValidateWrite(skipValidateWrite);
        #
        #    return ril;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: DictFieldUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #DictFieldUtil
    PROPERTIES
      Name                #DictFieldUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты с типом DictField
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see FieldIdUtil
        #//
        #abstract class DictFieldUtil
        #{
        #}
      ENDSOURCE
      SOURCE #baseType
        #public static Types baseType(DictField df)
        #{
        #    Types type = TypeUtil::undefined();
        #
        #    if( df )
        #    {
        #        type = df.baseType();
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(DictField dt, ExtendedTypeId potentialAncestorId)
        #{
        #    boolean ret;
        #
        #    if( dt && potentialAncestorId)
        #    {
        #        ret = ExtendedTypeUtil::is(dt.typeId(), potentialAncestorId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #nonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictField nonNull(DictField df)
        #{
        #    if( !df )
        #    {
        #        df = new DictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #select
        #// выбирает из указанной таблицы запись, в которой указанное поле равно указанному значению
        #// перебрать все записи можно оператором next
        #//
        #// @see SysQuery::query(), RecordUtil::select()
        #public static Common select(DictField df, anytype value, boolean _forupdate = false)
        #{
        #    Common ret;
        #    ;
        #
        #    if( df )
        #    {
        #        ret = TableUtil::select(df.tableid(), df.id(), value, _forupdate);
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #selectFirstOnly
        #// выбирает из указанной таблицы первую запись, в которой указанное поле равно указанному значению
        #public static Common selectFirstOnly(DictField df, anytype value, boolean _forupdate = false)
        #{
        #    Common ret;
        #    ;
        #
        #    if( df )
        #    {
        #        ret = TableUtil::selectFirstOnly(df.tableid(), df.id(), value, _forupdate);
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: FieldUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #FieldUtil
    PROPERTIES
      Name                #FieldUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает значения с типом FieldId
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #// @see DictFieldUtil
        #//
        #abstract class FieldUtil
        #{
        #}
      ENDSOURCE
      SOURCE #baseType
        #public static Types baseType(TableId tableId, FieldId fieldId)
        #{
        #    DictField df = FieldUtil::dictField(tableId, fieldId);
        #    Types type = TypeUtil::undefined();
        #
        #    if( df )
        #    {
        #        type = df.baseType();
        #    }
        #
        #    return type;
        #}
      ENDSOURCE
      SOURCE #dictField
        #public static DictField dictField(TableId tableId, FieldId fieldId)
        #{
        #    DictField df;
        #
        #    if( tableId && fieldId )
        #    {
        #        df = new DictField(tableId, fieldId);
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #dictField_NonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static DictField dictField_NonNull(TableId tableId, FieldId id)
        #{
        #    DictField df = FieldUtil::dictField(tableId, id);
        #    ;
        #
        #    df = DictFieldUtil::nonNull(df);
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #is
        #public static boolean is(TableId tableId, FieldId fieldId, ExtendedTypeId potentialAncestorId)
        #{
        #    DictField dt = new DictField(tableId, fieldId);
        #    boolean ret = DictFieldUtil::is(dt, potentialAncestorId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #RecId
        #public static FieldId recId()
        #{
        #    return fieldnum(Common, RecId);
        #}
      ENDSOURCE
      SOURCE #sysDictField
        #public static SysDictField sysDictField(TableId tableId, FieldId fieldId, int arrayIndex = 0)
        #{
        #    SysDictField df;
        #
        #    if( tableId && fieldId )
        #    {
        #        df = new SysDictField(tableId, fieldId, arrayIndex);
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #sysDictField_NonNull
        #// Возвращает подходящий не nullable объект.
        #// Полезно в выражениях, чтобы быть уверенным, что после выполнения этого метода объект точно не null
        #//
        #// not в названиях методов прочно ассоциируется с оператором логического отрицания (!)
        #// Поэтому название этого метода NonNull, а не NotNull
        #//
        #// @see https://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use
        #//
        #public static SysDictField sysDictField_NonNull(TableId tableId, FieldId id, int arrayIndex = 0)
        #{
        #    SysDictField df = FieldUtil::sysDictField(tableId, id, arrayIndex);
        #    ;
        #
        #    if( !df )
        #    {
        #        df = new SysDictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #TableId
        #public static FieldId tableId()
        #{
        #    return fieldnum(Common, TableId);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: RecordFieldUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #RecordFieldUtil
    PROPERTIES
      Name                #RecordFieldUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// mazzy, https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает поля табличного буфера
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class RecordFieldUtil
        #{
        #}
      ENDSOURCE
      SOURCE #dictField
        #// всегда возвращает not nullable объект. Полезно в выражениях
        #public static DictField dictField(Common rec, FieldId fieldId)
        #{
        #    DictField df = new DictField(rec.TableId, fieldId);
        #
        #    if( !df )
        #    {
        #        df = new DictField(tablenum(Common), fieldnum(Common, RecId));
        #    }
        #
        #    return df;
        #}
      ENDSOURCE
      SOURCE #findRef
        #// TODO refRecord
        #public static str findRef(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #findRefTitleField2
        #// TODO refTitleField2 - title field 2 from reference table
        #public static str findRefTitleField2(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #findReTitleField1
        #// TODO refTitleField2 - title field 1 from reference table
        #public static str findReTitleField1(Common rec, FieldId fieldId)
        #{
        #}
      ENDSOURCE
      SOURCE #getInfo
        #// mazzy, 18.12.2020
        #//
        #// возвращает строку, которая содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в информационных сообщениях
        #//
        #// пример использования:
        #// str s = SysDictTable::getInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// результат будет похож на: "RContractTable[CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]"
        #public static str getInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    str valueInfo = RecordUtil::getValuesInfo(rec, fieldIdCollection, uniqueCollection, mandatoryCollection);
        #    str ret = strFmt('%1[%2]', tableId2name(rec.TableId), valueInfo);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValue
        #public static anytype getValue(Common record, FieldId fieldid)
        #{
        #    // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    anytype value = record.(fieldid);
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #getValues
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValues(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static container getValues(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set         fields  = new Set(Types::Integer);
        #    container   ret;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        Enumerator e = collection ? EnumeratorUtil::getEnumerator(collection) : null;
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                ret += rec.(fieldId);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValuesInfo
        #// mazzy, 05.12.2019
        #//
        #// возвращает контейнер, который содержит значения указанных в контейнере, ключевых и обязательных полей
        #// каждое поле задействовано в контейнере только один раз
        #//
        #// порядок возвращаемых значений:
        #// сначала идут значения из полей, которые указаны пользователем,
        #// затем полей из уникальных индексов, затем обязательные поля
        #//
        #// как правило, метод используется в unit-тестах
        #//
        #// пример использования:
        #// container values = SysDictTable::getValuesInfo(rContractTable, [fieldnum(rContractTable,CurrencyCode)]);
        #//
        #// в стандартной Аксапте уникальный индекс состоит из полей RContractPartnerType, RContractCode, RContractAccount
        #// контейнер values будет содержать 4 значения: [CurrencyCode, RContractPartnerType, RContractCode, RContractAccount]
        #public static str getValuesInfo(
        #    Common      rec,
        #    anytype     fieldIdCollection       = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     uniqueCollection        = null, // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #    anytype     mandatoryCollection     = null) // Integer, Container, List, Set, Map, implements Enumerable or getEnumerator method
        #{
        #    Set fields = new Set(Types::Integer);
        #    TextBuffer text;
        #
        #    void appendFrom(anytype collection)
        #    {
        #        FieldId fieldId;
        #        DictField df;
        #        str info;
        #        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        #
        #        while( e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #
        #            if( fieldId && fields.add(fieldId) )
        #            {
        #                df = new DictField(rec.TableId, fieldId);
        #                info = strfmt("%1=%2", df.label(), rec.(df.id()));
        #
        #                text = TextBufferUtil::appendIfNotEmpty(text, ', ');
        #                text = TextBufferUtil::appendStr(text, info);
        #            }
        #        }
        #    }
        #
        #    appendFrom(fieldIdCollection);
        #    appendFrom(uniqueCollection ? uniqueCollection : SysDictTable::getUniqueIndexFields(rec.TableId));
        #    appendFrom(mandatoryCollection ? mandatoryCollection : SysDictTable::getMandatoryFields(rec.TableId));
        #
        #    return TextBufferUtil::getText(text);
        #}
      ENDSOURCE
      SOURCE #setValue
        #public static anytype setValue(Common record, fieldId fieldid, anytype value)
        #{
        #    // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        #    record.(fieldid) = value;
        #
        #    return value;
        #}
      ENDSOURCE
      SOURCE #titleField1
        #// TODO TitleField2
        #public static str titleField1(Common rec)
        #{
        #}
      ENDSOURCE
      SOURCE #titleField2
        #// TODO TitleField2
        #public static str titleField2(Common rec)
        #{
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArgsUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArgsUtil
    PROPERTIES
      Name                #ArgsUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс обслуживает объекты типа Args
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class ArgsUtil
        #{
        #}
      ENDSOURCE
      SOURCE #asRecord
        #public static Common asRecord(Args args, TableId tableId = 0)
        #{
        #    Common ret;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        ret = args.record();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #assertCallerFormName
        #public static void assertCallerFormName(Args args, FormName formName, str _funcname = '')
        #{
        #    if( ArgsUtil::callerFormName(args) == formName)
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertCallerType
        #public static void assertCallerType(Args args, classId potentialAncestorClassId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkCallerType(args, potentialAncestorClassId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnum
        #public static void assertEnum(Args args, Anytype enum, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkEnum(args, enum) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnum_Parm
        #public static void assertEnum_Parm(Args args, Anytype enum, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkEnum_Parm(args, enum) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnum_RefField
        #public static void assertEnum_RefField(Args args, Anytype enum, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkEnum_RefField(args, enum) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnumType
        #public static void assertEnumType(Args args, EnumId enumId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkEnumType(args, enumId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnumType_Parm
        #public static void assertEnumType_Parm(Args args, EnumId enumId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkEnumType_Parm(args, enumId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertEnumType_RefField
        #public static void assertEnumType_RefField(Args args, EnumId enumId, str _funcname = '')
        #{
        #    if( ArgsUtil::checkEnumType_RefField(args, enumId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertFormDatasource
        #public static void assertFormDatasource(Args args, str _funcname = '')
        #{
        #    if (args && args.dataset() && args.record().isFormDataSource())
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::wrongUseOfFunction(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertParm
        #public static void assertParm(Args args, str matchPattern = '.', str _funcname = '')
        #{
        #    if ( ArgsUtil::checkParm(args, matchPattern) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecord
        #public static void assertRecord(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecordExists
        #public static void assertRecordExists(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecordExists(args, tableId) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #assertRecordTableIds
        #public static void assertRecordTableIds(Args args, container tableIds, str _funcname = '')
        #{
        #    if ( ArgsUtil::checkRecordTableIds(args, tableIds) )
        #    {
        #        return;
        #    }
        #
        #    throw error(Error::missingRecord(_funcname ? _funcname : funcname()));
        #}
      ENDSOURCE
      SOURCE #caller
        #public static Object caller(Args args, classId potentialAncestorClassId)
        #{
        #    Object ret;
        #
        #    if( args )
        #    {
        #        ret = SysDictClass::as(args.caller(), potentialAncestorClassId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #callerFormName
        #public static str callerFormName(Args args)
        #{
        #    FormRun formRun = ArgsUtil::caller(args, classnum(FormRun));
        #    str formName;
        #
        #    if( formRun )
        #    {
        #        formName = formRun.form().name();
        #    }
        #
        #    return formName;
        #}
      ENDSOURCE
      SOURCE #checkCallerFormName
        #public static boolean checkCallerFormName(Args args, str formName)
        #{
        #    boolean ret = (ArgsUtil::callerFormName(args) == formName);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkCallerType
        #public static boolean checkCallerType(Args args, classId potentialAncestorClassId)
        #{
        #    boolean checkOk = args && SysDictClass::is(args.caller(), potentialAncestorClassId);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkEnum
        #public static boolean checkEnum(Args args, Anytype enum)
        #{
        #    boolean ret = ArgsUtil::checkEnum_Parm(args, enum) ||
        #                  ArgsUtil::checkEnum_RefField(args, enum);
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #checkEnum_Parm
        #public static boolean checkEnum_Parm(Args args, Anytype enum)
        #{
        #    boolean ret;
        #
        #    if( args && typeof(enum) == types::Enum )
        #    {
        #        ret = (enum == args.parmEnum());
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #checkEnum_RefField
        #// TODO!!!!
        #public static boolean checkEnum_RefField(Args args, Anytype enum)
        #{
        #    boolean ret;
        #
        #    if( args && typeof(enum) == types::Enum )
        #    {
        #        throw error(Error::missingOverride(funcname()));
        #
        #        ret = (enum == args.parmEnum());
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #checkEnumType
        #public static boolean checkEnumType(Args args, EnumId enumId)
        #{
        #    boolean ret = ArgsUtil::checkEnumType_Parm(args, enumId) ||
        #                  ArgsUtil::checkEnumType_RefField(args, enumId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkEnumType_Parm
        #public static boolean checkEnumType_Parm(Args args, EnumId enumId)
        #{
        #    boolean checkOk = (args && args.parmEnumType() == enumId);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkEnumType_RefField
        #public static boolean checkEnumType_RefField(Args args, EnumId enumId)
        #{
        #    boolean checkOk = (args && args.parmEnumType() == enumId);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkParm
        #// параметр parm содержит паттерн.
        #// возвращает true, если parm-строка соответствует regexp-выражению в matchPattern (метод использует функцию match для проверки)
        #// если не указать matchPattern, то возвращает true, если parm не пустой (содержит хотя бы один символ)
        #// возвращает true, если matchPattern является пустой строкой
        #public static boolean checkParm(Args args, str matchPattern = '.')
        #{
        #    boolean checkOk = (args && match(matchPattern, args.parm()));
        #
        #    return checkOk;
        #}
        #
      ENDSOURCE
      SOURCE #checkRecord
        #// запись из указанной таблицы (или любой таблицы для tableId = 0)
        #public static boolean checkRecord(Args args, TableId tableId = 0)
        #{
        #    boolean ret = false;
        #    int dataset;
        #
        #    if( args )
        #    {
        #        dataset = args.dataset();
        #
        #        if( dataset )
        #        {
        #            ret = (tableId == 0 || TableUtil::is(dataset, tableId));
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkRecordExists
        #// запись существует (recId != 0) и запись из указанной таблицы (или любой таблицы для tableId = 0)
        #public static boolean checkRecordExists(Args args, TableId tableId = 0)
        #{
        #    boolean checkOk = (ArgsUtil::checkRecord(args, tableId) && args.record().RecId != 0);
        #
        #    return checkOk;
        #}
      ENDSOURCE
      SOURCE #checkRecordTableIds
        #// возвращает true, если:
        #// * коллекция содержит tableId, совпадающий с tableId таблицы
        #// * коллекция содержит 0 или CommonTableId
        #// * коллекция пустая и записи в args не переданы
        #// возвращает false в остальных случаях
        #
        #// коллекция - это одно значение, container, Set, List, Array
        #public static boolean checkRecordTableIds(Args args, anytype tableIdOrCollection)
        #{
        #    boolean     ret = true; // для пустой коллекции
        #    Enumerator  e   = EnumeratorUtil::getEnumerator(tableIdOrCollection);
        #    TableId     tableId;
        #
        #    while( e && e.moveNext() )
        #    {
        #        tableId = e.current(); // TODO здесь возможно исключение, если коллекция содержит не целые
        #
        #        if( ArgsUtil::checkRecord(args, tableId) )
        #        {
        #            return true;
        #        }
        #
        #        ret = false;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #copyArgs
        #public static Args copyArgs(Args fromArgs, Args toArgs = null)
        #{
        #    if (fromArgs)
        #    {
        #        if (!toArgs)
        #        {
        #            toArgs = new Args();
        #        }
        #
        #        SysArgs::copyArgs(fromArgs, toArgs);
        #    }
        #
        #    return toArgs;
        #}
        #
      ENDSOURCE
      SOURCE #dataset
        #public static TableId dataset(Args args)
        #{
        #    TableId dataset = 0;
        #
        #    if( args )
        #    {
        #        dataset = args.dataset();
        #    }
        #
        #    return dataset;
        #}
      ENDSOURCE
      SOURCE #enum
        #// убедиться что в аргументах enum указанного типа и
        #// вернуть значение этого enum из аргументов
        #// бросает исключение, если enum не указанного типа
        #public static int enum(Args args, anytype enumIdNameOrValue, str _funcname = '')
        #{
        #    EnumId enumId = AnytypeUtil::enumId(enumIdNameOrValue);
        #    ;
        #
        #    ArgsUtil::assertEnumType(args, enumId, _funcname);
        #
        #    return args.parmEnum();
        #}
      ENDSOURCE
      SOURCE #enum_Parm
        #// убедиться что в аргументах CopyOfenum указанного типа и
        #// вернуть значение этого enum из аргументов
        #// бросает исключение, если enum не указанного типа
        #public static int enum_Parm(Args args, EnumId enumId, str _funcname = '')
        #{;
        #    ArgsUtil::assertEnumType_Parm(args, enumId, _funcname);
        #
        #    return args.parmEnum();
        #}
      ENDSOURCE
      SOURCE #enum_RefField
        #// убедиться что в аргументах enum указанного типа и
        #// вернуть значение этого enum из аргументов
        #// бросает исключение, если enum не указанного типа
        #public static int enum_RefField(Args args, EnumId enumId, str _funcname = '')
        #{;
        #    ArgsUtil::assertEnumType_RefField(args, enumId, _funcname);
        #
        #    return args.parmEnum(); // TODO !!!!!
        #}
      ENDSOURCE
      SOURCE #enumDefault
        #// тоже самое, что и ArgsUtil::getEnum()
        #// но если в аргументах не нужный enum не выдает ошибку, а возвращает дефолтное значение.
        #public static int enumDefault(Args args, anytype defaultEnumValue)
        #{
        #    if( typeof(defaultEnumValue) == Types::Enum )
        #    {
        #        if( ArgsUtil::checkEnumType(args, AnytypeUtil::enumId(defaultEnumValue)) )
        #        {
        #            return args.parmEnum();
        #        }
        #
        #        return defaultEnumValue;
        #    }
        #
        #    throw error::wrongUseOfFunction(funcname());
        #}
      ENDSOURCE
      SOURCE #enumOrDefault
        #// TODO !!!
        #// тоже самое, что и ArgsUtil::getEnum()
        #// но если в аргументах не нужный enum не выдает ошибку, а возвращает дефолтное значение.
        #public static int enumOrDefault(Args args, anytype defaultEnumValue)
        #{
        #    if( typeof(defaultEnumValue) == Types::Enum )
        #    {
        #        if( ArgsUtil::checkEnumType(args, AnytypeUtil::enumId(defaultEnumValue)) )
        #        {
        #            return args.parmEnum();
        #        }
        #
        #        return defaultEnumValue;
        #    }
        #
        #    throw error::wrongUseOfFunction(funcname());
        #}
      ENDSOURCE
      SOURCE #enumOrDefault_Parm
        #// тоже самое, что и ArgsUtil::getEnumFromParm()
        #// но если в аргументах не нужный enum не выдает ошибку, а возвращает дефолтное значение.
        #public static int enumOrDefault_Parm(Args args, anytype defaultEnumValue)
        #{
        #    if( typeof(defaultEnumValue) == Types::Enum )
        #    {
        #        if( ArgsUtil::checkEnumType_Parm(args, AnytypeUtil::enumId(defaultEnumValue)) )
        #        {
        #            return args.parmEnum();
        #        }
        #
        #        return defaultEnumValue;
        #    }
        #
        #    throw error::wrongUseOfFunction(funcname());
        #}
      ENDSOURCE
      SOURCE #enumOrDefault_RefField
        #// тоже самое, что и ArgsUtil::getEnumFromParm()
        #// но если в аргументах не нужный enum не выдает ошибку, а возвращает дефолтное значение.
        #public static int enumOrDefault_RefField(Args args, anytype defaultEnumValue)
        #{
        #    if( typeof(defaultEnumValue) == Types::Enum )
        #    {
        #        if( ArgsUtil::checkEnumType_RefField(args, AnytypeUtil::enumId(defaultEnumValue)) )
        #        {
        #            return args.parmEnum(); // TODO !!!!
        #        }
        #
        #        return defaultEnumValue;
        #    }
        #
        #    throw error::wrongUseOfFunction(funcname());
        #}
      ENDSOURCE
      SOURCE #marked
        #// возвращает отмеченные в датасорсе записи
        #// список может быть пустым, если record не является датасорсом формы
        #public static RecordList marked(Args args, TableId tableId = 0)
        #{
        #    RecordList ret;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        ret = RecordList::fromMarked(args.record().dataSource());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedIds
        #// возвращает set со значениями уникального индекса в промаркированных на форме записях
        #// если args не содержит записей или содержит записи "не того" типа, то null
        #// если на форме нет промарктированных записей, то вернет set из одной записи (из args.record)
        #//
        #// найдет уникальный индекс, состоящий из одного поля, и возвратит значения этого поля
        #// бросит исключение, если уникальный индекс не найден или состоит не из одного поля
        #public static Set markedIds(Args args, TableId tableId)
        #{
        #    SysDictTable    dt          = new SysDictTable(tableId);
        #    DictIndex       dictIndex   = dt ? dt.findUniqueIndex() : null;
        #    Set             ret;
        #
        #    if( dictIndex && dictIndex.numberOfFields() == 1 )
        #    {
        #        ret = ArgsUtil::markedSet(args, tableId, dictIndex.field(1));
        #    }
        #    else
        #    {
        #        throw error(strfmt('%1 did not find a unique index with one field.'));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedOrCurrent
        #// возвращает отмеченные на форме записи или текущую
        #public static RecordList markedOrCurrent(Args args, TableId tableId = 0)
        #{
        #    RecordList ret = ArgsUtil::marked(args, tableId);
        #    Common buf;
        #    ;
        #
        #    if( !ret || ret.elements() == 0 )
        #    {
        #        buf = ArgsUtil::record(args, tableId);
        #        ret = RecordList::fromBuf1(buf);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedRecIds
        #public static container markedRecIds(Args args, TableId tableId = 0, str _funcname = '')
        #{
        #    container       ret;
        #    FormDataSource  fds;
        #    common          record;
        #
        #    if( ArgsUtil::checkRecord(args, tableId) )
        #    {
        #        fds = args.record().dataSource();
        #        if( fds && fds.anyMarked() )
        #        {
        #            // marked records
        #            for( record = fds.getFirst(true) ; record ; record = fds.getNext() )
        #            {
        #                ret += record.RecId;
        #            }
        #        }
        #
        #        if( !ret )
        #        {
        #            // or a record itself
        #            record = ArgsUtil::record(args, tableId, _funcname);
        #            ret = [record.RecId];
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedSet
        #// возвращает set со значениями в указанном поле в промаркированных на форме записях
        #// если args не содержит записей или содержит записи "не того" типа, то null
        #// если на форме нет промарктированных записей, то вернет set из одной записи (из args.record)
        #// если опустить параметр _field, то возвратит значения recId
        #public static Set markedSet(Args args, TableId tableId = 0, FieldId fieldId = 0)
        #{
        #    Set             ret;
        #    Common          record = ArgsUtil::asRecord(args, tableId);
        #    FormDataSource  fds;
        #    Common          marked;
        #
        #    if( RecordUtil::isNotCommon(record) )
        #    {
        #        if( !fieldId )
        #        {
        #            fieldId = fieldnum(Common, RecId);
        #        }
        #
        #        fds = record.dataSource();
        #        if( fds && fds.anyMarked() )
        #        {
        #            // marked records
        #            for( marked = fds.getFirst(true) ; marked ; marked = fds.getNext() )
        #            {
        #                ret = SetUtil::addFieldValue(ret, marked, fieldId);
        #            }
        #        }
        #
        #        if( !ret )
        #        {
        #            // or a record itself
        #            ret = SetUtil::addFieldValue(ret, record, fieldId);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #markedSets
        #// возвращает map(key=fieldId, value=set), содержащий set со значениями в указанном поле в промаркированных на форме записях
        #// если args не содержит записей или содержит записи "не того" типа, то вернет пустой map
        #// если опустить параметр _field, то возвратит значения одного поля - recId
        #// если на форме нет промарктированных записей, то вернет набор из одной записи (из args.record)
        #public static Map markedSets(Args args, TableId tableId, anytype fieldIdCollection)
        #{
        #    Map         ret = new Map(Types::Integer, Types::Class); // {FieldId, Set(FieldValue)}
        #    Enumerator  e;
        #    FieldId     fieldId;
        #    Set         set;
        #
        #    if( ArgsUtil::checkRecord(args, tableid) )
        #    {
        #        // можно переделать, чтобы вместо вложенных циклов был один цикл
        #        e = AnytypeUtil::getEnumerator(fieldIdCollection);
        #        while( tableId && e && e.moveNext() )
        #        {
        #            fieldId = AnytypeUtil::asInt(e.current());
        #            if( fieldId )
        #            {
        #                set = ArgsUtil::markedSet(args, tableId, fieldId);
        #                ret.insert(fieldId, set);
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #populateRecord
        #// заполняет данные в указанной записи, если в аргументах есть запись с подходящей таблицей (map)
        #// возвращает true, если запись была заполнена
        #//
        #// Внимание! метод заполнит только поля. метод потеряет информацию о datasource, while select, selectForUpdate и прочее
        #public static boolean populateRecord(Args args, Common record)
        #{
        #    boolean ret;
        #
        #    if( ArgsUtil::checkRecord(args, record.TableId) )
        #    {
        #        record.data(args.record());
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #record
        #public static Common record(Args args, TableId tableId = 0, str _funcname = '')
        #{;
        #    ArgsUtil::assertRecord(args, tableId, _funcname);
        #
        #    return args.record();
        #}
      ENDSOURCE
      SOURCE #recordAs
        #// @deprecated!
        #public static Common recordAs(Args args, TableId tableId = 0)
        #{
        #    Common ret = ArgsUtil::asRecord(args, tableId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #setEnum
        #public static boolean setEnum(Args args, anytype enum)
        #{
        #    boolean ret;
        #    EnumId enumId;
        #
        #    if( args && typeof(enum) == Types::Enum )
        #    {
        #        enumId = DictEnum::value2id(enum);
        #        args.parmEnumType(enumId);
        #        args.parmEnum(enum);
        #
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: ArgsUtilTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #ArgsUtilTest
    PROPERTIES
      Name                #ArgsUtilTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #
        #// not yet implemented
        #// - the test testAssertFormDatasource() when a record.isFormDataSource()
        #// - tests for ArgsUtil::getMarkedRecIds()
        #class ArgsUtilTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName
        #void testAssertCallerFormName()
        #{
        #    Args        args            = new Args();
        #
        #    str         formName        = formstr(SysUserInfo);
        #    Args        formRunArgs     = new Args(formName);
        #    FormRun     formRun         = classFactory.formRunClass(formRunArgs);
        #;
        #    args.caller(formRun);
        #
        #//    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_Empty
        #void testAssertCallerFormName_Empty()
        #{
        #    Args    args        = new Args();
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_NotForm
        #void testAssertCallerFormName_NotForm()
        #{
        #    Args    args        = new Args();
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_NotMatch
        #void testAssertCallerFormName_NotMatch()
        #{
        #    Args        args            = new Args();
        #
        #    str         formName        = formstr(SysUserInfo);
        #    Args        formRunArgs     = new Args(formName);
        #    FormRun     formRun         = classFactory.formRunClass(formRunArgs);
        #;
        #    args.caller(formRun);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formstr(SysUserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerFormName_Null
        #void testAssertCallerFormName_Null()
        #{
        #    Args    args;
        #    str     formName    = formstr(SysUserInfo);
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerFormName(args, formName);
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType
        #void testAssertCallerType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Ancestor
        #void testAssertCallerType_Ancestor()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classnum(SysTestAssert));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Empty
        #void testAssertCallerType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Interface
        #void testAssertCallerType_Interface()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertCallerType(args, classnum(SysTestable));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_NotMatch
        #void testAssertCallerType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classnum(FormRun));
        #}
      ENDSOURCE
      SOURCE #testAssertCallerType_Null
        #void testAssertCallerType_Null()
        #{
        #    Args    args;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertCallerType(args, classidget(this));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType
        #void testAssertEnumType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_Empty
        #void testAssertEnumType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_NotMatch
        #void testAssertEnumType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(LedgerTransType));
        #}
      ENDSOURCE
      SOURCE #testAssertEnumType_Null
        #void testAssertEnumType_Null()
        #{
        #    Args    args;
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertEnumType(args, enumnum(NoYes));
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Empty
        #void testAssertFormDatasource_Empty()
        #{
        #    Args        args    = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(args);
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Fail
        #void testAssertFormDatasource_Fail()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(args);
        #}
      ENDSOURCE
      SOURCE #testAssertFormDatasource_Null
        #void testAssertFormDatasource_Null()
        #{
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertFormDatasource(null);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord
        #void testAssertRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Empty
        #void testAssertRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Map
        #void testAssertRecord_Map()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record  = CustTrans::find(0);
        #;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecord(args, tablenum(CustTrans));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_MapEmpty
        #void testAssertRecord_MapEmpty()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record;
        #;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, tablenum(CustTrans));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_NotMatch
        #void testAssertRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertRecord_Null
        #void testAssertRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecord(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists
        #void testAssertRecordExists()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(false);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_Empty
        #void testAssertRecordExists_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_NotMatch
        #void testAssertRecordExists_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testAssertRecordExists_Null
        #void testAssertRecordExists_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::assertRecordExists(args, record.TableId);
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType
        #void testCheckCallerType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Ancestor
        #void testCheckCallerType_Ancestor()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classnum(SysTestAssert)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Empty
        #void testCheckCallerType_Empty()
        #{
        #    Args    args    = new Args();
        #;
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Interface
        #void testCheckCallerType_Interface()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertTrue(ArgsUtil::checkCallerType(args, classnum(SysTestable)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_NotMatch
        #void testCheckCallerType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.caller(this);
        #
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classnum(FormRun)));
        #}
      ENDSOURCE
      SOURCE #testCheckCallerType_Null
        #void testCheckCallerType_Null()
        #{
        #    Args    args;
        #;
        #    this.assertFalse(ArgsUtil::checkCallerType(args, classidget(this)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType
        #void testCheckEnumType()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.assertTrue(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_Empty
        #void testCheckEnumType_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_NotMatch
        #void testCheckEnumType_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(LedgerTransType)));
        #}
      ENDSOURCE
      SOURCE #testCheckEnumType_Null
        #void testCheckEnumType_Null()
        #{
        #    Args    args;
        #;
        #    this.assertFalse(ArgsUtil::checkEnumType(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord
        #void testCheckRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Empty
        #void testCheckRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Map
        #void testCheckRecord_Map()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record  = CustTrans::find(0);
        #;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecord(args, tablenum(CustTrans)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_MapEmpty
        #void testCheckRecord_MapEmpty()
        #{
        #    Args            args    = new Args();
        #    CustVendTrans   record;
        #;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecord(args, tablenum(CustTrans)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_NotMatch
        #void testCheckRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecord(args, tablenum(UserGroupInfo)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecord_Null
        #void testCheckRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.assertFalse(ArgsUtil::checkRecord(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists
        #void testCheckRecordExists()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_Empty
        #void testCheckRecordExists_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_NotMatch
        #void testCheckRecordExists_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, tablenum(UserGroupInfo)));
        #}
      ENDSOURCE
      SOURCE #testCheckRecordExists_Null
        #void testCheckRecordExists_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.assertFalse(ArgsUtil::checkRecordExists(args, record.TableId));
        #}
      ENDSOURCE
      SOURCE #testEnum
        #void testEnum()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(NoYes));
        #    args.parmEnum(NoYes::Yes);
        #
        #    // as Integers!
        #    this.assertEquals(0+NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_Empty
        #void testEnum_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_NotMatch
        #void testEnum_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(LedgerTransType));
        #    args.parmEnum(LedgerTransType::Sales);
        #
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnum_Null
        #void testEnum_Null()
        #{
        #    Args    args;
        #;
        #    this.parmExceptionExpected(true);
        #    this.assertEquals(NoYes::Yes, ArgsUtil::enum(args, enumnum(NoYes)));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault
        #void testEnumDefault()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(SysModule));
        #    args.parmEnum(SysModule::Ledger);
        #
        #    // as Integers!
        #    this.assertEquals(0+SysModule::Ledger, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_Empty
        #void testEnumDefault_Empty()
        #{
        #    Args    args = new Args();
        #;
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_NotMatch
        #void testEnumDefault_NotMatch()
        #{
        #    Args    args    = new Args();
        #;
        #    args.parmEnumType(enumnum(LedgerTransType));
        #    args.parmEnum(LedgerTransType::Sales);
        #
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testEnumDefault_Null
        #void testEnumDefault_Null()
        #{
        #    Args    args;
        #;
        #    // as Integers!
        #    this.assertEquals(0+SysModule::System, ArgsUtil::enumOrDefault(args, SysModule::System));
        #}
      ENDSOURCE
      SOURCE #testRecord
        #void testRecord()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(bufCmp(record,ArgsUtil::record(args, record.TableId)));
        #}
      ENDSOURCE
      SOURCE #testRecord_Empty
        #void testRecord_Empty()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    //select firstOnly record;
        #    args.record(record);
        #
        #    this.assertTrue(bufCmp(record,ArgsUtil::record(args, record.TableId)));
        #}
      ENDSOURCE
      SOURCE #testRecord_NotMatch
        #void testRecord_NotMatch()
        #{
        #    Args        args    = new Args();
        #    UserInfo    record;
        #;
        #    select firstOnly record;
        #    args.record(record);
        #
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::record(args, tablenum(UserGroupInfo));
        #}
      ENDSOURCE
      SOURCE #testRecord_Null
        #void testRecord_Null()
        #{
        #    Args        args;
        #    UserInfo    record;
        #;
        #    this.parmExceptionExpected(true);
        #    ArgsUtil::record(args, record.TableId);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysQuery unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysQuery
    PROPERTIES
      Name                #SysQuery
      Extends             #Query
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #addRangeNzValue
        #// если value не пустой, добавляет критерий с value (включая коллекции), выполняет экранирование
        #// если value пустой, то ничего не делает, возвращает null
        #static QueryBuildRange addRangeNzValue(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange qbr;
        #    ;
        #
        #    if( value )
        #    {
        #        qbr = SysQuery::addRangeValue(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #addRangeNzValueNot
        #// если value не пустой, добавляет критерий с valueNot (включая коллекции), выполняет экранирование
        #// если value пустой, то ничего не делает, возвращает null
        #static QueryBuildRange addRangeNzValueNot(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange qbr;
        #    ;
        #
        #    if( value )
        #    {
        #        qbr = SysQuery::addRangeValueNot(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #addRangeNzValueRaw
        #// если value не пустой, добавляет критерий с value (включая коллекции), НЕ выполняет экранирование
        #// если value пустой, то ничего не делает, возвращает null
        #static QueryBuildRange addRangeNzValueRaw(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    str                     value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange qbr;
        #    ;
        #
        #    if( value )
        #    {
        #        qbr = SysQuery::addRangeValueRaw(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #addRangesFromCon
        #// добавить каждое значение контейнера как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromCon(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    container               con,
        #    RangeStatus             rangeStatus         = RangeStatus::Open,
        #    int                     oneRangeChunkSize   = 7)
        #{
        #    ConEnumerator   ce;
        #    container       chunk;
        #    ;
        #
        #    if( qbds && fieldId && con )
        #    {
        #        ce = ConEnumerator::construct(con);
        #        while (ce && ce.moveNext())
        #        {
        #            if( !SysQuery::isQueryValue(ce.current()) )
        #                continue;
        #
        #            chunk += ce.current();
        #            if( conlen(chunk) < oneRangeChunkSize )
        #                continue;
        #
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #            chunk = connull();
        #        }
        #
        #        if( chunk )
        #        {
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromEnumerator
        #// добавить каждое значение энумератора как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #
        #// TODO подумать как разбить энумератор произвольного типа на чанки
        #
        #static QueryBuildDataSource addRangesFromEnumerator(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    Enumerator              e,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    ;
        #
        #    if( qbds && fieldId )
        #    {
        #        while (e && e.moveNext())
        #        {
        #            SysQuery::addRangeValue(qbds, fieldId, e.current(), rangeStatus);
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromKeyData
        #// Can't be an instance method because new queryRun() until takes a query!
        #static QueryBuildDataSource addRangesFromKeyData(
        #    QueryBuildDataSource    qbds,
        #    KeyData                 keyData     // Must be a unique list of values!
        #    )
        #{
        #    Map                     keyDataMap;
        #    MapEnumerator           me;
        #
        #    // A local a method is used because the a variable can change type for each while loop
        #    anytype a()
        #    {
        #        anytype a;
        #        [a] = me.currentValue();
        #        return a;
        #    }
        #    //Only do Map::create() when container has at least 4 parameters. version,domain type,
        #    //range type and size
        #    if (conlen(keyData) >= 4)
        #    {
        #        keyDataMap = Map::create(keyData);
        #
        #        me = keyDataMap.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            qbds.addRange(me.currentKey()).value(queryValue(a()));
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromList
        #// добавить каждое значение списка как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromList(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    List                    list,
        #    RangeStatus             rangeStatus         = RangeStatus::Open,
        #    int                     oneRangeChunkSize   = 7)
        #{
        #    ListEnumerator le;
        #    List chunk;
        #    ;
        #
        #    if( qbds && fieldId && list )
        #    {
        #        le = list.getEnumerator();
        #        while (le && le.moveNext())
        #        {
        #            if( !SysQuery::isQueryValue(le.current()) )
        #                continue;
        #
        #            chunk = ListUtil::add(chunk, le.current());
        #            if( chunk.elements() < oneRangeChunkSize )
        #                continue;
        #
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #            chunk = null;
        #        }
        #
        #        if( chunk )
        #        {
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangesFromQbds
        #// копирует критерии из датасорса.
        #// не удаляет и не изменяет уже установленные критерии
        #//
        #// чтобы заменить существующие и добавить новые, используйте mergeRangesFromQbds
        #public static QueryBuildDataSource addRangesFromQbds(QueryBuildDataSource dest, QueryBuildDataSource source)
        #{
        #    return SysQuery::mergeRangeValuesFromQbds_Impl(dest, source, true);
        #}
      ENDSOURCE
      SOURCE #addRangesFromSet
        #// добавить каждое значение множества как отдельный range
        #// полезно для большого количества значений, когда все они не помещаются в одну строку
        #//
        #// чтобы заменить все критерии по полю, используйте qbds.clearRange(fieldId) перед вызовом этого метода
        #static QueryBuildDataSource addRangesFromSet(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    Set                     set,
        #    RangeStatus             rangeStatus         = RangeStatus::Open,
        #    int                     oneRangeChunkSize   = 7)
        #{
        #    SetEnumerator   se;
        #    List chunk;
        #    ;
        #
        #    if( qbds && fieldId && set )
        #    {
        #        se = set.getEnumerator();
        #        while (se && se.moveNext())
        #        {
        #            if( !SysQuery::isQueryValue(se.current()) )
        #                continue;
        #
        #            chunk = ListUtil::add(chunk, se.current());
        #            if( chunk.elements() < oneRangeChunkSize )
        #                continue;
        #
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #            chunk = null;
        #        }
        #
        #        if( chunk )
        #        {
        #            SysQuery::addRangeValue(qbds, fieldId, chunk, rangeStatus);
        #        }
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
      SOURCE #addRangeValue
        #// добавляет критерий с value (включая коллекции), выполняет экранирование
        #static QueryBuildRange addRangeValue(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    str                 valueStr;
        #    ;
        #
        #    if( qbds && fieldId && SysQuery::isQueryValue(value) )
        #    {
        #        qbr = qbds.addRange(fieldId);
        #        if( qbr )
        #        {
        #            valueStr = SysQuery::value(value);
        #            qbr.value(valueStr);
        #            qbr.status(rangeStatus);
        #        }
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #addRangeValueNot
        #// добавляет критерий с valueNot (включая коллекции), выполняет экранирование
        #static QueryBuildRange addRangeValueNot(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    str                 valueStr;
        #    ;
        #
        #    if( qbds && fieldId && SysQuery::isQueryValue(value) )
        #    {
        #        qbr = qbds.addRange(fieldId);
        #        if( qbr )
        #        {
        #            valueStr = SysQuery::valueNot(value);
        #            qbr.value(valueStr);
        #            qbr.status(rangeStatus);
        #        }
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #addRangeValueRaw
        #// добавляет критерий с value (включая коллекции), НЕ выполняет экранирование
        #static QueryBuildRange addRangeValueRaw(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    str                     value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    ;
        #
        #    if( qbds && fieldId && SysQuery::isQueryValue(value) )
        #    {
        #        qbr = qbds.addRange(fieldId);
        #        if( qbr )
        #        {
        #            qbr.value(value);
        #            qbr.status(rangeStatus);
        #        }
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #clearAllRanges
        #// удаляет все range по одному полю или все в qbds
        #public static void clearAllRanges(QueryBuildDataSource qbds, FieldId fieldId = 0)
        #{
        #    QueryBuildRange    qbr;
        #
        #    if( qbds )
        #    {
        #        if( fieldId )
        #        {
        #            do
        #            {
        #                qbds.clearRange(fieldId);
        #            }
        #            while(qbds.findRange(fieldId));
        #        }
        #        else
        #        {
        #            qbds.clearRanges();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #findGroupByField
        #//mazzy 05.02.2020
        #public static QueryGroupByField findGroupByField(
        #    Query                   _query,
        #    QueryBuildDataSource    _qbds,
        #    fieldId                 _fieldId)
        #{
        #    int                 groupFields;
        #    int                 i;
        #    QueryGroupByField   queryGroupByField;
        #;
        #
        #    if (_query && _qbds)
        #    {
        #        groupFields = _query.groupByFieldCount();
        #        for (i=1; i <= groupFields; ++i)
        #        {
        #            queryGroupByField = _query.groupByField(i);
        #
        #            if (queryGroupByField
        #                && queryGroupByField.fieldID() == _fieldId
        #                && queryGroupByField.dataSource().table() == _qbds.table())
        #            {
        #                break;
        #            }
        #        }
        #    }
        #
        #    return queryGroupByField;
        #}
      ENDSOURCE
      SOURCE #findOrCreateGroupByField
        #//mazzy 05.02.2020
        #public static QueryGroupByField findOrCreateGroupByField(Query _query, QueryBuildDataSource _queryBuildDataSource, fieldId _fieldId)
        #{
        #    QueryGroupByField    queryGroupByField;
        #
        #    if (_query && _queryBuildDataSource)
        #    {
        #        queryGroupByField = SysQuery::findGroupByField(_query, _queryBuildDataSource, _fieldId);
        #
        #        if (!queryGroupByField)
        #        {
        #            queryGroupByField = _queryBuildDataSource.addGroupByField(_fieldId);
        #        }
        #    }
        #
        #    return queryGroupByField;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRange
        #public static QueryBuildRange findOrCreateRange(QueryBuildDataSource _queryBuildDataSource, fieldId _fieldId)
        #{
        #    QueryBuildRange queryBuildRange;
        #
        #    if (_queryBuildDataSource)
        #    {
        #        queryBuildRange = _queryBuildDataSource.findRange(_fieldId);
        #
        #        if (!queryBuildRange && _fieldId)
        #        {
        #            queryBuildRange = _queryBuildDataSource.addRange(_fieldId);
        #        }
        #    }
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRangeValue
        #// mazzy 03.12.2019
        #// сразу устанавливает value (включая контейнер), выполняет экранирование
        #// пустое значение не изменяет критерий! чтобы очистить, используйте .findOrCreateRange(...).Value(SysQuery::valueUnlimited())
        #public static QueryBuildRange findOrCreateRangeValue(
        #    QueryBuildDataSource    _queryBuildDataSource,
        #    fieldId                 _fieldId,
        #    Anytype                 _value)
        #{
        #    QueryBuildRange     queryBuildRange     = SysQuery::findOrCreateRange(_queryBuildDataSource, _fieldId);
        #    str                 strValue;
        #    ;
        #
        #    if (queryBuildRange && SysQuery::isQueryValue(_value))
        #    {
        #        strValue = SysQuery::value(_value);
        #
        #        // 08.08.2021 попробуем посмотреть как много фильтров превышает диапазон.
        #        // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #        ExtendedTypeUtil::isLengthEnoughOrWarning(extendedTypeNum(Range), strlen(strValue));
        #
        #        queryBuildRange.value(strValue);
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRangeValueNot
        #// mazzy 03.12.2019
        #// сразу устанавливает value (включая контейнер), выполняет экранирование
        #// пустое значение не изменяет критерий! чтобы очистить, используйте .findOrCreateRange(...).Value(SysQuery::valueUnlimited())
        #public static QueryBuildRange findOrCreateRangeValueNot(
        #    QueryBuildDataSource    _queryBuildDataSource,
        #    fieldId                 _fieldId,
        #    Anytype                 _value)
        #{
        #    QueryBuildRange     queryBuildRange     = SysQuery::findOrCreateRange(_queryBuildDataSource, _fieldId);
        #    str                 strValue;
        #    ;
        #
        #    if (queryBuildRange && SysQuery::isQueryValue(_value))
        #    {
        #        strValue = SysQuery::valueNot(_value);
        #
        #        if( strValue )
        #        {
        #            // 08.08.2021 попробуем посмотреть как много фильтров превышает диапазон.
        #            // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #            ExtendedTypeUtil::isLengthEnoughOrWarning(extendedTypeNum(Range), strlen(strValue));
        #
        #            queryBuildRange.value(strValue);
        #        }
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRangeValueRaw
        #// mazzy 03.12.2019
        #// сразу устанавливает value (включая контейнер), НЕ выполняет экранирование
        #// любое значение изменяет критерий!
        #public static QueryBuildRange findOrCreateRangeValueRaw(
        #    QueryBuildDataSource    _queryBuildDataSource,
        #    fieldId                 _fieldId,
        #    str                     _strValue,
        #    boolean                 _usingExtendedQuery_MRC     = false)
        #{
        #    QueryBuildRange     queryBuildRange     = SysQuery::findOrCreateRange(_queryBuildDataSource, _fieldId);
        #    ;
        #
        #    if (queryBuildRange)
        #    {
        #        // 08.08.2021 попробуем посмотреть как много фильтров превышает диапазон.
        #        // сообщите smazurkin@mercury.ru, если у вас появилось это сообщение
        #        ExtendedTypeUtil::isLengthEnoughOrWarning(extendedTypeNum(Range), strlen(_strValue));
        #
        #        queryBuildRange.value(_strValue);
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #firstOnlyN
        #public static void firstOnlyN(QueryRun qr, int n, int startFrom = 1)
        #{
        #    if( qr && n )
        #    {
        #        qr.enablePositionPaging(true);
        #        qr.addPageRange(startFrom, n);
        #    }
        #}
      ENDSOURCE
      SOURCE #isQueryValue
        #// возвращает true, если значение (кроме пустой строки) будет преобразовано в непустое queryValue
        #// возвращает false, если значение является null или содержит другие значения, которые не будут обработаны методом SysQuery::value()
        #public static boolean isQueryValue(anytype value)
        #{
        #    boolean ret = false;
        #    Types type = typeof(value);
        #
        #    switch (type)
        #    {
        #        case Types::String:
        #        case Types::RString:
        #        case Types::VarString:
        #        case Types::Enum:
        #        case Types::Integer:
        #        case Types::Int64:
        #        case Types::Real:
        #        case Types::Date:
        #        case Types::UtcDateTime:
        #        case Types::Time:
        #        case Types::Guid:
        #            ret = true;
        #            break;
        #
        #        case Types::Container:
        #            if( value )
        #            {
        #                ret = true;
        #            }
        #            break;
        #
        #        case Types::Class:
        #            ret = ObjectUtil::isEnumerable(value);
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #mergeRangeValuesFromQbds
        #// реализация: заменяет и добавляет значения критериев из датасорса.
        #// не копирует link и dynalink
        #
        #// используйте addRangesFromQbds или mergeRangesFromQbds
        #public static QueryBuildDataSource mergeRangeValuesFromQbds(
        #    QueryBuildDataSource    dest,
        #    QueryBuildDataSource    source)
        #{
        #    return SysQuery::mergeRangeValuesFromQbds_Impl(dest, source, false);
        #}
      ENDSOURCE
      SOURCE #mergeRangeValuesFromQbds_Impl
        #// реализация: заменяет и добавляет значения критериев из датасорса.
        #// не копирует link и dynalink
        #
        #// используйте addRangesFromQbds или mergeRangesFromQbds
        #protected static QueryBuildDataSource mergeRangeValuesFromQbds_Impl(
        #    QueryBuildDataSource    dest,
        #    QueryBuildDataSource    source,
        #    boolean                 addSameFieldRange   = false)
        #{
        #    QueryBuildRange     sourceRange;
        #    QueryBuildRange     destRange;
        #    int                 i;
        #    ;
        #
        #    if (source && dest && source.table() == dest.table())
        #    {
        #        for (i = 1; i <= source.rangeCount(); i++)
        #        {
        #            sourceRange = source.range(i);
        #            if (sourceRange && sourceRange.value())
        #            {
        #                if (!addSameFieldRange)
        #                {
        #                    dest.clearRange(sourceRange.field());
        #                }
        #                destRange = dest.addRange(sourceRange.field());
        #                if (destRange)
        #                {
        #                    destRange.value(sourceRange.value());
        #                    destRange.enabled(sourceRange.enabled());
        #                    destRange.status(sourceRange.status());
        #                }
        #            }
        #        }
        #    }
        #
        #    return dest;
        #}
      ENDSOURCE
      SOURCE #query
        #// mazzy 26.12.2019
        #//
        #// @see TableUtil::select()
        #// @see RecordUtil::select()
        #public static Query query(
        #    TableId     _tableId,
        #    FieldId     _fieldId    = 0,
        #    Anytype     _value      = null)
        #{
        #    Query                   q       = new Query();
        #    QueryBuildDataSource    qbds    = q.addDataSource(_tableId);
        #    ;
        #
        #    if (_fieldId && qbds && !prmisdefault(_value))
        #    {
        #        SysQuery::findOrCreateRangeValue(qbds, _fieldId, _value);
        #    }
        #
        #    return q;
        #}
      ENDSOURCE
      SOURCE #queryRun
        #// mazzy 26.12.2019
        #public static QueryRun queryRun(
        #    TableId     _tableId,
        #    FieldId     _fieldId    = 0,
        #    Anytype     _value      = null)
        #{
        #    Query       q   = SysQuery::query(_tableId, _fieldId, _value);
        #    QueryRun    qr  = new QueryRun(q);
        #    ;
        #
        #    return qr;
        #}
      ENDSOURCE
      SOURCE #setRangeValue
        #// заменяет критерий с value (включая коллекции), выполняет экранирование
        #//
        #// в отличие от findOrCreate сперва удаляет все критерии перед установкой нового значения.
        #// если в качестве value передать null, то просто удалит критерии, не создавая новых
        #static QueryBuildRange setRangeValue(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    ;
        #
        #    if( qbds && fieldId )
        #    {
        #        SysQuery::clearAllRanges(qbds, fieldId);
        #
        #        qbr = SysQuery::addRangeValue(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #setRangeValueNot
        #// заменяет критерий с valueNot (включая коллекции), выполняет экранирование
        #//
        #// в отличие от findOrCreate сперва удаляет все критерии перед установкой нового значения.
        #// если в качестве value передать null, то просто удалит критерии, не создавая новых
        #static QueryBuildRange setRangeValueNot(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    anytype                 value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    ;
        #
        #    if( qbds && fieldId )
        #    {
        #        SysQuery::clearAllRanges(qbds, fieldId);
        #
        #        qbr = SysQuery::addRangeValueNot(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #setRangeValueRaw
        #// заменяет критерий с value (включая коллекции), НЕ выполняет экранирование
        #//
        #// в отличие от findOrCreate сперва удаляет все критерии перед установкой нового значения.
        #// если в качестве value передать null, то просто удалит критерии, не создавая новых
        #static QueryBuildRange setRangeValueRaw(
        #    QueryBuildDataSource    qbds,
        #    FieldId                 fieldId,
        #    str                     value,
        #    RangeStatus             rangeStatus     = RangeStatus::Open)
        #{
        #    QueryBuildRange     qbr;
        #    ;
        #
        #    if( qbds && fieldId )
        #    {
        #        SysQuery::clearAllRanges(qbds, fieldId);
        #
        #        qbr = SysQuery::addRangeValueRaw(qbds, fieldId, value, rangeStatus);
        #    }
        #
        #    return qbr;
        #}
      ENDSOURCE
      SOURCE #take
        #// получить из запроса n записей, начиная со startFrom
        #public static QueryRun take(Query q, int n, int startFrom = 1)
        #{
        #    QueryRun qr = new QueryRun(q);
        #    ;
        #
        #    qr = QueryRunUtil::take(qr, n, startFrom);
        #
        #    return qr;
        #}
      ENDSOURCE
      SOURCE #value
        #public static str value(anytype a)
        #{
        #    str quotableStr = ' *",.()\\';
        #    str s;
        #    int t;
        #
        #    TextBuffer text;
        #    Enumerator e;
        #
        #    str doEscape(str s1)
        #    {
        #        int i = 1;
        #        int pos;
        #        int len = strlen(s1);
        #        str result;
        #        pos = strfind(s1, quotableStr, i, len - i + 1);
        #        while (pos)
        #        {
        #            result += substr(s1, i, pos - i) + '\\' + substr(s1, pos, 1);
        #            i = pos + 1;
        #            if (i<=len)
        #                pos = strfind(s1, quotableStr, i, len - i + 1);
        #            else
        #                pos = 0;
        #        }
        #
        #        if (i == 1)
        #            return s1;
        #
        #        if (i<=len)
        #            result += substr(s1, i, len - i + 1);
        #
        #        return result;
        #    }
        #
        #    t = typeof(a);
        #    switch (t)
        #    {
        #        case Types::Enum:
        #            return enum2Value(a);
        #        case Types::Real:
        #            return num2str(a,0,16,1,0);
        #        case Types::Date:
        #        case Types::UtcDateTime:
        #            return strfmt('\"%1\"',a);  // must be double quotes
        #        case
        #            Types::String,
        #            Types::RString,
        #            Types::VarString:
        #        {
        #            s = a;
        #            if (!s)
        #                return SysQuery::valueEmptyString();
        #            return strfmt('%1',doEscape(s));  // must be double quotes
        #        }
        #        //mazzy 03.12.2019 -->
        #        case Types::Container:
        #        case Types::Class:
        #            e = CollectionUtil::getEnumerator(a);
        #
        #            while( e && e.moveNext() )
        #            {
        #                text = TextBufferUtil::appendCollectionItem(text, SysQuery::value(e.current()), ',');
        #            }
        #
        #            s = TextBufferUtil::getText(text);
        #
        #            return s;
        #       //mazzy 03.12.2019 <--
        #    }
        #    // <GEEU>
        #
        #    // to avoid stack trace on unsupported value 'null'
        #    if (! new DictEnum(enumnum(Types)).value2Symbol(t))
        #        return SysQuery::valueUnlimited();
        #
        #        // </GEEU>
        #    return strfmt('%1',a);
        #}
      ENDSOURCE
      SOURCE #valueNot
        #public static str valueNot(anytype a)
        #{
        #    str         ret;
        #    Enumerator  e       = EnumeratorUtil::getEnumerator(a);
        #    TextBuffer  text    = new TextBuffer();
        #    str         sep     = '';
        #    str         s;
        #    ;
        #
        #    while( e && e.moveNext() )
        #    {
        #        s = strfmt('%1!%2', sep, SysQuery::value(e.current()));
        #
        #        text = TextBufferUtil::appendStr(text, s);
        #
        #        sep = ',';
        #    }
        #
        #    ret = text.getText();
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysQueryTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysQueryTest
    PROPERTIES
      Name                #SysQueryTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysQueryTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testValue_Container
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_Container()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    str         range       = SysQuery::value(con);
        #    str         expected    = strfmt('%1,%2', InventLocationType::Quarantine, InventLocationType::Standard);
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
      SOURCE #testValue_List
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_List()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    List        list        = ListUtil::newFrom(con);
        #    str         range       = SysQuery::value(list);
        #    str         expected    = '1,0';
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
      SOURCE #testValue_Set
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValue_Set()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    Set         set         = SetUtil::newFrom(con);
        #    str         range       = SysQuery::value(set);
        #    str         expected    = '0,1';
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
      SOURCE #testValueNot_Container
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_Container()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    str         range       = SysQuery::valueNot(con);
        #    str         expected    = strfmt('!%1,!%2', InventLocationType::Quarantine, InventLocationType::Standard);
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
      SOURCE #testValueNot_List
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_List()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    List        list        = ListUtil::newFrom(con);
        #    str         range       = SysQuery::valueNot(list);
        #    str         expected    = '!1,!0';
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
      SOURCE #testValueNot_Set
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testValueNot_Set()
        #{
        #    container   con         = [InventLocationType::Quarantine, InventLocationType::Standard];
        #    Set         set         = SetUtil::newFrom(con);
        #    str         range       = SysQuery::valueNot(set);
        #    str         expected    = '!0,!1';
        #    ;
        #
        #    this.assertEquals(expected, range);
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: QueryRunUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #QueryRunUtil
    PROPERTIES
      Name                #QueryRunUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class QueryRunUtil
        #{
        #}
      ENDSOURCE
      SOURCE #getByName
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Common getByName(QueryRun qr, str dsName)
        #{
        #    Query                   q       = qr && dsName ? qr.query() : null;
        #    QueryBuildDataSource    qbds    = q ? q.dataSourceName(dsName) : null;
        #    Common                  ret;
        #
        #    if( qbds )
        #    {
        #        ret = qr.getNo(qbds.id());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #take
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// получить из запроса n записей, начиная со startFrom
        #public static QueryRun take(QueryRun qr, int n, int startFrom = 1)
        #{
        #    if( qr && n )
        #    {
        #        qr.enablePositionPaging(true);
        #        qr.addPageRange(startFrom, n);
        #    }
        #
        #    return qr;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: QueryUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #QueryUtil
    PROPERTIES
      Name                #QueryUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// это Util-класс, содержащий только статические методы
        #// нет смысла создавать объекты этого класса
        #abstract class QueryUtil
        #{
        #}
      ENDSOURCE
      SOURCE #hasRecord
        #public client server static boolean hasRecord(Query q)
        #{
        #    boolean ret = QueryUtil::hasRecordImpl(q.pack(false));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #hasRecordImpl
        #private server static boolean hasRecordImpl(container queryPack)
        #{
        #    boolean                 ret;
        #
        #    Query                   q       = new Query(queryPack);
        #    QueryBuildDataSource    qbds    = q.dataSourceNo(1);
        #    QueryBuildFieldList     qbfl;
        #    QueryRun                qr;
        #    ;
        #
        #    q.clearGroupBy();
        #    q.clearOrderBy();
        #
        #    qbds.update(false);
        #    qbds.sortClear();
        #    qbds.firstOnly(true);
        #
        #    qbfl = qbds.fields();
        #    qbfl.dynamic(false);
        #    qbfl.clearFieldList();
        #
        #    qbds.addSelectionField(fieldnum(Common,RecId));
        #
        #    qr = new QueryRun(q);
        #    if (qr && qr.next())
        #    {
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: QbdsUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #QbdsUtil
    PROPERTIES
      Name                #QbdsUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class QbdsUtil 
        #{
        #}
      ENDSOURCE
      SOURCE #childDataSourceTable
        #public static QueryBuildDataSource childDataSourceTable(QueryBuildDataSource parentQbds, tableId tableId, int occurrence = 1)
        #{
        #    QueryBuildDataSource ret;
        #    QueryBuildDataSource qbds;
        #    query q;
        #    int i;
        #    ;
        #
        #    for (i = 1; parentQbds && i <= parentQbds.childDataSourceCount(); i++)
        #    {
        #        qbds = parentQbds.childDataSourceNo(i);
        #
        #        if (qbds && qbds.table() == tableId)
        #        {
        #            occurrence--;
        #
        #            if( occurrence <= 0 )
        #            {
        #                ret = qbds;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #findOrCreateDataSource
        #public static QueryBuildDataSource findOrCreateDataSource(QueryBuildDataSource parentQbds, tableId tableId)
        #{
        #    QueryBuildDataSource qbds = QbdsUtil::childDataSourceTable(parentQbds, tableId);
        #    ;
        #
        #    if( !qbds )
        #    {
        #        qbds = parentQbds.addDataSource(tableId);
        #    }
        #
        #    return qbds;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SessionUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SessionUtil
    PROPERTIES
      Name                #SessionUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class SessionUtil
        #{
        #}
      ENDSOURCE
      SOURCE #clientSessionTable
        #public static server SysClientSessions clientSessionTable(int _sessionId = 0)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    SysClientSessions clientSessions;
        #    ;
        #
        #    new SkipAOSValidationPermission().assert();
        #
        #    //BP deviation documented
        #    clientSessions.skipAosValidation(true);
        #
        #    select clientSessions
        #    where clientSessions.SessionId == sessId;
        #
        #    return clientSessions;
        #}
      ENDSOURCE
      SOURCE #clientType
        #public static ClientType clientType(int _sessionId = 0)
        #{
        #    return SessionUtil::session().clientKind();
        #
        #}
      ENDSOURCE
      SOURCE #isInRoleAdmin
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает true если:
        #// пользователь наделен правами локального администратора
        #// и текущая сессия была запущена runAsAdministrator
        #//
        #public static boolean isInRoleAdmin()
        #{
        #    #define.CacheOwner('SessionFlags')
        #    #define.CacheKey('isInRoleAdmin')
        #
        #    boolean ret;
        #    anytype cached = classfactory.globalCache().get(#CacheOwner, #CacheKey, '');
        #
        #    if( typeof(cached) == Types::Integer )
        #    {
        #        ret = cached;
        #    }
        #    else
        #    {
        #        ret = SessionUtil::isInRoleAdmin_Slow();
        #
        #        classfactory.globalCache().set(#CacheOwner, #CacheKey, ret);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isInRoleAdmin_Slow
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает true если:
        #// пользователь наделен правами локального администратора
        #// и текущая сессия была запущена runAsAdministrator
        #//
        #// используйте метод isInRoleAdmin(), в котором выполняется кэширование
        #//
        #public static boolean isInRoleAdmin_Slow()
        #{
        #    anytype perm = new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    System.Security.Principal.WindowsIdentity    id = System.Security.Principal.WindowsIdentity::GetCurrent();
        #    System.Security.Principal.WindowsPrincipal   principal = new System.Security.Principal.WindowsPrincipal(id);
        #    System.Security.Principal.WindowsBuiltInRole admin = System.Security.Principal.WindowsBuiltInRole::Administrator;
        #
        #    boolean ret = principal.IsInRole(admin);
        #    ;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #serverSessionTable
        #public static server SysServerSessions serverSessionTable(int _sessionId = 0)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    SysClientSessions clientSessions;
        #    SysServerSessions serverSessions;
        #    ;
        #
        #    new SkipAOSValidationPermission().assert();
        #
        #    //BP deviation documented
        #    clientSessions.skipAosValidation(true);
        #    //BP deviation documented
        #    serverSessions.skipAosValidation(true);
        #
        #    select serverSessions
        #    exists join clientSessions
        #    where clientSessions.ServerId == serverSessions.ServerId
        #       && clientSessions.SessionId == sessId;
        #
        #    return serverSessions;
        #}
      ENDSOURCE
      SOURCE #session
        #public static Session session(int _sessionId = 0, boolean _checkSession = false)
        #{
        #    int sessId = _sessionId ? _sessionId : sessionid();
        #
        #    Session ret = new Session(sessId, _checkSession);
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: Timer unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Timer
    PROPERTIES
      Name                #Timer
      Extends             #SysStopWatch
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс с коротким и запоминающимся названием.
        #// Но у многих такой класс уже есть.
        #//
        #// Дополнительно к методу StartNew (как в .net-библиотеке)
        #// класс имеет StartNow (очень многие привыкли в аксапте писать именно так)
        #class Timer extends SysStopwatch
        #{
        #}
      ENDSOURCE
      SOURCE #toString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public str toString()
        #{
        #    return this.elapsed();
        #}
      ENDSOURCE
      SOURCE #construct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Timer construct()
        #{
        #    Timer timer = new Timer();
        #
        #    return timer;
        #}
        #
      ENDSOURCE
      SOURCE #startNew
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static Timer startNew()
        #{
        #    Timer timer = Timer::construct();
        #    ;
        #
        #    timer.start();
        #
        #    return timer;
        #}
      ENDSOURCE
      SOURCE #startNow
        #public static Timer startNow()
        #{
        #    Timer timer = Timer::construct();
        #    ;
        #
        #    timer.start();
        #
        #    return timer;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysStopWatch unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysStopWatch
    PROPERTIES
      Name                #SysStopWatch
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// класс обертка класса System.Diagnostics.Stopwatch
        #// см. https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch
        #//
        #// быстрый и эффективный класс:
        #// + не задействует метод new(), поэтому можно спокойно использовать classFactory.createClass() и другие фабрики
        #// + объекты создаются в памяти только по необходимости
        #// + минимум вычислений на X++, форматирование и преобразование в строку выполняется в .net
        #// + скрывает взаимодействие с CLR - программист может просто использовать X++ класс в своем коде
        #// + метод stopwatch() возвращает CLR-объект  - программист может получить доступ ко всей функциональности .net-объекта
        #// + метод toString() позволяет видеть время выполнения в отладчике
        #//
        #class SysStopwatch
        #{
        #    System.Diagnostics.Stopwatch stopwatch;
        #}
      ENDSOURCE
      SOURCE #elapsed
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает строку со временем выполнения в формате [-][d.]hh:mm:ss (без миллисекунд)
        #public str elapsed()
        #{
        #    str   ret;
        #    int64 ticks = this.elapsedTicks();
        #    int64 ticksPerSecond = 10000000; // https://docs.microsoft.com/en-us/dotnet/api/system.timespan.tickspersecond
        #
        #    if( ticks > ticksPerSecond )
        #    {
        #        ticks -= ticks mod ticksPerSecond;  // отбросим миллисекунды, если время больше секунды
        #    }
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    ret = System.TimeSpan::FromTicks(ticks).ToString();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedFormated
        #public str elapsedFormated(boolean _stop = false)
        #{
        #    System.TimeSpan ts;
        #    str             ret;
        #    ;
        #
        #    if (_stop)
        #    {
        #        this.stop();
        #    }
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    if (stopwatch)
        #    {
        #        ts = stopwatch.get_Elapsed();
        #    }
        #    else
        #    {
        #        ts = System.TimeSpan::FromTicks(0);
        #    }
        #
        #    if (ts)
        #    {
        #        ret = ts.ToString();
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedMilliseconds
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public int64 elapsedMilliseconds()
        #{
        #    int64 ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_ElapsedMilliseconds();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedTicks
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public int64 elapsedTicks()
        #{
        #    int64 ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_ElapsedTicks();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #elapsedWide
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// возвращает строку со временем выполнения в формате [-][d.]hh:mm:ss[.ffffff] (с миллисекундами)
        #public str elapsedWide()
        #{
        #    str ret;
        #    System.TimeSpan timespan;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    timespan = stopwatch.get_Elapsed();
        #
        #    ret = timespan.ToString();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #ensureInitialized
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #protected void ensureInitialized()
        #{
        #    if( !stopwatch )
        #    {
        #        stopwatch = new System.Diagnostics.Stopwatch();
        #    }
        #}
      ENDSOURCE
      SOURCE #init
        #protected void init()
        #{;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    if (stopwatch)
        #    {
        #        stopwatch = new System.Diagnostics.Stopwatch();
        #    }
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
      SOURCE #initAndStart
        #protected void initAndStart()
        #{;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    stopwatch = System.Diagnostics.Stopwatch::StartNew();
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
      SOURCE #isRunning
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public boolean isRunning()
        #{
        #    boolean ret;
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    ret = stopwatch.get_IsRunning();
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #new
        #protected void new(boolean startNow = false)
        #{
        #    if (startNow)
        #    {
        #        this.initAndStart();
        #    }
        #}
      ENDSOURCE
      SOURCE #reset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch reset()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Reset();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #start
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch start()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Start();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #stop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public SysStopwatch stop()
        #{
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    this.ensureInitialized();
        #
        #    stopwatch.Stop();
        #
        #    return this;
        #}
      ENDSOURCE
      SOURCE #stopPrintElapsed
        #public int64 stopPrintElapsed(boolean _formated = true, str _text = '')
        #{
        #    int64 ret;
        #    ;
        #
        #    this.stop();
        #
        #    ret = this.elapsedMilliseconds();
        #
        #    if (!_text)
        #    {
        #        _text = 'ELAPSED: ';
        #    }
        #
        #    if (_formated)
        #    {
        #        debug::printDebug(_text, this.elapsedFormated());
        #    }
        #    else
        #    {
        #        debug::printDebug(_text, ret, " MS");
        #    }
        #
        #    return ret;
        #
        #}
      ENDSOURCE
      SOURCE #stopwatch
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public System.Diagnostics.Stopwatch stopwatch()
        #{
        #    this.ensureInitialized();
        #
        #    return stopwatch;
        #}
      ENDSOURCE
      SOURCE #toString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public str toString()
        #{
        #    return this.elapsed();
        #}
      ENDSOURCE
      SOURCE #construct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #public static SysStopwatch construct()
        #{
        #    return new SysStopwatch();
        #}
        #
      ENDSOURCE
      SOURCE #contruct
        #public static SysStopWatch contruct(boolean startNow = false)
        #{
        #    return new SysStopWatch(startNow);
        #}
      ENDSOURCE
      SOURCE #startNew
        #public static SysStopwatch startNew()
        #{
        #    return SysStopwatch::construct().start();
        #}
        #
      ENDSOURCE
      SOURCE #startNow
        #public static SysStopwatch startNow()
        #{
        #    return SysStopwatch::construct().start();
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysStopWatchTest unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysStopWatchTest
    PROPERTIES
      Name                #SysStopWatchTest
      Extends             #SysTestCase
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #class SysStopwatchTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testConstruct
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testConstruct()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertTrue(SysDictClass::is(stopwatch, classnum(SysStopwatch)));
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testConstruct_False
        #void testConstruct_False()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct(false);
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(SysDictClass::is(sysStopWatch, classnum(SysStopWatch)));
        #    this.assertFalse(sysStopWatch.isRunning());
        #
        #}
      ENDSOURCE
      SOURCE #testConstruct_True
        #void testConstruct_True()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct(true);
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(SysDictClass::is(sysStopWatch, classnum(SysStopWatch)));
        #    this.assertTrue(sysStopWatch.isRunning());
        #
        #}
      ENDSOURCE
      SOURCE #testElapsed
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsed()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsed();
        #
        #    this.assertTrue(match(@'^:d:d\::d:d\::d:d$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testElapsed_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsed_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertEquals('00:00:00', stopwatch.elapsed());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted
        #void testElapsedFormatted()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertEquals('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted_Start
        #void testElapsedFormatted_Start()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedFormatted_StartNew
        #void testElapsedFormatted_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual('00:00:00', sysStopWatch.elapsedFormated());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedMilliseconds()
        #{
        #    SysStopwatch sysStopWatch = SysStopWatch::startNew();
        #    int64 zero = 0;
        #;
        #    sleep(50);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedMilliseconds_NotStarted()
        #{
        #    SysStopwatch sysStopWatch = SysStopWatch::construct();
        #    int64 zero = 0;
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertEquals(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_Start
        #void testElapsedMilliseconds_Start()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #    int64           zero = 0;
        #;
        #    sysStopWatch.start();
        #    sleep(100);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedMilliseconds_StartNew
        #void testElapsedMilliseconds_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #    int64           zero = 0;
        #;
        #    sleep(100);
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertNotEqual(zero, sysStopWatch.elapsedMilliseconds());
        #}
      ENDSOURCE
      SOURCE #testElapsedWideFormat
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedWideFormat()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsedWide();
        #
        #    this.assertTrue(match(@'^:d:d\::d:d\::d:d\.:d+$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testElapsedWideFormat_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testElapsedWideFormat_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertEquals('00:00:00', stopwatch.elapsedWide());
        #}
      ENDSOURCE
      SOURCE #testIsReset
        #void testIsReset()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.reset();
        #}
      ENDSOURCE
      SOURCE #testIsReset_startNew
        #void testIsReset_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.reset();
        #}
      ENDSOURCE
      SOURCE #testIsRunning
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    sleep(50);
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Immediately
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Immediately()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Reset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Reset()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    stopwatch.reset();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Start
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Start()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartNew
        #void testIsRunning_StartNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    this.assertNotNull(sysStopWatch);
        #    this.assertTrue(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartReset
        #void testIsRunning_StartReset()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #    sysStopWatch.reset();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertFalse(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_StartStop
        #void testIsRunning_StartStop()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #    sysStopWatch.stop();
        #
        #    this.assertNotNull(sysStopWatch);
        #    this.assertFalse(sysStopWatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testIsRunning_Stop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testIsRunning_Stop()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testReset
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testReset()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.reset();
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testReset_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testReset_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #    int64 zero = 0;
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStart
        #void testStart()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::contruct();
        #;
        #    sysStopWatch.start();
        #}
      ENDSOURCE
      SOURCE #testStart_startNew
        #void testStart_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.start();
        #}
      ENDSOURCE
      SOURCE #testStartNew
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStartNew()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #
        #    this.assertNotNull(stopwatch);
        #    this.assertTrue(SysDictClass::is(stopwatch, classnum(SysStopwatch)));
        #    this.assertTrue(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStop()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.stop();
        #
        #    this.assertNotEqual(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testStop_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #    int64 zero = 0;
        #
        #    sleep(50);
        #    stopwatch.stop();
        #
        #    this.assertEquals(zero, stopwatch.elapsedMilliseconds());
        #    this.assertFalse(stopwatch.isRunning());
        #}
      ENDSOURCE
      SOURCE #testStop_startNew
        #void testStop_startNew()
        #{
        #    SysStopWatch    sysStopWatch = SysStopWatch::startNew();
        #;
        #    sysStopWatch.stop();
        #}
      ENDSOURCE
      SOURCE #testToString
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::startNew();
        #    str elapsed;
        #
        #    sleep(50);
        #    elapsed = stopwatch.elapsed();
        #
        #    this.assertTrue(match(@':d:d\::d:d\::d:d$', elapsed), elapsed);
        #}
      ENDSOURCE
      SOURCE #testToString_NotStarted
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #void testToString_NotStarted()
        #{
        #    SysStopwatch stopwatch = SysStopwatch::construct();
        #
        #    this.assertEquals('00:00:00', stopwatch.toString());
        #}
      ENDSOURCE
      SOURCE #testToString_StartNew
        #void testToString_StartNew()
        #{
        #    SysStopWatch    sysStopWatch    = SysStopWatch::startNew();
        #    str             pattern         = @'^\d\d:\d\d:\d\d(\.\d+)?$';
        #    str             s;
        #    System.Text.RegularExpressions.Match regExpMatch;
        #;
        #    sleep(100);
        #
        #    s = sysStopWatch.toString();
        #
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    regExpMatch = System.Text.RegularExpressions.Regex::Match(s, pattern);
        #
        #    this.assertTrue(regExpMatch && regExpMatch.get_Success(), strfmt('"%1" does not match "%2"', s, pattern));
        #
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: PrevCurr unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #PrevCurr
    PROPERTIES
      Name                #PrevCurr
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// https://github.com/mazzy-ax/SysUtil
        #//
        #// Класс текущее и предыдущее значение,
        #// позволяет в цикле определить, что текущее значение отличается от предыдущего.
        #// Отлично работает и на первой итерации, когда предыдущего значения еще нет.
        #//
        #// Пример использования:
        #//
        #// container con = [1,1,2,2,3,3,3,2];
        #// Enumerator e = ConUtil::getEnumerator(con);
        #// PrevCurr prevCurr = PrevCurr::construct();
        #//
        #// while( e && e.moveNext() )
        #// {
        #//     if( prevCurr.isChanged(e.current()) )
        #//     {
        #//         info(strfmt("%1", e.current()));
        #//     }
        #// }
        #//
        #// Пример выведет в инфолог: 1,2,3,2
        #//
        #class PrevCurr
        #{
        #    Any current;
        #    Any previous;
        #}
      ENDSOURCE
      SOURCE #current
        #// сюда можно передать параметр любого типа, включая объект типа Any
        #public anytype current(anytype newCurrent = null)
        #{
        #    anytype ret;
        #
        #    if( !prmIsDefault(newCurrent) )
        #    {
        #        previous = current;
        #        current = Any::construct(newCurrent);
        #    }
        #
        #    if( current )
        #    {
        #        ret = current.value();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #isChanged
        #// устанавливает newCurrent, если newCurrent был передан как параметр
        #// возвращает true, если текущее значение (current) отличается от предыдущего
        #// возвращает true, если и предыдущее, и текущее не были установлены ни разу
        #// возвращает false, если текущее значение совпадает с предыдущим
        #//
        #// параметром можно передать параметр любого типа, включая объект типа Any
        #public boolean isChanged(anytype newCurrent = null)
        #{
        #    boolean ret;
        #
        #    if( !prmisdefault(newCurrent) )
        #    {
        #        this.current(newCurrent);
        #    }
        #
        #    ret = !Any::isEqual(current, previous);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #prev
        #// сюда можно передать параметр любого типа, включая объект типа Any
        #public anytype prev(anytype newPrev = null)
        #{
        #    anytype ret;
        #
        #    if( !prmIsDefault(newPrev) )
        #    {
        #        previous = Any::construct(newPrev);
        #    }
        #
        #    if( previous )
        #    {
        #        ret = previous.value();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #reset
        #public void reset()
        #{
        #    previous = null;
        #    current = null;
        #}
      ENDSOURCE
      SOURCE #construct
        #public static PrevCurr construct()
        #{
        #    return new PrevCurr();
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: FormRunUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #FormRunUtil
    PROPERTIES
      Name                #FormRunUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// Класс обслуживает значения с типом FormRun
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class FormRunUtil
        #{
        #}
      ENDSOURCE
      SOURCE #args
        #public static Args args(FormRun formRun)
        #{
        #    Args ret;
        #
        #    if( formRun )
        #    {
        #        ret = formRun.args();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: FormControlUtil unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #FormControlUtil
    PROPERTIES
      Name                #FormControlUtil
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #//
        #// Класс обслуживает значения с типом FormControl
        #//
        #// Util-класс реализует только статические методы.
        #// не содержит внутри никаких значений.
        #// не имеет смысла создавать экземпляр этого класса.
        #//
        #abstract class FormControlUtil
        #{
        #}
      ENDSOURCE
      SOURCE #classesWithMadatoryMethod
        #static container classesWithMadatoryMethod()
        #{
        #    container ret = [
        #            classnum(FormStringControl),
        #            classnum(FormRealControl),
        #            classnum(FormIntControl),
        #            classnum(FormInt64Control),
        #            classnum(FormDateControl),
        #            classnum(FormDateTimeControl),
        #            classnum(FormTimeControl),
        #            classnum(FormGuidControl)
        #    ];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #enabled
        #static boolean enabled(
        #    FormControl formControl,
        #    boolean     enabled = true)
        #{
        #    boolean ret;
        #
        #    if (formControl)
        #    {
        #        if( prmisdefault(enabled) )
        #        {
        #            ret = formControl.enabled();
        #        }
        #        else
        #        {
        #            ret = formControl.enabled(enabled);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #hasMandatoryMethod
        #static boolean hasMandatoryMethod(FormControl formControl)
        #{
        #    boolean ret = ObjectUtil::isOneOf(formControl, FormControlUtil::classesWithMadatoryMethod());
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #madatory
        #static boolean madatory(
        #    FormControl     formControl,
        #    boolean         mandatory   = false)
        #{
        #    Object obj = ObjectUtil::asOneOf(formControl, FormControlUtil::classesWithMadatoryMethod());
        #    boolean ret;
        #    ;
        #
        #    if( obj )
        #    {
        #        // мы убедились, что объект имеет тип, у которого есть метод mandatory
        #        // поэтому выполняем вызов произвольного метода через object (позднее связывание)
        #        if( prmisdefault(mandatory) )
        #        {
        #            ret = obj.mandatory();
        #        }
        #        else
        #        {
        #            ret = obj.mandatory(mandatory);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #setVisibleAndEnabled
        #//VSHis 07.04.2020
        #static void setVisibleAndEnabled(
        #    FormControl _formControl,
        #    boolean     _visible,
        #    boolean     _enabled)
        #{
        #    ;
        #
        #    if (_formControl)
        #    {
        #        _formControl.visible(_visible);
        #        _formControl.enabled(_enabled);
        #    }
        #}
      ENDSOURCE
      SOURCE #visible
        #static boolean visible(
        #    FormControl formControl,
        #    boolean     visible = true)
        #{
        #    boolean ret;
        #
        #    if (formControl)
        #    {
        #        if( prmisdefault(visible) )
        #        {
        #            ret = formControl.visible();
        #        }
        #        else
        #        {
        #            ret = formControl.visible(visible);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: PRN

; Microsoft Dynamics AX Project : SysUtil unloaded
; --------------------------------------------------------------------------------
  PROJECTVERSION 2
  
  PROJECT #SysUtil
   SHARED
  PROPERTIES
    Name                #SysUtil
  ENDPROPERTIES
  
    PROJECTCLASS ProjectNode
    GROUP #Error
      PROPERTIES
        Name                #Error
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 123
        NODETYPE 329
        NAME #Error
      ENDNODE
      ENDGROUP
      
    GROUP #Any
      PROPERTIES
        Name                #Any
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50009
        NODETYPE 329
        NAME #Any
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50010
        NODETYPE 329
        NAME #AnyTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50011
        NODETYPE 329
        NAME #AnytypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Types
      PROPERTIES
        Name                #Types
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50028
        NODETYPE 329
        NAME #DictTypeUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50034
        NODETYPE 329
        NAME #ExtendedTypeUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50092
        NODETYPE 329
        NAME #TypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #CLR
      PROPERTIES
        Name                #CLR
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50020
        NODETYPE 329
        NAME #ClrTypeUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Str
      PROPERTIES
        Name                #Str
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50068
        NODETYPE 329
        NAME #StrUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50069
        NODETYPE 329
        NAME #StrUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50087
        NODETYPE 329
        NAME #TextBufferUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50088
        NODETYPE 329
        NAME #TextBufferUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50089
        NODETYPE 329
        NAME #TextUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50090
        NODETYPE 329
        NAME #TextUtilTest
      ENDNODE
      ENDGROUP
      
    GROUP #Collection
      PROPERTIES
        Name                #Collection
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50021
        NODETYPE 329
        NAME #CollectionUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50016
        NODETYPE 329
        NAME #ArrayUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50017
        NODETYPE 329
        NAME #ArrayUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50023
        NODETYPE 329
        NAME #ConUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50024
        NODETYPE 329
        NAME #ConUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50040
        NODETYPE 329
        NAME #ListUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50041
        NODETYPE 329
        NAME #ListUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50061
        NODETYPE 329
        NAME #SetUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50062
        NODETYPE 329
        NAME #SetUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50063
        NODETYPE 329
        NAME #StackUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50067
        NODETYPE 329
        NAME #StructUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50047
        NODETYPE 329
        NAME #MapUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50045
        NODETYPE 329
        NAME #MapOfSets
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50046
        NODETYPE 329
        NAME #MapOfSetsTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50043
        NODETYPE 329
        NAME #MapOfLists
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50044
        NODETYPE 329
        NAME #MapOfListsTest
      ENDNODE
      ENDGROUP
      
    GROUP #Enumerator
      PROPERTIES
        Name                #Enumerator
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50031
        NODETYPE 329
        NAME #EnumeratorUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50032
        NODETYPE 329
        NAME #EnumeratorUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50029
        NODETYPE 329
        NAME #EEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50060
        NODETYPE 329
        NAME #SetEEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50039
        NODETYPE 329
        NAME #ListEEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50042
        NODETYPE 329
        NAME #MapEEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50015
        NODETYPE 329
        NAME #ArrayEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50022
        NODETYPE 329
        NAME #ConEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50030
        NODETYPE 329
        NAME #EnumEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50049
        NODETYPE 329
        NAME #OneValueEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50054
        NODETYPE 329
        NAME #RecordEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50065
        NODETYPE 329
        NAME #StrSplitEnumerator
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50066
        NODETYPE 329
        NAME #StrSplitEnumeratorTest
      ENDNODE
      ENDGROUP
      
    GROUP #Class
      PROPERTIES
        Name                #Class
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      GROUP #Standard
        PROPERTIES
          Name                #Standard
          ProjectGroupType    #All
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 5434
          NODETYPE 329
          NAME #SysDictionary
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 1568
          NODETYPE 329
          NAME #SysDictClass
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 982
          NODETYPE 329
          NAME #SysDictEnum
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 935
          NODETYPE 329
          NAME #SysDictTable
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 641
          NODETYPE 329
          NAME #SysDictField
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 5313
          NODETYPE 329
          NAME #SysDictMethod
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 978
          NODETYPE 329
          NAME #SysDictType
        ENDNODE
        ENDGROUP
        
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50019
        NODETYPE 329
        NAME #ClassUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50025
        NODETYPE 329
        NAME #DictClassUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50048
        NODETYPE 329
        NAME #ObjectUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Record
      PROPERTIES
        Name                #Record
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50086
        NODETYPE 329
        NAME #TableUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50027
        NODETYPE 329
        NAME #DictTableUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50058
        NODETYPE 329
        NAME #RecordUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50059
        NODETYPE 329
        NAME #RecordUtilTest
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50056
        NODETYPE 329
        NAME #RecordList
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50057
        NODETYPE 329
        NAME #RecordMap
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50073
        NODETYPE 329
        NAME #SysRecordInsertList
      ENDNODE
      ENDGROUP
      
    GROUP #Field
      PROPERTIES
        Name                #Field
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50026
        NODETYPE 329
        NAME #DictFieldUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50036
        NODETYPE 329
        NAME #FieldUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50055
        NODETYPE 329
        NAME #RecordFieldUtil
      ENDNODE
      ENDGROUP
      
    GROUP #Misc
      PROPERTIES
        Name                #Misc
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      GROUP #Args
        PROPERTIES
          Name                #Args
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50013
          NODETYPE 329
          NAME #ArgsUtil
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50014
          NODETYPE 329
          NAME #ArgsUtilTest
        ENDNODE
        ENDGROUP
        
      GROUP #Query
        PROPERTIES
          Name                #Query
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 2881
          NODETYPE 329
          NAME #SysQuery
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50071
          NODETYPE 329
          NAME #SysQueryTest
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50052
          NODETYPE 329
          NAME #QueryRunUtil
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50053
          NODETYPE 329
          NAME #QueryUtil
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50051
          NODETYPE 329
          NAME #QbdsUtil
        ENDNODE
        ENDGROUP
        
      GROUP #Session
        PROPERTIES
          Name                #Session
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50008
          NODETYPE 329
          NAME #SessionUtil
        ENDNODE
        ENDGROUP
        
      GROUP #Timer
        PROPERTIES
          Name                #Timer
          ProjectGroupType    #Classes
          GroupMask           #
          PreventEditProperties #No
        ENDPROPERTIES
        
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50091
          NODETYPE 329
          NAME #Timer
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50076
          NODETYPE 329
          NAME #SysStopWatch
        ENDNODE
        BEGINNODE
          FILETYPE 0
          UTILTYPE 45
          UTILOBJECTID 50077
          NODETYPE 329
          NAME #SysStopWatchTest
        ENDNODE
        ENDGROUP
        
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50050
        NODETYPE 329
        NAME #PrevCurr
      ENDNODE
      ENDGROUP
      
    GROUP #Form
      PROPERTIES
        Name                #Form
        ProjectGroupType    #Classes
        GroupMask           #
        PreventEditProperties #No
      ENDPROPERTIES
      
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50038
        NODETYPE 329
        NAME #FormRunUtil
      ENDNODE
      BEGINNODE
        FILETYPE 0
        UTILTYPE 45
        UTILOBJECTID 50037
        NODETYPE 329
        NAME #FormControlUtil
      ENDNODE
      ENDGROUP
      
  ENDPROJECT
  

***Element: END

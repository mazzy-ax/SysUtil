//
// https://github.com/mazzy-ax/SysUtil
//
// Util-класс реализует только статические методы.
// не содержит внутри никаких значений.
// не имеет смысла создавать экземпляр этого класса.
//
abstract class ConUtil
{

    public static container add(container con, anytype collectionOrValue)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);

        while( e && e.moveNext() )
        {
            con += e.current(); // ядро бросит исключение, если тип значения не может быть помещен в контейнер
        }

        return con;
    }

    public static boolean contains(container con, anytype value)
    {
        boolean ret = (confind(con, value) != 0);

        return ret;
    }

    public static boolean containsAll(container con, anytype collection)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        boolean ret = true; // любой контейнер содержит пустую коллекцию

        while( ret && e && e.moveNext() )
        {
            ret = ret && (confind(con, e.current()) != 0);
        }

        return ret;
    }

    public static FormRun conView(container con, str caption = '', boolean lookup = false)
    {
        return conView(con, caption, lookup);
    }

    public static int countAs(container con, Types type)
    {
        int ret;
        int len = conlen(con);
        int i;

        for( i=1 ; i<=len ; i++ )
        {
            if( typeof(conpeek(con,i)) == type )
            {
                ret++;
            }
        }

        return ret;
    }

    public static int countValue(container con, anytype value)
    {
        int ret;
        int len = conlen(con);
        int i;

        for( i=1 ; i<=len ; i++ )
        {
            if( conpeek(con,i) == value )
            {
                ret++;
            }
        }

        return ret;
    }

    public static container delete(container con, int start, int number)
    {
        container ret = condel(con, start, number);

        return ret;
    }

    // возвращает новый контейнер, в котором присутствуют только уникальные объекты (дубли удалены)
    public static container distinct(anytype collection)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        container ret;

        while( e && e.moveNext() )
        {
            if( !confind(ret, e.current()) )
            {
                ret += e.current();
            }
        }

        return ret;
    }

    public static container drop(container con, int n = 1)
    {
        container ret;
        int i;
        int len = conlen(con);

        for( i=n; i<=len; i++ )
        {
            ret += conpeek(con, 1);
        }

        return ret;
    }

    public static int find(container con, anytype element)
    {
        int ret = confind(con, element);

        return ret;
    }

    public static anytype first(container con)
    {
        anytype ret = conpeek(con, 1);

        return ret;
    }

    public static ConEnumerator getEnumerator(container con)
    {
        ConEnumerator ret = ConEnumerator::construct(con);

        return ret;
    }

    public static anytype head(container con)
    {
        anytype ret = ConUtil::first(con);

        return ret;
    }

    public static boolean in(anytype value, container con)
    {
        boolean ret = (confind(con, value) != 0);

        return ret;
    }

    public static container insert(container con, int start, anytype element)
    {
        container ret = conins(con, start, element);

        return ret;
    }

    public static boolean isEmpty(container con)
    {
        if( con )
        {
            return false;
        }

        return true;
    }

    public static boolean isNotEmpty(container con)
    {
        if( con )
        {
            return true;
        }

        return false;
    }

    public static anytype last(container con)
    {
        int lastPos = conlen(con);
        anytype ret = conpeek(con, lastPos);

        return ret;
    }

    public static int len(container con)
    {
        int ret = conlen(con);

        return ret;
    }

    // проверяет есть ли вхожение паттерна в какую-нибудь строку внутри контейнера
    // проверку выполняет рекурсивно
    public static boolean match(
        str         pattern,
        container   con)
    {
        int     len     = conlen(con);
        int     i;
        Any     value;

        for( i=1; i<=len; ++i )
        {
            value = Any::conpeek(con, i);

            switch( value.type() )
            {
                case Types::String:
                case Types::RString:
                case Types::VarString:
                    if( match(pattern, value.asString()) )
                        return true;
                    break;

                case Types::Container:
                    if( ConUtil::match(pattern, value.asContainer()) )
                        return true;
                    break;

                case Types::Record:
                    if( RecordUtil::match(pattern, value.asRecord()) )
                        return true;
                    break;

                default:
                    break;
            }
        }

        return false;
    }

    public static anytype maxAs(container con, Types type)
    {
        anytype ret;
        int len = conlen(con);
        int i;

        for( i=1 ; i<=len ; i++ )
        {
            if( typeof(conpeek(con,i)) == type )
            {
                if( typeof(ret) == AnytypeUtil::undefined() )
                {
                    ret = conpeek(con, i);
                }
                else
                {
                    ret = max(ret, conpeek(con, i));
                }
            }
        }

        return ret;
    }

    // возвращает максимум элементов, тип которых совпадает с типом второго параметра
    //
    // метод удобно использовать, передавая как второй параметр переменную,
    // в которую будете разместите результат
    //
    // пример использования:
    //     container con = [1, 'test', 2, 3.01];
    //     int maxValue = ConUtil::maxAs(con, maxValue); // метод вернет 2
    //
    public static anytype maxAsValue(container con, anytype valueWithType)
    {
        Types type = typeof(valueWithType);
        anytype ret = ConUtil::maxAs(con, type);

        return ret;
    }

    public static anytype maxCon(container con)
    {
        anytype ret = conpeek(con, 1);
        Types type = typeof(ret);
        int len = conlen(con);
        int i;

        for( i=2; i<=len; i++ )
        {
            if( typeof(conpeek(con, i)) == type )
            {
                ret = max(ret, conpeek(con, i));
            }
        }

        return ret;
    }

    public static anytype minAs(container con, Types type)
    {
        anytype ret;
        int len = conlen(con);
        int i;

        for( i=1 ; i<=len ; i++ )
        {
            if( typeof(conpeek(con,i)) == type )
            {
                if( typeof(ret) == Types::AnyType )
                {
                    ret = conpeek(con, i);
                }
                else
                {
                    ret = min(ret, conpeek(con, i));
                }
            }
        }

        return ret;
    }

    // возвращает минимум элементов, тип которых совпадает с типом второго параметра
    //
    // метод удобно использовать, передавая как второй параметр переменную,
    // в которую будете разместите результат
    //
    // пример использования:
    //     container con = [1, 'test', 2, 3.01];
    //     int minValue = ConUtil::minAs(con, minValue); // метод вернет 1
    //
    public static anytype minAsValue(container con, anytype valueWithType)
    {
        Types type = typeof(valueWithType);
        anytype ret = ConUtil::minAs(con, type);

        return ret;
    }

    public static anytype minCon(container con)
    {
        anytype ret = conpeek(con, 1);
        Types type = typeof(ret);
        int len = conlen(con);
        int i;

        for( i=2; i<=len; i++ )
        {
            if( typeof(conpeek(con, i)) == type )
            {
                ret = min(ret, conpeek(con, i));
            }
        }

        return ret;
    }

    public static container newFrom(anytype collection)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collection);
        container con;

        while( e && e.moveNext() )
        {
            con += e.current();
        }

        return con;
    }

    public static container newFromArray(Array array)
    {
        container ret;
        int i;

        for( i=1; array && i<=array.lastIndex(); ++i )
        {
            ret += array.value(i);
        }

        return ret;
    }

    public static container newFromBlob(container blob)
    {
        return ContainerClass::blob2Container(blob);
    }

    public static container newFromBuf(Common buffer)
    {
        // первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        container ret = [buffer.TableId, buffer];
        ;

        return ret;
    }

    public static container newFromList(List list)
    {
        ListEnumerator le = ListUtil::getEnumerator(list);
        container ret;

        while( le && le.moveNext() )
        {
            ret += le.current();
        }

        return ret;
    }

    public static container newFromMap(Map map)
    {
        container ret;
        MapEnumerator me = MapUtil::getEnumerator(map);

        while( me && me.moveNext() )
        {
            ret += [[me.currentKey(), me.currentValue()]];
        }

        return ret;
    }

    public static container newFromSet(Set set)
    {
        SetEnumerator se = SetUtil::getEnumerator(set);
        container ret;

        while( se && se.moveNext() )
        {
            ret += se.current();
        }

        return ret;
    }

    public static container newFromStr(str s, str sep = ',', int maxSubstrings = 0)
    {
        Enumerator e = StrSplitEnumerator::construct(s, sep, maxSubstrings);
        container ret;

        while( e && e.moveNext() )
        {
            ret += e.current();
        }

        return ret;
    }

    public static container newFromXml(XmlNode node)
    {
        return Global::containerFromXMLNode(node);
    }

    public static anytype peekAs(container con, int idx, Types type, int potentialAncestorId = 0)
    {
        anytype ret = AnytypeUtil::as(conpeek(con, idx), type, potentialAncestorId);

        return ret;
    }

    public static container peekAsContainer(container con, int idx)
    {
        container ret = AnytypeUtil::asContainer(conpeek(con, idx));

        return ret;
    }

    public static Date peekAsDate(container con, int idx)
    {
        Date ret = AnytypeUtil::asDate(conpeek(con, idx));

        return ret;
    }

    public static UtcDateTime peekAsDateTime(container con, int idx)
    {
        utcdatetime ret = AnytypeUtil::asDateTime(conpeek(con, idx));

        return ret;
    }

    public static anytype peekAsEnum(container con, int idx, enumId enumId = 0)
    {
        anytype ret = AnytypeUtil::asEnum(conpeek(con, idx), enumId);

        return ret;
    }

    public static GUID peekAsGUID(container con, int idx)
    {
        GUID ret = AnytypeUtil::asGUID(conpeek(con, idx));

        return ret;
    }

    public static int peekAsInt(container con, int idx)
    {
        int ret = AnytypeUtil::asInt(conpeek(con, idx));

        return ret;
    }

    public static Int64 peekAsInt64(container con, int idx)
    {
        Int64 ret = AnytypeUtil::asInt64(conpeek(con, idx));

        return ret;
    }

    public static Real peekAsReal(container con, int idx)
    {
        Real ret = AnytypeUtil::asInt(conpeek(con, idx));

        return ret;
    }

    public static int64 peekAsRecId(container con, int idx)
    {
        Int64 ret = AnytypeUtil::asRecId(conpeek(con, idx));

        return ret;
    }

    public static Common peekAsRecord(container con, int idx, TableId tableId = 0)
    {
        Common ret = AnytypeUtil::asRecord(conpeek(con, idx), tableId);

        return ret;
    }

    public static anytype peekAsValue(container con, int idx, anytype asValue)
    {
        anytype ret = AnytypeUtil::asValue(conpeek(con, idx), asValue);

        return ret;
    }

    public static container poke(container con, int start, anytype value)
    {
        container ret = conpoke(con, start, value);

        return ret;
    }

    // возвращает контейнер, в котором содержатся элементы, равные value
    public static container ratainAll(container con, anytype value)
    {
        container ret;
        ConEnumerator ce = ConEnumerator::construct(con);

        while( ce && ce.moveNext() )
        {
            if( value == ce.current() )
            {
                ret += value;
            }
        }

        return ret;
    }

    public static container remove(container con, anytype value)
    {
        int i = confind(con, value);

        if( i )
        {
            con = condel(con, i, 1);
        }

        return con;
    }

    public static container removeAll(container con, anytype value)
    {
        int i;

        do
        {
            i = confind(con, value);
            if( i )
            {
                con = condel(con, i, 1);
            }
        }
        while( i );

        return con;
    }

    public static container removeAllEnumerator(container con, Enumerator e)
    {
        container ret = con;

        while( e && e.moveNext() )
        {
            ret = ConUtil::removeAll(ret, e.current());
        }

        return con;
    }

    // возвращает новый контейнер, в котором удалены все пустые элементы
    public static container removeEmpty(anytype collectionOrValue)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);
        container ret;

        while( e && e.moveNext() )
        {
            if( e.current() )
            {
                ret += e.current(); // ядро бросит исключение, если тип значения не может быть помещен в контейнер
            }
        }

        return ret;
    }

    public static container retainAllByEnumerator(container con, Enumerator e)
    {
        container ret = con;

        while( e && e.moveNext() )
        {
            ret = ConUtil::removeAll(ret, e.current());
        }

        return con;
    }

    public static anytype sumAs(container con, Types type)
    {
        anytype ret;
        ConEnumerator ce = ConEnumerator::construct(con);

        while( ce && ce.moveNext() )
        {
            if( typeof(ce.current()) == type )
            {
                ret += ce.current();
            }
        }

        return ret;
    }

    public static str sumAsStr(container con)
    {
        str ret;
        ConEnumerator ce = ConEnumerator::construct(con);

        while( ce && ce.moveNext() )
        {
            if( AnytypeUtil::isString(ce.current()) )
            {
                ret += ce.current();
            }
        }

        return ret;
    }

    public static anytype sumAsValue(container con, anytype valueWithType)
    {
        Types type = typeof(valueWithType);
        anytype ret = ConUtil::sumAs(con, type);

        return ret;
    }

    public static anytype sumCon(container con)
    {
        anytype ret = conpeek(con, 1);
        int len = conlen(con);
        int i;

        for( i=2 ; i<=len ; i++ )
        {
            ret += conpeek(con, i);
        }

        return ret;
    }

    public static container tail(container con)
    {
        container ret = ConUtil::take(con, conlen(con), 2);

        return ret;
    }

    public static container take(container con, int n = 1, int startFrom = 1)
    {
        container ret;

        int len     = conlen(con);
        int i       = max(0, startFrom);
        int lastPos = min(i+n-1, len);

        while( i<=lastPos )
        {
            ret += conpeek(con, i);
            i++;
        }

        return ret;
    }

    public static Array toArray(container con)
    {
        Array ret = ArrayUtil::newFromCon(con);

        return ret;
    }

    public static container toBlob(container con)
    {
        ContainerClass containerClass = new ContainerClass(con);

        return containerClass.toBlob();
    }

    public static Common toBuf(container con)
    {
        TableId tableId;
        Common ret;
        ;

        // первый элемент - для совместимости с Global:buf2con(), и Global::con2Buf()
        // возможны проблемы, если после создания container таблица изменена в AOT.
        // метод работает очень быстро.
        [tableId, ret] = con;

        Debug::assert(tableId == ret.TableId);

        return ret;
    }

    public static List toList(container con, List list = null)
    {
        Any any;
        int i;
        int len = conlen(con);

        for( i=1; i<=len; ++i )
        {
            any = Any::conpeek(con, i);

            if( !list )
            {
                list = new List(any.type());
            }

            if( any.type() == list.typeId() )
            {
                list.addEnd(any.value());
            }
        }

        return list;
    }

    public static Set toSet(container con, Set set = null)
    {
        Any any;
        int i;
        int len = conlen(con);

        for( i=1; i<=len; ++i )
        {
            any = Any::conpeek(con, i);

            if( !set )
            {
                set = new Set(any.type());
            }

            if( any.type() == set.typeId() )
            {
                set.add(conpeek(con, i));
            }
        }

        return set;
    }

    public static str toStr(container con, str sep = ',')
    {
        str ret = TextBufferUtil::appendContainer(null, con, sep).getText();

        return ret;
    }

    public static str toXmlString(container con, int indent = 0)
    {
        return Global::XMLString(con, types::Container, indent);
    }

    // возвращает
    //   Types::void - если контейнер пуст
    //   Types::AnyType - если в контейнере содержатся элементы разного типа
    //   Types::* - если все элементы одного типа
    public static Types typeofAll(container con)
    {
        Types type = Types::void;
        ConEnumerator ce = ConEnumerator::construct(con);

        if( ce && ce.moveNext() )
        {
            type = typeof(ce.current());
        }

        while( ce && ce.moveNext() )
        {
            if( type != typeof(ce.current()) )
            {
                return Types::AnyType;
            }
        }

        return type;
    }

    public static container zip(container con1, container con2, int maxElements = 0)
    {
        container   ret;
        int         minLen = min(conlen(con1), conlen(con2));
        int         idx;

        if( maxElements && maxElements < minLen )
        {
            minLen = maxElements;
        }

        for (idx = 1; idx <= minlen; idx++)
        {
            ret += conpeek(con1, idx) + conpeek(con2, idx);
        }

        return ret;
    }
}
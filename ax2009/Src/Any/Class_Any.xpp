//
// https://github.com/mazzy-ax/SysUtil
//
// класс содержит неизменяемое значение любого типа
// чтобы переприсвоить значение, создайте новый объект этого типа
//
// Чем отличается этот класс от Anytype и от SysAnyType?
// 1.
// Аксапта позволяет установить произвольное значение в переменную типа anytype только один раз.
// Во время первой инициализации тип переменной фиксируется, в дальнейшем тип изменить нельзя.
//
// Anytype var = 1;
// var = 2;         // ok
// var = '';        // результат не определен. В большинстве версий аксапты будет 0;
//
// 2.
// Чтобы обойти эту проблему в Аксапту ввели тип SysAnyType
// SysAnyType позволяет в любой момент установить действительно любое значение.
// Но ради этого тип сделали очень тяжелым - в куче хранится map, key и сам объект в качестве value
// кроме того, каждое обращение к value - это lookup внутри map
//
// SysAnyType var = new SysAnyType(1);
// var.value('');   // будет хранить пустую строку
//
// 3.
// Данный класс Any не позволяет изменять значение хранимого объекта.
// Поэтому данный класс может просто хранить ref на объект произвольного типа
// Но! переприсвоить значение можно просто пересоздав объект Any
//
// Any var = new Any(1);        // ok
// var = new Any('');           // ok
//
// у Any есть несколько специализированных конструкторов и обычный construct
//
// Any var = Any::constuct(1);  // ok
// var = Any::constuct('');     // ok
//
// Класс проявляется в цикле (обратите внимание на специализированный конструктор conpeek)
//
// container con = [1, '', 31\01\2019];
// Any var;
// for(i=1; i<=conlen(con); ++i)
// {
//     var = Any::conpeek(con, i);
// }
class Any
{
    Anytype value;

    // перенести в SysTextBuffer
    // рекурсивно заполняет textBuffer
    protected textBuffer addToTextBuffer(  str          _sep                        = ',',
                                           boolean      _queryValue                 = false,
                                           boolean      _usingExtendedQuery_MRC     = false,
                                           TextBuffer   _textBuffer                 = null)
    {
        Types   type    = typeof(value);
        int     i;
        int     len;
        str     s;
    ;

        if (_textBuffer == null)
        {
            _textBuffer = new TextBuffer();
        }

        switch(type)
        {
            case Types::Container:
                len = conlen(value);
                for(i=1; i<=len; ++i)
                {
                    if(i>1)
                    {
                        _textBuffer.appendText(_sep);
                    }
                    _textBuffer = Any::conpeek(value, i).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
                }
                break;

            case Types::Class:
                if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(Set)))
                {
                    _textBuffer = Any::construct(ConUtil::newFromSet(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
                    break;
                }
                else if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(List)))
                {
                    _textBuffer = Any::construct(ConUtil::newFromList(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
                    break;
                }
                else if (SysDictClass::isEqualOrSuperclass(classidget(value), classnum(Array)))
                {
                    _textBuffer = Any::construct(ConUtil::newFromArray(value)).addToTextBuffer(_sep, _queryValue, _usingExtendedQuery_MRC, _textBuffer);
                    break;
                }
                // no break! проваливаемся ниже
            case Types::Record:
            case Types::AnyType:
            case Types::BLOB:
            case Types::void:
                throw error(Error::unsupportedEnum(funcname(), type));

            default:
                s = _queryValue ? SysQuery::value_MRC(value) : AnytypeUtil::toString(value);
                _textBuffer.appendText(s);
                break;
        }

        return _textBuffer;
    }

    public anytype as(Types type, int potentialAncestorId = 0)
    {
        return AnytypeUtil::as(this.value(), type, potentialAncestorId);
    }

    public Array asArray()
    {
        return AnytypeUtil::asArray(this.value());
    }

    public Object asClass(ClassId potentialAncestorId = 0)
    {
        return AnytypeUtil::asClass(this.value(), potentialAncestorId);
    }

    public container asContainer()
    {
        return AnytypeUtil::asContainer(this.value());
    }

    public Date asDate()
    {
        return AnytypeUtil::asDate(this.value());
    }

    public UtcDateTime asDateTime()
    {
        return AnytypeUtil::asDateTime(this.value());
    }

    public anytype asEnum(enumId enumId = 0)
    {
        return AnytypeUtil::asEnum(this.value(), enumId);
    }

    public GUID asGUID()
    {
        return AnytypeUtil::asGUID(this.value());
    }

    public int asInt()
    {
        return AnytypeUtil::asInt(this.value());
    }

    public int64 asInt64()
    {
        return AnytypeUtil::asInt64(this.value());
    }

    public List asList()
    {
        return AnytypeUtil::asList(this.value());
    }

    public Map asMap()
    {
        return AnytypeUtil::asMap(this.value());
    }

    public Object asObject()
    {
        return AnytypeUtil::asObject(this.value());
    }

    public Real asReal()
    {
        return AnytypeUtil::asReal(this.value());
    }

    public int64 asRecId()
    {
        return AnytypeUtil::asRecId(this.value());
    }

    public Common asRecord(TableId tableId = 0)
    {
        return AnytypeUtil::asRecord(this.value(), tableId);
    }

    public int64 asRecVersion()
    {
        return AnytypeUtil::asRecVersion(this.value());
    }

    public Set asSet()
    {
        return AnytypeUtil::asSet(this.value());
    }

    public str asString()
    {
        return AnytypeUtil::asString(this.value());
    }

    public timeOfDay asTime()
    {
        return AnytypeUtil::asTime(this.value());
    }

    public anytype asValue(anytype asValue)
    {
        anytype ret = AnytypeUtil::as(this.value(), asValue);

        return ret;
    }

    public Any ensureEmpty()
    {
        if (this.value())
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        return this;
    }

    public Any ensureInTypes(container typeCon)
    {
        if (confind(typeCon, this.type()))
        {
            return this;
        }

        throw error(Error::wrongUseOfFunction(funcname()));
    }

    public Any ensureNotEmpty()
    {
        if (this.value())
        {
            return this;
        }

        throw error(Error::wrongUseOfFunction(funcname()));
    }

    public Any ensureType(Types type, int potentialAncestorId = 0)
    {
        if (AnytypeUtil::is(this.value(), type, potentialAncestorId))
        {
            return this;
        }

        throw error(Error::wrongUseOfFunction(funcname()));
    }

    public boolean equalsTo(Any type2)
    {
        //Is one of them null ?
        if (!type2)
        {
            return false;
        }

        //Are their types different ?
        if (this.type() != type2.type())
        {
            return false;
        }

        //They are the same type. Is this type void ?
        if (this.type() == Types::void)
        {
            return true;
        }

        //Are their values different ?
        if (this.value() != type2.value())
        {
            return false;
        }

        return true;
    }

    public int id()
    {
        int id = AnytypeUtil::Id(this.value());

        return id;
    }

    public boolean is(Types type, int potentialAncestorId = 0)
    {
        return AnytypeUtil::is(this.value(), type, potentialAncestorId);
    }

    public boolean isArray()
    {
        return AnytypeUtil::isArray(this.value());
    }

    public boolean isClass(int potentialAncestorId = 0)
    {
        return AnytypeUtil::isClass(potentialAncestorId);
    }

    // возвращает true для значения, для которого можно получить enumerator
    public boolean isCollection()
    {
        return EnumeratorUtil::isEnumerable(this.value());
    }

    public boolean isContainer()
    {
        return AnytypeUtil::isContainer(this.value());
    }

    // нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
    public boolean isEmpty()
    {
        if (this.value())
        {
            return false;
        }

        return true;
    }

    public boolean isEnum(enumId enumId = 0)
    {
        return AnytypeUtil::isEnum(this.value(), enumId);
    }

    // возвращает true для значения, для которого можно получить enumerator
    public boolean isEnumerable()
    {
        return EnumeratorUtil::isEnumerable(this.value());
    }

    // возвращает true для значения, для которого можно получить enumerator
    public boolean isEnumerator()
    {
        return EnumeratorUtil::isEnumerator(this.value());
    }

    public boolean isImplements(int interfaceId = 0)
    {
        return AnytypeUtil::isImplement(this.value(), interfaceId);
    }

    public boolean isInt()
    {
        return AnytypeUtil::isInt(this.value());
    }

    public boolean isInt64()
    {
        return AnytypeUtil::isInt(this.value());
    }

    public boolean isList()
    {
        return AnytypeUtil::isClass(classnum(List));
    }

    public boolean isMap()
    {
        return AnytypeUtil::isClass(classnum(Map));
    }

    // нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
    public boolean isNotEmpty()
    {
        if (this.value())
        {
            return true;
        }

        return false;
    }

    public boolean isRecId()
    {
        return AnytypeUtil::isRecId(this.value());
    }

    public boolean isRecord(int potentialAncestorId = 0)
    {
        return AnytypeUtil::isRecord(this.value(), potentialAncestorId);
    }

    public boolean isRecVersion()
    {
        return AnytypeUtil::isRecId(this.value());
    }

    public boolean isSet()
    {
        return AnytypeUtil::isClass(classnum(Set));
    }

    public boolean isString()
    {
        return AnytypeUtil::isString(this.value());
    }

    public boolean isValue(anytype isValue)
    {
        boolean ret = AnytypeUtil::isValue(this.value(), isValue);

        return ret;
    }

    void new(Anytype _value = null)
    {
        value = _value;
    }

    // @deprecated! используйте метод toQueryValue()
    //
    final public str queryValue(boolean _usingExtendedQuery_MRC = false)
    {
        return this.toQueryValue(_usingExtendedQuery_MRC);
    }

    // преобразовать value в соответствующий буфер, насколько это возможно
    public Common toBuf()
    {
        return AnytypeUtil::toBuf(this.value());
    }

    public anytype toNullValue()
    {
        return nullValueBaseType(this.type());
    }

    public str toQueryValue(boolean _usingExtendedQuery_MRC = false)
    {
        str ret;

        switch (this.type())
        {
            case Types::Class:
            case Types::Container:
                ret = this.addToTextBuffer(',', true, _usingExtendedQuery_MRC).getText();
                break;

            case Types::Record:
            case Types::AnyType:
            case Types::BLOB:
            case Types::void:
                throw error(Error::unsupportedEnum(funcname(), this.type()));

            default:
                ret = SysQuery::value_MRC(value,_usingExtendedQuery_MRC);
                break;
        }

        return ret;
    }

    public str toString(str sep = ',')
    {
        // поскольку этот метод может вызваться в отладчике еще до инициализации,
        // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        // и ни в коем случае не бросаем исключение на неинициализированные значения
        str ret = AnytypeUtil::toString(this.value(), sep);

        return ret;
    }

    final public Types type()
    {
        Types type = typeof(value);

        return type;
    }

    // только чтение! см. комментарий к classDeclaration
    final public AnyType value()
    {
        return value;
    }

    // принимает данные в контейнере, который состоит из контейнеров - значение и метка
    // выдает ошибки для всех пустых значений
    // если хотя бы одно значение пустое, то возвращает false
    // если все значения не пустые, то возвращает true
    //
    // пример использования:
    //     Any::checkAllNotEmpty([[purchId, 'Закупка'], [emplId, 'Ответственный']]);
    //
    public static boolean checkAllNotEmpty(container pairs, str txt = 'Значение не должно быть пустым. Укажите значение для %1.')
    {
        boolean     ret = true;

        container   pair;
        str         label;

        int         i;
        int         len = conlen(pairs);
        ;

        for (i=1; i<=len; ++i)
        {
            pair  = ConUtil::peekAsContainer(pairs, i);
            label = conpeek(pair, 2);

            if( !conpeek(pair, 1) )
            {
                ret = CheckFailed(strfmt(txt, label));
            }
        }

        return ret;
    }

    public static Any conpeek(container con, int idx)
    {
        anytype value   = conpeek(con, idx);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про контейнеры
        Any     ret     = Any::construct(value);

        return ret;
    }

    public static Any construct(Anytype value)
    {
        return new Any(value);
    }

    public static Any field(Common record, fieldId fieldid)
    {
        anytype value   = record.(fieldid);  // не делаем дополнительных проверок: к случае чего, аксапта выбросит исключение про поля в записи
        Any     ret     = Any::construct(value);

        return ret;
    }

    // TODO удалить
    public static boolean isEqual(Any type1, Any type2)
    {
        //Are both null ?
        if (!type1 && !type2)
        {
            return true;
        }

        //Is one of them null ?
        if (!type1 || !type2)
        {
            return false;
        }

        //Are their types different ?
        if (type1.type() != type2.type())
        {
            return false;
        }

        //They are the same type. Is this type void ?
        if (type1.type() == Types::void)
        {
            return true;
        }

        //Are their values different ?
        if (type1.value() != type2.value())
        {
            return false;
        }

        return true;
    }

    // mazzy CL006053 31.12.2019
    public static Set list2set(List _list)
    {
        Set set;
        ListEnumerator   le;

        if (_list)
        {
            set = new Set(_list.typeId());

            le = _list.getEnumerator();
            while (le.moveNext())
            {
                set.add(le.current());
            }
        }

        return set;
    }

    // mazzy CL006053 31.12.2019
    public static List set2list(Set _set)
    {
        List            list;
        SetEnumerator   se;

        if (_set)
        {
            list = new List(_set.typeId());

            se = _set.getEnumerator();
            while (se.moveNext())
            {
                list.addEnd(se.current());
            }
        }

        return list;
    }
}
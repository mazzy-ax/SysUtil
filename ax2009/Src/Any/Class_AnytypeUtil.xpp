//
// https://github.com/mazzy-ax/SysUtil
//
// Класс AnytypeUtil обслуживает значения типа anytype
//
// Util-класс реализует только статические методы.
// не содержит внутри никаких значений.
// не имеет смысла создавать экземпляр этого класса.
//
class AnytypeUtil
{

    public static anytype as(anytype value, Types type, int potentialAncestorId = 0)
    {
        if( AnytypeUtil::is(value, type, potentialAncestorId) )
        {
            return value;
        }

        return nullValueBaseType(type);
    }

    public static Array asArray(anytype value)
    {
        if( AnytypeUtil::isArray(value) )
        {
            return value;
        }

        return null;
    }

    public static Object asClass(anytype value, ClassId potentialAncestorId = 0)
    {
        if( typeof(value) == Types::Class )
        {
            if( potentialAncestorId )
            {
                return ObjectUtil::as(value, potentialAncestorId);
            }

            return value;
        }

        return null;
    }

    public static anytype asCollection(anytype value)
    {
        return EnumeratorUtil::asEnumerable(value);
    }

    public static container asContainer(anytype value)
    {
        if( typeof(value) == Types::Container )
        {
            return value;
        }

        return connull();
    }

    public static Date asDate(anytype value)
    {
        if( typeof(value) == Types::Date )
        {
            return value;
        }

        return DateNull();
    }

    public static UtcDateTime asDateTime(anytype value)
    {
        if( typeof(value) == Types::UtcDateTime )
        {
            return value;
        }

        return utcDateTimeNull();
    }

    public static anytype asEnum(anytype value, enumId enumId = 0)
    {
        return AnytypeUtil::as(value, Types::Enum, enumId);
    }

    public static anytype asEnumDefault(anytype value, anytype defaultEnumValue)
    {
        int enumId = AnytypeUtil::enumId(defaultEnumValue);

        if( enumId && AnytypeUtil::is(value, Types::Enum, enumId) )
        {
            return value;
        }

        return defaultEnumValue;
    }



    public static anytype asEnumerable(anytype value)
    {
        return EnumeratorUtil::asEnumerable(value);
    }

    public static anytype asEnumerator(anytype value)
    {
        return EnumeratorUtil::asEnumerator(value);
    }

    public static GUID asGUID(anytype value)
    {
        if( typeof(value) == Types::Guid )
        {
            return value;
        }

        return nullValueBaseType(Types::Guid);
    }

    public static int asInt(anytype value)
    {
        if( typeof(value) == Types::Integer )
        {
            return value;
        }

        return 0;
    }

    public static int64 asInt64(anytype value)
    {
        if( typeof(value) == Types::Int64 )
        {
            return value;
        }

        return 0;
    }

    public static List asList(anytype value)
    {
        if( AnytypeUtil::isList(value) )
        {
            return value;
        }

        return null;
    }

    public static Map asMap(anytype value)
    {
        if( AnytypeUtil::isMap(value) )
        {
            return value;
        }

        return null;
    }

    public static Object asObject(anytype value)
    {
        return AnytypeUtil::asClass(value);
    }

    public static Real asReal(anytype value)
    {
        if( typeof(value) == Types::Real )
        {
            return value;
        }

        return 0.0;
    }

    public static int64 asRecId(anytype value)
    {
        if( typeof(value) == Types::Int64 )
        {
            return value;
        }

        return 0;
    }

    public static Common asRecord(anytype value, TableId tableId = 0)
    {
        Common ret = AnytypeUtil::as(value, Types::Record, tableId);

        return ret;
    }

    public static int asRecVersion(anytype value)
    {
        if( typeof(value) == Types::Integer )
        {
            return value;
        }

        return 0;
    }

    public static anytype assertEmpty(anytype value)
    {
        if (value)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return value;
    }

    public static anytype assertNotEmpty(anytype value)
    {
        if (value)
        {
            return value;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

    public static anytype assertType(anytype value, Types type, int potentialAncestorId = 0)
    {
        if (AnytypeUtil::is(value, type, potentialAncestorId))
        {
            return value;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

    public static Set asSet(anytype value)
    {
        if( AnytypeUtil::isSet(value) )
        {
            return value;
        }

        return null;
    }

    public static Stack asStack(anytype value)
    {
        if( AnytypeUtil::isStack(value) )
        {
            return value;
        }

        return null;
    }

    public static str asString(anytype value)
    {
        if( AnytypeUtil::isString(value) )
        {
            return value;
        }

        return '';
    }

    public static Struct asStruct(anytype value)
    {
        if( AnytypeUtil::isStruct(value) )
        {
            return value;
        }

        return null;
    }

    public static timeOfDay asTime(anytype value)
    {
        if( typeof(value) == Types::Integer )
        {
            return value;
        }

        return 0;
    }

    public static anytype asValue(anytype value, anytype asValue)
    {
        Types   asType = typeof(asValue);
        Int     asId   = AnytypeUtil::id(asValue);
        anytype ret    = AnytypeUtil::as(value, asType, asId);

        return ret;
    }

    public static int classId(anytype value)
    {
        int id = 0;

        if( typeof(value) == Types::Class )
        {
            id = classidget(value);
        }

        return id;
    }

    public static int enumId(anytype value)
    {
        int id = 0;

        if( typeof(value) == Types::Enum )
        {
            id = DictEnum::value2id(value);
        }

        return id;
    }

    // возвращает объект, у которого можно вызвать метод moveNext
    public static Enumerator getEnumerator(anytype collectionOrValue)
    {
        Enumerator e = EnumeratorUtil::getEnumerator(collectionOrValue);

        return e;
    }

    public static int id(anytype value)
    {
        int   id   = 0;
        Types type = typeof(value);

        switch( type )
        {
            case Types::Enum:
                id = DictEnum::value2id(value);
                break;

            case Types::Record:
                id = AnytypeUtil::asRecord(value).TableId;
                break;

            case Types::Class:
                id = classidget(value);
                break;
        }

        return id;
    }

    public static boolean is(anytype value, Types type, int potentialAncestorId = 0)
    {
        Types t = typeof(value);

        if( potentialAncestorId )
        {
            switch( t )
            {
                case Types::Class:
                    return (type == t) && ObjectUtil::is(value, potentialAncestorId);

                case Types::Record:
                    return (type == t) && SysDictTable::is(value, potentialAncestorId);

                case Types::Integer:
                    switch( type )
                    {
                        case Types::Class:
                            return ObjectUtil::is(value, potentialAncestorId);

                        case Types::Record:
                            return SysDictTable::is(RecordUtil::makeRecord(value), potentialAncestorId);

                        case Types::UserType:
                            return DictTypeUtil::is(value, potentialAncestorId);

                        case Types::Enum:
                            return (potentialAncestorId == new DictType(value).enumId());
                    }
                    break;

                case Types::Enum:
                    return (type == t) && potentialAncestorId == DictEnum::value2id(value); // TODO равен ли? может ли быть enum от enum?
            }
        }

        if( type == t )
        {
            return true;
        }
        else if( TypeUtil::isString(t) )
        {
            // не строгое совпадение строковых типов поскольку все строки можно присвоить друг другу
            return true;
        }

        return false;
    }

    public static boolean isArray(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(Array));

        return ret;
    }

    public static boolean isClass(anytype value, int potentialAncestorId = 0)
    {
        boolean ret = AnytypeUtil::is(Types::Class, potentialAncestorId);

        return ret;
    }

    // возвращает true для значения, для которого можно получить enumerator
    public static boolean isCollection(anytype value)
    {
        return EnumeratorUtil::isEnumerable(value);
    }

    public static boolean isContainer(anytype value)
    {
        boolean ret = typeof(value) == Types::Container;

        return ret;
    }

    // нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
    public static boolean isEmpty(anytype value)
    {
        if (value)
        {
            return false;
        }

        return true;
    }

    public static boolean isEnum(anytype value, enumId enumId = 0)
    {
        return AnytypeUtil::is(value, Types::Enum, enumId);
    }

    // возвращает true для значения, для которого можно получить enumerator
    public static boolean isEnumerable(anytype value)
    {
        return EnumeratorUtil::isEnumerable(value);
    }

    // возвращает true для значения, для которого можно получить enumerator
    public static boolean isEnumerator(anytype value)
    {
        return EnumeratorUtil::isEnumerator(value);
    }

    // не создаем новых переменных в стеке
    public static boolean isEqual(anytype value1, anytype value2)
    {
        //Are both null ?
        if (!value1 && !value2)
        {
            return true;
        }

        //Is one of them null ?
        if (!value1 || !value2)
        {
            return false;
        }

        //Are their types different ?
        if (typeof(value1) != typeof(value2))
        {
            return false;
        }

        //They are the same type. Is this type void ?
        if (typeof(value1) == Types::void)
        {
            return true;
        }

        if (typeof(value1) == Types::Class)
        {
            return ObjectUtil::isEqual(value1, value2);
        }

        //Are their values different ?
        if (value1 != value2)
        {
            return false;
        }

        return true;
    }

    public static boolean isImplement(anytype value, int interfaceId = 0)
    {
        boolean ret;

        if( interfaceId && typeof(value) == Types::Class )
        {
            ret = ObjectUtil::isImplement(value, interfaceId);
        }

        return ret;
    }

    public static boolean isInt(anytype value)
    {
        boolean ret = typeof(value) == Types::Integer;

        return ret;
    }

    public static boolean isInt64(anytype value)
    {
        boolean ret = typeof(value) == Types::Int64;

        return ret;
    }

    public static boolean isList(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(List));

        return ret;
    }

    public static boolean isMap(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(Map));

        return ret;
    }

    // нормально работает с контейнерами, классами, CLR и прочими сложными объектами.
    public static boolean isNotEmpty(anytype value)
    {
        if (value)
        {
            return true;
        }

        return false;
    }

    public static boolean isNull(anytype value)
    {
        Types type = typeof(value);

        switch( type )
        {
            case Types::Class:
            case typeof(null):
                return true;
        }

        return false;
    }

    public static boolean isNumeric(anytype value)
    {
        Types type = typeof(value);
        boolean ret = TypeUtil::isNumeric(type);

        return ret;
    }

    public static boolean isPrimitive(anytype value)
    {
        Types type = typeof(value);

        switch( type )
        {
            case Types::String:
            case Types::Integer:
            case Types::Real:
            case Types::Date:
            case Types::Enum:
            case Types::UtcDateTime:
            case Types::RString:
            case Types::VarString:
            case Types::UserType:
            case Types::Guid:
            case Types::Int64:
            case Types::Time:
                return true;

            case Types::Container:
            case Types::Record:
            case Types::AnyType:
            case Types::BLOB:
            case Types::Class:
            case Types::void:
                return false;
        }

        return false;
    }

    public static boolean isRecId(anytype value)
    {
        boolean ret = typeof(value) == Types::Int64;

        return ret;
    }

    public static boolean isRecord(anytype value, int potentialAncestorId = 0)
    {
        boolean ret = AnytypeUtil::is(value, Types::Record, potentialAncestorId);

        return ret;
    }

    public static boolean isRecVersion(anytype value)
    {
        boolean ret = typeof(value) == Types::Integer;

        return ret;
    }

    public static boolean isSet(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(Set));

        return ret;
    }

    public static boolean isStack(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(Stack));

        return ret;
    }

    public static boolean isString(anytype value)
    {
        Types type = typeof(value);
        boolean ret = TypeUtil::isString(type);

        return ret;
    }

    public static boolean isStruct(anytype value)
    {
        boolean ret = AnytypeUtil::isClass(value, classnum(Struct));

        return ret;
    }

    public static boolean isValue(anytype value, anytype isValue)
    {
        Types   isType = typeof(isValue);
        Int     isId   = AnytypeUtil::id(isValue);
        boolean ret    = AnytypeUtil::is(value, isType, isId);

        return ret;
    }

    public static anytype nullValue(anytype value)
    {
        Types type = typeof(value);

        return nullValueBaseType(type);
    }

    public static int tableId(anytype value)
    {
        int id = 0;

        if( typeof(value) == Types::Record )
        {
            id = AnytypeUtil::asRecord(value).TableId;
        }

        return id;
    }

    // преобразовать value в соответствующий буфер, насколько это возможно
    public static Common toBuf(anytype value)
    {
        Common buf;

        switch(typeof(value))
        {
            case Types::Record:
                buf = value;
                break;

            case Types::Integer:
                buf = RecordUtil::makeRecord(value);
                break;

            case Types::Int64:
                buf = RecordUtil::makeRecord(int642int(value, true));
                break;

            case Types::String:
            case Types::RString:
            case Types::VarString:
                if( value )
                {
                    buf = RecordUtil::makeRecord(tablename2id(value));
                }
                break;
        }

        return buf;
    }

    public static anytype toNullValue(anytype value)
    {
        return nullValueBaseType(value);
    }

    public static str toString(anytype value, str sep = ',')
    {
        // поскольку этот метод может вызваться в отладчике еще до инициализации,
        // то в этом методе нельзя использовать методы класса и нельзя бросать исключение
        // и ни в коем случае не бросаем исключение на неинициализированные значения
        Types type = typeof(value);
        str   ret;
        Object obj;

        switch (type)
        {
            case Types::String:
            case Types::RString:
            case Types::VarString:
                ret = value;
                break;

            case Types::Container:
                ret = ConUtil::toStr(value, sep);
                break;

            case Types::Enum:
                ret = enum2str(value);
                break;

            case Types::AnyType:
                ret = '';
                break;

            case Types::Record:
                ret = RecordUtil::getValuesInfo(value);

            case Types::Class:
                if( value )
                {
                    obj = value;
                    ret = obj.toString();
                }
                else
                {
                    ret = 'null';
                }
                break;

            case Types::BLOB:
            case Types::void:
                ret = strfmt('%1', type); // не бросаем исключение! throw error(Error::unsupportedEnum(funcname(), type));
                break;

            default:
                ret = strfmt('%1', value);
                break;
        }

        return ret;
    }

    public static Types type(anytype value)
    {
        Types type = typeof(value);

        return type;
    }

    public static anytype undefined()
    {
        anytype undefined;

        return undefined;
    }
}